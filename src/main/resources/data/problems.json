[
    {
        "id": 0,
        "number": 1,
        "title": "Two Sum",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p>\n    <p>Given an array of integers, return <b>indices</b> of the two numbers such that they add up to a specific target.\n    </p>\n\n    <p>You may assume that each input would have <b><i>exactly</i></b> one solution, and you may not use the <i>same</i>\n        element twice.</p>\n\n    <p>\n        <b>Example:</b><br>\n    </p>\n    <pre>Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[<b>0</b>] + nums[<b>1</b>] = 2 + 7 = 9,\nreturn [<b>0</b>, <b>1</b>].\n</pre>\n    <p></p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    /***\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * Build a map between num and it's target\n     * for each num in nums\n     *  if num's target is in map\n     *      return the indexes of this num and the index of the target in the map\n     *  put index and target value in map\n     *\n     * return [-1, -1]\n     */\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> targetToIndex = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            // If the diff from target is in the map\n            if(targetToIndex.containsKey(nums[i]))\n                return new int[]{targetToIndex.get(nums[i]), i};\n            // Otherwise put diff and index to the map\n            targetToIndex.put(target - nums[i], i);\n        }\n        return new int[]{-1, -1};\n    }\n}",
        "tags": "0, 1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 1,
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Reverse digits of an integer.</p>\n\n    <p style=\"font-family:monospace\">\n        <b>Example1:</b> x =  123, return  321<br>\n        <b>Example2:</b> x = -123, return -321\n    </p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show spoilers.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Have you thought about this?</b>\n\n        <p>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>\n\n        <p>If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.</p>\n\n        <p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p>\n\n        <p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>\n\n    </div>\n\n</div>",
        "solution": "public class Solution {\n    public int reverse(int x) {\n        if(x < 10 && x > -10) return x;\n\n        int absX = x > 0 ? x : -x;\n        long longRes = 0;\n        while(absX > 0){\n            longRes = longRes*10 + absX % 10;\n            if(longRes > Integer.MAX_VALUE || -longRes < Integer.MIN_VALUE)\n                return 0;\n            absX /= 10;\n        }\n\n        return x > 0 ? (int)longRes : -1*(int)longRes;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 2,
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>Determine whether an integer is a palindrome. Do this without extra space.</p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show spoilers.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Some hints:</b>\n\n        <p>Could negative integers be palindromes? (ie, -1)</p>\n\n        <p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>\n\n        <p>You could also try reversing an integer. However, if you have solved the problem \"Reverse Integer\", you know that the reversed integer might overflow. How would you handle such case?</p>\n\n        <p>There is a more generic way of solving this problem.</p>\n\n    </div><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public boolean isPalindrome(int x) {\n        //negative numbers are not palindrome\n        if (x < 0) return false;\n\n        // find the most siginificant digit\n        int div = 1;\n        while (x / div >= 10) {\n            div *= 10;\n        }\n\n        // stop till x is 0\n        while (x != 0) {\n            int left = x / div; // left digit\n            int right = x % 10; // right digit\n\n            if (left != right)\treturn false;\n            // remove first and last digit\n            x = (x % div) / 10;\n            // reduce dividor\n            div /= 100;\n        }\n        return true;\n    }\n}",
        "tags": "3",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 3,
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a roman numeral, convert it to an integer.</p>\n\n    <p>Input is guaranteed to be within the range from 1 to 3999.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int romanToInt(String s) {\n        if (s.length() == 0)\n            return 0;\n\n        List<Character> romans = Arrays.asList('I', 'V', 'X', 'L', 'C', 'D', 'M');\n        int[] numbers = {1, 5, 10, 50, 100, 500, 1000};\n\n        if (s.length() == 1)\n            return numbers[romans.indexOf(s.charAt(0))];\n\n        int index = 0, result = 0;\n        while (index < s.length() - 1) {\n            // If cur char smaller than next\n            if (romans.indexOf(s.charAt(index)) >= romans.indexOf(s.charAt(index + 1))) {\n                result += numbers[romans.indexOf(s.charAt(index))];\n                index++;\n            } else {\n                result += numbers[romans.indexOf(s.charAt(index + 1))]\n                        - numbers[romans.indexOf(s.charAt(index))];\n                index += 2;\n            }\n        }\n        // Deal with the last char. Need to check since we have index += 2\n        if (index == s.length() - 1)\n            result += numbers[romans.indexOf(s.charAt(index))];\n\n        return result;\n    }\n}",
        "tags": "3, 5",
        "companies": "",
        "specialtags": "2"
    },
    {
        "id": 4,
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write a function to find the longest common prefix string amongst an array of strings.\n</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) return \"\";\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < strs[0].length(); i++) {\n            // Check each char of first string\n            int strsInd = 0;\n            while (strsInd < strs.length && i < strs[strsInd].length() &&\n                    strs[strsInd].charAt(i) == strs[0].charAt(i))\n                strsInd++;\n            // If all strings have the char\n            if (strsInd == strs.length) {\n                res.append(strs[0].charAt(i));\n            } else\n                return res.toString();\n        }\n        return strs[0];\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 5,
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>\n\n    <p>The brackets must close in the correct order, <code>\"()\"</code> and <code>\"()[]{}\"</code> are all valid but <code>\"(]\"</code> and <code>\"([)]\"</code> are not.</p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean isValid(String s) {\n        Deque<Character> stack = new ArrayDeque<>();\n        int i = 0;\n        while (i < s.length()) {\n            if (s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[')\n                stack.push(s.charAt(i));\n            else if (s.charAt(i) == ')' && (stack.isEmpty() || stack.pop() != '(') ||\n                    s.charAt(i) == '}' &&(stack.isEmpty() || stack.pop() != '{') ||\n                    s.charAt(i) == ']' && (stack.isEmpty() || stack.pop() != '[')){\n                return false;\n            }\n            i++;\n        }\n        return stack.isEmpty();\n    }\n}",
        "tags": "5, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 6,
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode fakeHead = new ListNode(0);\n        ListNode current = fakeHead;\n\n        while (l1 != null || l2 != null) {\n            if (l1 == null || (l2 != null && l1.val >= l2.val)) {\n                current.next = l2;\n                current = l2;\n                l2 = l2.next;\n            } else {\n                current.next = l1;\n                current = l1;\n                l1 = l1.next;\n            }\n        }\n        return fakeHead.next;\n    }\n}",
        "tags": "2",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 7,
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a sorted array, remove the duplicates in place such that each element appear only <i>once</i> and return the new length.</p>\n\n    <p>\n        Do not allocate extra space for another array, you must do this in place with constant memory.\n    </p>\n\n    <p>\n        For example,<br>\n        Given input array <i>nums</i> = <code>[1,1,2]</code>,\n    </p>\n    <p>\n        Your function should return length = <code>2</code>, with the first two elements of <i>nums</i> being <code>1</code> and <code>2</code> respectively. It doesn't matter what you leave beyond the new length.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length <= 1)\n            return nums.length;\n\n        int endIndex = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[endIndex]){\n                endIndex++;\n                nums[endIndex] = nums[i];\n            }\n        }\n        return endIndex + 1;\n    }\n}",
        "tags": "0, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 8,
        "number": 27,
        "title": "Remove Element",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array and a value, remove all instances of that value in place and return the new length.\n</p>\n\n    <p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>\n\n    <p>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</p>\n\n    <p>\n        <b>Example:</b><br>\n        Given input array <i>nums</i> = <code>[3,2,2,3]</code>, <i>val</i> = <code>3</code>\n    </p>\n\n    <p>Your function should return length = 2, with the first two elements of <i>nums</i> being 2.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int removeElement(int[] nums, int val) {\n        if (nums.length == 0){\n            return 0;\n        }\n\n        if (nums.length == 1) {\n            return nums[0] == val ? 0 : 1;\n        }\n\n        int firstIndex = 0;\n        int lastIndex = nums.length - 1;\n        while (firstIndex < lastIndex) {\n            if (nums[firstIndex] != val) {\n                firstIndex++;\n                continue;\n            }\n            nums[firstIndex] += nums[lastIndex];\n            nums[lastIndex] = nums[firstIndex] - nums[lastIndex];\n            nums[firstIndex] = nums[firstIndex] - nums[lastIndex];\n            lastIndex--;\n        }\n\n        return nums[firstIndex] == val ? firstIndex : firstIndex + 1;\n    }\n}",
        "tags": "0, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 9,
        "number": 28,
        "title": "Implement strStr()",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Implement strStr().\n</p>\n    <p>\n        Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle == null || haystack == null || needle.length() > haystack.length())\n            return -1;\n        if (needle.length() == 0){\n            return 0;\n        }\n\n        int[] overlay = getOverlay(needle);\n        int i = 0;\n        while (i <= haystack.length() - needle.length()){\n            int j = 0;\n            while(j < needle.length()){\n                if (haystack.charAt(i+j) != needle.charAt(j)){\n                    i = j == 0 ? i+1 : i+j-overlay[j-1];\n                    break;\n                }\n                j++;\n            }\n            if(j == needle.length()){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Generate the prefix function for pattern itself\n    private int[] getOverlay(String pattern){\n        int[] res = new int[pattern.length()];\n        res[0] = 0;\n        for(int i = 1; i < pattern.length(); i++){\n            int index = res[i-1];\n            while (index > 0 && pattern.charAt(index) != pattern.charAt(i))\n                index = res[index-1];\n            res[i] = (pattern.charAt(index) == pattern.charAt(i)) ? index + 1 : 0;\n        }\n        return res;\n    }\n}",
        "tags": "4, 5",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 10,
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n\n    <p>You may assume no duplicates in the array.</p>\n\n    <p>\n        Here are few examples.<br>\n        <code>[1,3,5,6]</code>, 5 -> 2<br>\n        <code>[1,3,5,6]</code>, 2 -> 1<br>\n        <code>[1,3,5,6]</code>, 7 -> 4<br>\n        <code>[1,3,5,6]</code>, 0 -> 0\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int low = 0;\n        int high = nums.length - 1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] > target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n}",
        "tags": "0, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 11,
        "number": 38,
        "title": "Count and Say",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>\n    <pre>1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n</pre>\n\n    <p>\n        <code>1</code> is read off as <code>\"one 1\"</code> or <code>11</code>.<br>\n        <code>11</code> is read off as <code>\"two 1s\"</code> or <code>21</code>.<br>\n        <code>21</code> is read off as <code>\"one 2</code>, then <code>one 1\"</code> or <code>1211</code>.<br>\n    </p>\n\n    <p>\n        Given an integer <i>n</i>, generate the <i>n</i><sup>th</sup> term of the count-and-say sequence.\n    </p>\n\n    <p>\n        Note: Each term of the sequence of integers will be represented as a string.\n    </p>\n\n    <p><b>Example 1:</b>\n    </p><pre><b>Input:</b> 1\n<b>Output:</b> \"1\"\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre><b>Input:</b> 4\n<b>Output:</b> \"1211\"\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String countAndSay(int n) {\n        StringBuilder curr = new StringBuilder(\"1\");\n        for (int i = 1; i < n; i++) {\n            StringBuilder prev = curr;\n            curr = new StringBuilder();\n            int count = 1;\n            char say = prev.charAt(0);\n\n            for (int j = 1, len = prev.length(); j < len; j++) {\n                if (prev.charAt(j) != say) {\n                    curr.append(count).append(say);\n                    count = 1;\n                    say = prev.charAt(j);\n                } else count++;\n            }\n            curr.append(count).append(say);\n        }\n        return curr.toString();\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 12,
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\n</p>\n    <p>\n        For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>\n        the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.\n    </p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show more practice.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>More practice:</b>\n\n        <p>If you have figured out the O(<i>n</i>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n    // DP solution\n    public int maxSubArray(int[] nums) {\n        int max = Integer.MIN_VALUE, sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum = (sum < 0) ? nums[i] : (sum + nums[i]);\n            if (sum > max)\n                max = sum;\n        }\n        return max;\n    }\n\n    // Divide and Conquer\n    public int maxSubArray(int[] nums) {\n        return divide(nums, 0, nums.length - 1);\n    }\n\n    int divide(int nums[], int low, int high) {\n        if (low == high){\n            return nums[low];\n        }\n        if (low == high - 1)\n            return Math.max(nums[low] + nums[high], Math.max(nums[low], nums[high]));\n        int mid = low + (high - low) / 2;\n        int lmax = divide(nums, low, mid - 1);\n        int rmax = divide(nums, mid + 1, high);\n        int mmax = nums[mid];\n        int tmp = mmax;\n        for (int i = mid - 1; i >= low; i--) {\n            tmp += nums[i];\n            if (tmp > mmax){\n                mmax = tmp;\n            }\n        }\n        tmp = mmax;\n        for (int i = mid + 1; i <= high; i++) {\n            tmp += nums[i];\n            if (tmp > mmax){\n                mmax = tmp;\n            }\n        }\n        return Math.max(mmax, Math.max(lmax, rmax));\n    }\n}",
        "tags": "0, 8, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 13,
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string <i>s</i> consists of upper/lower-case alphabets and empty space characters <code>' '</code>, return the length of last word in the string.</p>\n\n    <p>If the last word does not exist, return 0.</p>\n\n    <p><b>Note:</b> A word is defined as a character sequence consists of non-space characters only.</p>\n\n    <p>\n        For example, <br>\n        Given <i>s</i> = <code>\"Hello World\"</code>,<br>\n        return <code>5</code>.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int lengthOfLastWord(String s) {\n        int count = 0;\n        if(s.length()==0) return 0;\n        int len = s.length()-1;\n\n        while(len>=0 && s.charAt(len) == ' ')\n            len--;\n\n        if(len<0) return 0;\n\n\n        for(int i=len; i>=0; i--){\n            if(s.charAt(i) != ' ')\n                count++;\n            else\n                break;\n        }\n        return count;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 14,
        "number": 66,
        "title": "Plus One",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a non-negative integer represented as a <b>non-empty</b> array of digits, plus one to the integer.</p>\n\n    <p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p>\n\n    <p>The digits are stored such that the most significant digit is at the head of the list.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int[] plusOne(int[] digits) {\n        int carry = 1;\n        for(int i=digits.length-1; i >= 0; i--){\n            if((digits[i] + carry) < 10){\n                digits[i] = digits[i] + carry;\n                return digits;\n            }else{\n                digits[i] = digits[i] + carry - 10;\n                carry = 1;\n            }\n        }\n\n        int[] res = new int[digits.length+1];\n        res[0] = 1;\n        return res;\n    }\n}",
        "tags": "0, 3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 15,
        "number": 67,
        "title": "Add Binary",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given two binary strings, return their sum (also a binary string).\n</p>\n\n    <p>\n        For example,<br>\n        a = <code>\"11\"</code><br>\n        b = <code>\"1\"</code><br>\n        Return <code>\"100\"</code>.\n    </p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public String addBinary(String a, String b) {\n        int aInd = a.length() - 1;\n        int bInd = b.length() - 1;\n        int carry = 0;\n        StringBuilder res = new StringBuilder();\n        while(aInd >= 0 || bInd >= 0){\n            int sum = carry;\n            if(aInd >= 0 && a.charAt(aInd) == '1')\n                sum += 1;\n            if(bInd >= 0 && b.charAt(bInd) == '1')\n                sum += 1;\n            res.insert(0, sum % 2);\n            carry = sum / 2;\n            aInd--;\n            bInd--;\n        }\n        if(carry > 0)\n            res.insert(0, '1');\n        return res.toString();\n    }\n}",
        "tags": "3, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 16,
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement <code>int sqrt(int x)</code>.</p>\n\n    <p>Compute and return the square root of <i>x</i>.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int mySqrt(int x) {\n        if(x <= 1) return x;\n        int start = 0, end = x/2 + 1;\n        while(start <= end) {\n            int mid = start + (end-start)/2;\n            if(x/mid == mid)\n                return mid;\n            else if(x/mid < mid)\n                end = mid-1;\n            else\n                start = mid+1;\n        }\n        return end;\n    }\n}",
        "tags": "2, 6",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 17,
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>You are climbing a stair case. It takes <i>n</i> steps to reach to the top.</p>\n\n    <p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n    </p>\n\n    <p><b>Note:</b> Given <i>n</i> will be a positive integer.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int climbStairs(int n) {\n        int[] steps = new int[n+1];\n        if(n==1) return 1;\n        if(n==2) return 2;\n\n        steps[1] = 1;\n        steps[2] = 2;\n        int i = 3;\n\n        while(i <= n){\n            steps[i] = steps[i-1] + steps[i-2];\n            i++;\n        }\n\n        return steps[n];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 18,
        "number": 83,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a sorted linked list, delete all duplicates such that each element appear only <i>once</i>.\n</p>\n    <p>\n        For example,<br>\n        Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>\n        Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null || head.next == null) return head;\n\n        ListNode cur = head;\n        while(cur != null && cur.next != null){\n            while(cur.val == cur.next.val){\n                cur.next = cur.next.next;\n                if(cur.next == null)\n                    break;\n            }\n            cur = cur.next;\n        }\n        return head;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 19,
        "number": 88,
        "title": "Merge Sorted Array",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given two sorted integer arrays <i>nums1</i> and <i>nums2</i>, merge <i>nums2</i> into <i>nums1</i> as one sorted array.</p>\n\n    <p>\n        <b>Note:</b><br>\n        You may assume that <i>nums1</i> has enough space (size that is greater or equal to <i>m</i> + <i>n</i>) to hold additional elements from <i>nums2</i>. The number of elements initialized in <i>nums1</i> and <i>nums2</i> are <i>m</i> and <i>n</i> respectively.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1;\n        int j = n - 1;\n        int k = m + n - 1;\n        while (i > -1 && j > -1){\n            nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];\n        }\n        while (j > -1){\n            nums1[k--] = nums2[j--];\n        }\n    }\n}",
        "tags": "0, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 20,
        "number": 100,
        "title": "Same Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two binary trees, write a function to check if they are equal or not.\n</p>\n\n    <p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n\n        return (p.val == q.val) && isSameTree(p.left, q.left)\n                && isSameTree(p.right, q.right);\n    }\n}",
        "tags": "12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 21,
        "number": 101,
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\n\n    <p>\n        For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:\n    </p><pre>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</pre>\n    <p></p>\n    <p>\n        But the following <code>[1,2,2,null,3,null,3]</code>  is not:<br>\n    </p><pre>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</pre>\n    <p></p>\n\n    <p>\n        <b>Note:</b><br>\n        Bonus points if you could solve it both recursively and iteratively.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root == null) return true;\n        return isSymmetric(root.left, root.right);\n    }\n\n    private boolean isSymmetric(TreeNode leftSub, TreeNode rightSub){\n        if(leftSub == null && rightSub == null) return true;\n        if(leftSub == null || rightSub == null) return false;\n\n        if(leftSub.val == rightSub.val){\n            return isSymmetric(leftSub.left, rightSub.right) && isSymmetric(leftSub.right, rightSub.left);\n        }\n\n        return false;\n    }\n}",
        "tags": "12, 14, 19",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 22,
        "number": 104,
        "title": "Maximum Depth of Binary Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, find its maximum depth.</p>\n\n    <p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n\n        if(root.left == null && root.right == null) return 1;\n\n        if(root.left == null)\n            return 1+maxDepth(root.right);\n        else if(root.right == null)\n            return 1+maxDepth(root.left);\n        else\n            return 1+Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}",
        "tags": "12, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 23,
        "number": 107,
        "title": "Binary Tree Level Order Traversal II",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, return the <i>bottom-up level order</i> traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br>\n    </p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n    <p></p>\n    <p>\n        return its bottom-up level order traversal as:<br>\n    </p><pre>[\n  [15,7],\n  [9,20],\n  [3]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if(root == null) return res;\n\n        Deque<TreeNode> curLevel = new ArrayDeque<TreeNode>();\n        Deque<TreeNode> nextLevel = new ArrayDeque<TreeNode>();\n        curLevel.addLast(root);\n        Deque<List<Integer>> listStack = new ArrayDeque<List<Integer>>();\n\n        while(!curLevel.isEmpty()){\n            List<Integer> curList = new ArrayList<Integer>();\n            for(TreeNode n : curLevel){\n                curList.add(n.val);\n                if(n.left != null) nextLevel.addLast(n.left);\n                if(n.right != null) nextLevel.addLast(n.right);\n            }\n            listStack.addFirst(curList);\n            curLevel = new ArrayDeque<TreeNode>(nextLevel);\n            nextLevel.clear();\n        }\n\n        for(List<Integer> l : listStack){\n            res.add(l);\n        }\n        return res;\n    }\n}",
        "tags": "12, 19",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 24,
        "number": 108,
        "title": "Convert Sorted Array to Binary Search Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode sortedArrayToBST(int[] num) {\n        if(num.length == 0) return null;\n\n        int startIndex = 0, endIndex = num.length - 1;\n        int midIndex = (startIndex + endIndex)/2;\n\n        TreeNode root = new TreeNode(num[midIndex]);\n        if(num.length == 1) return root;\n\n        root.left = arrayToBST(num, startIndex, midIndex-1);\n        root.right = arrayToBST(num, midIndex+1, endIndex);\n\n        return root;\n    }\n\n    public TreeNode arrayToBST(int[] num, int start, int end){\n        TreeNode root = null;\n        if(start <= end){\n            int mid = (start + end)/2;\n            root = new TreeNode(num[mid]);\n            if(start == end)\n                return root;\n            root.left = arrayToBST(num, start, mid-1);\n            root.right = arrayToBST(num, mid+1, end);\n        }\n\n        return root;\n    }\n}",
        "tags": "12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 25,
        "number": 110,
        "title": "Balanced Binary Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, determine if it is height-balanced.\n</p>\n\n    <p>\n        For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <i>every</i> node never differ by more than 1.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isBalanced(TreeNode root) {\n        if(root == null) return true;\n\n        int leftHeight = treeHeight(root.left);\n        int rightHeight = treeHeight(root.right);\n\n        if(Math.abs(leftHeight-rightHeight) <=1)\n            return isBalanced(root.left) && isBalanced(root.right);\n        else\n            return false;\n    }\n\n    private int treeHeight(TreeNode root){\n        if(root == null) return 0;\n        int left = treeHeight(root.left);\n        int right = treeHeight(root.right);\n\n        return 1+Math.max(left, right);\n    }\n}",
        "tags": "2, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 26,
        "number": 111,
        "title": "Minimum Depth of Binary Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, find its minimum depth.</p>\n\n    <p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n        if (root.left == null && root.right == null)\n            return 1;\n        if (root.left == null)\n            return 1 + minDepth(root.right);\n        if (root.right == null)\n            return 1 + minDepth(root.left);\n        return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n    }\n}",
        "tags": "2, 14, 19",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 27,
        "number": 112,
        "title": "Path Sum",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n</p>\n\n    For example:<br>\n    Given the below binary tree and <code>sum = 22</code>,\n    <pre>              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n</pre>\n\n    <p>\n        return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null) return false;\n\n        if(root.left == null && root.right == null)\n            return (sum == root.val);\n\n        return hasPathSum(root.left, sum-root.val) ||\n                hasPathSum(root.right, sum-root.val);\n    }\n}",
        "tags": "2, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 28,
        "number": 118,
        "title": "Pascals Triangle",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given <i>numRows</i>, generate the first <i>numRows</i> of Pascal's triangle.</p>\n\n    <p>\n        For example, given <i>numRows</i> = 5,<br>\n        Return\n    </p><pre>[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if (numRows == 0) return res;\n\n        List<Integer> curRow = new ArrayList<Integer>();\n        curRow.add(1);\n        res.add(curRow);\n        if (numRows == 1)\n            return res;\n\n        List<Integer> preRow = curRow;\n        for (int i = 2; i < numRows + 1; i++) {\n            curRow = new ArrayList<Integer>();\n            for (int j = 0; j < i; j++) {\n                if (j == 0) {\n                    curRow.add(preRow.get(0));\n                } else if (j == i - 1) {\n                    curRow.add(preRow.get(j - 1));\n                } else {\n                    curRow.add(preRow.get(j) + preRow.get(j - 1));\n                }\n            }\n            res.add(curRow);\n            preRow = curRow;\n        }\n\n        return res;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 29,
        "number": 119,
        "title": "Pascals Triangle II",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an index <i>k</i>, return the <i>k</i><sup>th</sup> row of the Pascal's triangle.</p>\n\n    <p>\n        For example, given <i>k</i> = 3,<br>\n        Return <code>[1,3,3,1]</code>.\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        Could you optimize your algorithm to use only <i>O</i>(<i>k</i>) extra space?\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> row = new ArrayList<Integer>();\n        row.add(1);\n        for (int i = 1; i <= rowIndex; i++) {\n            List<Integer> preRow = row;\n            row = new ArrayList<Integer>();\n            for (int j = 0; j <= i; j++) {\n                int val = ((j > 0) ? preRow.get(j - 1) : 0)\n                        + ((j < preRow.size()) ? preRow.get(j) : 0);\n                row.add(val);\n            }\n        }\n        return row;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 30,
        "number": 121,
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n    <p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre>Input: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre>Input: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0.\n</pre>\n    <p></p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices == null || prices.length <= 1) return 0;\n        // Track min value so far\n        int minSofar = prices[0];\n        int maxProfit = 0;\n        for(int i = 1; i < prices.length; i++){\n            if(prices[i] < minSofar){\n                minSofar = prices[i]; // update min so far\n            } else {\n                // update max profit\n                maxProfit = Math.max(prices[i] - minSofar, maxProfit);\n            }\n        }\n        return maxProfit;\n    }\n}",
        "tags": "0, 9",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 31,
        "number": 122,
        "title": "Best Time to Buy and Sell Stock II",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n    <p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices == null || prices.length <= 1) return 0;\n        int maxProfit = 0;\n        for(int i = 1 ; i < prices.length; i++){\n            if(prices[i] > prices[i-1]){\n                maxProfit += prices[i] - prices[i-1];\n            }\n        }\n        return maxProfit;\n    }\n}",
        "tags": "0, 18",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 32,
        "number": 125,
        "title": "Valid Palindrome",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n</p>\n\n    <p>\n        For example,<br>\n        <code>\"A man, a plan, a canal: Panama\"</code> is a palindrome.<br>\n        <code>\"race a car\"</code> is <i>not</i> a palindrome.\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        Have you consider that the string might be empty? This is a good question to ask during an interview.</p>\n    <p>\n        For the purpose of this problem, we define empty string as valid palindrome.\n    </p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public boolean isPalindrome(String s) {\n        if(s == null) return false;\n        // Replace char that is not in the list\n        s = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n        if(s.length() == 0) return true;\n        // Compare char from both ends\n        for(int i = 0; i < s.length() ; i++){\n            if(s.charAt(i) != s.charAt(s.length() - 1 - i)){\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "tags": "4, 5",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 33,
        "number": 136,
        "title": "Single Number",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array of integers, every element appears <i>twice</i> except for one. Find that single one.</p>\n\n    <p>\n        <b>Note:</b><br>\n        Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int singleNumber(int[] A) {\n        if (A.length == 0) return -1;\n        int result = A[0];\n\n        for (int i = 1; i < A.length; i++) {\n            result ^= A[i];\n        }\n\n        return result;\n    }\n}",
        "tags": "1, 22",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 34,
        "number": 141,
        "title": "Linked List Cycle",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a linked list, determine if it has a cycle in it.\n</p>\n\n    <p>\n        Follow up:<br>\n        Can you solve it without using extra space?\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) return false;\n\n        ListNode slow = head.next, fast = head.next.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n}",
        "tags": "2, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 35,
        "number": 155,
        "title": "Min Stack",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n</p><ul>\n    <li>\n        push(x) -- Push element x onto stack.\n    </li>\n    <li>\n        pop() -- Removes the element on top of the stack.\n    </li>\n    <li>\n        top() -- Get the top element.\n    </li>\n    <li>\n        getMin() -- Retrieve the minimum element in the stack.\n    </li>\n</ul>\n    <p></p>\n\n    <p><b>Example:</b><br>\n    </p><pre>MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; Returns -3.\nminStack.pop();\nminStack.top();      --&gt; Returns 0.\nminStack.getMin();   --&gt; Returns -2.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "class MinStack {\n    Deque<Integer> stackContent = new ArrayDeque<Integer>();\n    Deque<Integer> stackMinVal = new ArrayDeque<Integer>();\n\n    public void push(int x) {\n        this.stackContent.push(x);\n        if (this.stackMinVal.isEmpty() || x <= this.stackMinVal.peek()) {\n            this.stackMinVal.push(x);\n        }\n    }\n\n    public void pop() {\n        if (this.stackContent.isEmpty()) return;\n        if (this.stackContent.peek().equals(this.stackMinVal.peek())) {\n            this.stackMinVal.pop();\n        }\n        this.stackContent.pop();\n    }\n\n    public int top() throws IndexOutOfBoundsException {\n        if (this.stackContent.isEmpty())\n            throw new IndexOutOfBoundsException();\n        return this.stackContent.peek();\n    }\n\n    public int getMin() {\n        if (this.stackMinVal.isEmpty())\n            return -1;\n        return this.stackMinVal.peek();\n    }\n}\n",
        "tags": "10, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 36,
        "number": 157,
        "title": "Read N Characters Given Read4",
        "difficulty": "Easy",
        "description": "<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    The API:&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">int read4(char *buf)</code>&nbsp;reads 4 characters at a time from a file.</div>\n\n<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    The API:&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">int read4(char *buf)</code>&nbsp;reads 4 characters at a time from a file.</div>\n\n<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    By using the&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">read4</code>&nbsp;API, implement the function&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">int read(char *buf, int n)</code>&nbsp;that reads&nbsp;<i style=\"box-sizing: border-box;\">n</i>&nbsp;characters from the file.</div>\n<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    <span style=\"box-sizing: border-box; font-weight: 700;\">Note:</span><br>\n    The&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">read</code>&nbsp;function will only be called once for each test case.</div>\n",
        "solution": "public class Solution extends Reader4 {\n    // 时间 O(N) 空间 O(1)\n    public int read(char[] buf, int n) {\n        for(int i = 0; i < n; i += 4){\n            char[] tmp = new char[4];\n            // 将数据读入临时数组\n            int len = read4(tmp);\n            // 将临时数组拷贝至buf数组，这里拷贝的长度是本次读到的个数和剩余所需个数中较小的\n            System.arraycopy(tmp, 0, buf, i, Math.min(len, n - i));\n            // 如果读不满4个，说明已经读完了，返回总所需长度和目前已经读到的长度的较小的\n            if(len < 4) return Math.min(i + len, n);\n        }\n        // 如果循环内没有返回，说明读取的字符是4的倍数\n        return n;\n    }\n}",
        "tags": "0",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 37,
        "number": 160,
        "title": "Intersection of Two Linked Lists",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n    <br>\n    <p>For example, the following two linked lists: </p>\n    <pre>A:          a1 -> a2\n                   \\\n                     c1 -> c2 -> c3\n                   /\nB:     b1 -> b2 -> b3\n</pre>\n    <p>begin to intersect at node c1.</p>\n    <br>\n    <p><b>Notes:</b>\n    </p><ul>\n    <li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n    <li>The linked lists must retain their original structure after the function returns. </li>\n    <li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n    <li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        int lenA = getLength(headA);\n        int lenB = getLength(headB);\n\n        int cut = lenA - lenB;\n        while (cut > 0) {\n            headA = headA.next;\n            cut--;\n        }\n        while (cut < 0) {\n            headB = headB.next;\n            cut++;\n        }\n\n        while (headA != null && headB != null) {\n            if (headA == headB) return headA;\n            headA = headA.next;\n            headB = headB.next;\n        }\n        return null;\n    }\n\n    static int getLength(ListNode head) {\n        int len = 0;\n        while (head != null) {\n            head = head.next;\n            len++;\n        }\n        return len;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 38,
        "number": 167,
        "title": "Two Sum II - Input array is sorted",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array of integers that is already <b><i>sorted in ascending order</i></b>, find two numbers such that they add up to a specific target number.</p>\n\n    <p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n\n    <p>You may assume that each input would have <i>exactly</i> one solution and you may not use the <i>same</i> element twice.</p>\n\n    <p style=\"font-family:monospace\">\n        <b>Input:</b> numbers={2, 7, 11, 15}, target=9<br>\n        <b>Output:</b> index1=1, index2=2\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int[] indice = new int[2];\n        if (numbers == null || numbers.length < 2)\n            return indice;\n        int left = 0, right = numbers.length - 1;\n        while (left < right) {\n            int v = numbers[left] + numbers[right];\n            if (v == target) {\n                indice[0] = left + 1;\n                indice[1] = right + 1;\n                break;\n            } else if (v > target) {\n                right--;\n            } else {\n                left++;\n            }\n        }\n        return indice;\n    }\n}",
        "tags": "0, 4, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 39,
        "number": 168,
        "title": "Excel Sheet Column Title",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>\n\n    <p>For example:</p>\n    <pre>    1 -&gt; A\n    2 -&gt; B\n    3 -&gt; C\n    ...\n    26 -&gt; Z\n    27 -&gt; AA\n    28 -&gt; AB </pre>\n\n</div>",
        "solution": "public class Solution {\n    public String convertToTitle(int n) {\n        StringBuilder res = new StringBuilder();\n        while (n > 0) {\n            res.insert(0, (char) ('A' + (n - 1) % 26));\n            n = (n - 1) / 26;\n        }\n        return res.toString();\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 40,
        "number": 169,
        "title": "Majority Element",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array of size <i>n</i>, find the majority element. The majority element is the element that appears <b>more than</b> <code> |_n/2_|</code> times.</p>\n\n    <p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n\n</div>",
        "solution": "public class Solution {\n    public int majorityElement(int[] num) {\n        int majorityElement = num[0], count = 1;\n        for (int i = 1; i < num.length; i++) {\n            if (num[i] == majorityElement)\n                count++;\n            else {\n                count--;\n                if (count == 0) {\n                    majorityElement = num[i];\n                    count = 1;\n                }\n            }\n        }\n        count = 0;\n        for (int i = 0; i < num.length; i++)\n            if (num[i] == majorityElement) count++;\n        return (count > num.length / 2) ? majorityElement : -1;\n    }\n}",
        "tags": "0, 7, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 41,
        "number": 171,
        "title": "Excel Sheet Column Number",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Related to question <a href=\"https://leetcode.com/problems/excel-sheet-column-title/\">Excel Sheet Column Title</a></p>\n    <p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\n\n    <p>For example:</p>\n    <pre>    A -&gt; 1\n    B -&gt; 2\n    C -&gt; 3\n    ...\n    Z -&gt; 26\n    AA -&gt; 27\n    AB -&gt; 28 </pre>\n\n</div>",
        "solution": "public class Solution {\n    public int titleToNumber(String s) {\n        if (s.length() == 0) return 0;\n        int num = 0;\n        for (int i = 0; i < s.length(); i++)\n            num = num * 26 + s.charAt(i) - 'A' + 1;\n        return num;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 42,
        "number": 172,
        "title": "Factorial Trailing Zeroes",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer <i>n</i>, return the number of trailing zeroes in <i>n</i>!.</p>\n\n    <p><b>Note: </b>Your solution should be in logarithmic time complexity.</p>\n\n</div>",
        "solution": "public class Solution {\n    public int trailingZeroes(int n) {\n        if (n < 0) return -1;\n        if (n < 5) return 0;\n        int count = 0;\n        for (long i = 5; n / i >= 1; i *= 5) {\n            count += n / i;\n        }\n        return count;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 43,
        "number": 189,
        "title": "Rotate Array",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Rotate an array of <i>n</i> elements to the right by <i>k</i> steps.</p>\n    <p>For example, with <i>n</i> = 7 and <i>k</i> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>. </p>\n\n    <p><b>Note:</b><br>\n        Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n    </p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">[show hint]</a></p>\n    <div class=\"spoilers\" style=\"display: block;\"><b>Hint:</b><br>\n        Could you do it in-place with O(1) extra space?\n    </div>\n\n</div>",
        "solution": "public class Solution {\n    public void rotate(int[] nums, int k) {\n        if (nums.length <= 1) return;\n        k = k % nums.length;\n\n        reverseArray(nums, 0, nums.length - 1 - k);\n        reverseArray(nums, nums.length - k, nums.length - 1);\n        reverseArray(nums, 0, nums.length - 1);\n    }\n\n    static void reverseArray(int[] nums, int start, int end) {\n        while (start < end) {\n            nums[start] += nums[end];\n            nums[end] = nums[start] - nums[end];\n            nums[start] = nums[start] - nums[end];\n            start++;\n            end--;\n        }\n    }\n}",
        "tags": "0",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 44,
        "number": 190,
        "title": "Reverse Bits",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Reverse bits of a given 32 bits unsigned integer.</p>\n\n    <p>For example, given input 43261596 (represented in binary as <b>00000010100101000001111010011100</b>), return 964176192 (represented in binary as <b>00111001011110000010100101000000</b>).</p>\n\n    <p>\n        <b>Follow up</b>:<br>\n        If this function is called many times, how would you optimize it?\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int firstBitInd = 0, lastBitInd = 31;\n        while(firstBitInd < lastBitInd){\n            int firstBit = (n >> firstBitInd) & 1;\n            int lastBit = (n >> lastBitInd) & 1;\n            // Set last bit\n            if(firstBit > 0)\n                n |= (1 << lastBitInd);\n            else\n                n &= ~(1 << lastBitInd);\n            // Set first bit\n            if(lastBit > 0)\n                n |= (1 << firstBitInd);\n            else\n                n &= ~(1 << firstBitInd);\n            firstBitInd++;\n            lastBitInd--;\n        }\n        return n;\n    }\n}",
        "tags": "22",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 45,
        "number": 191,
        "title": "Number of 1 Bits",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\">Hamming weight</a>).</p>\n\n    <p>For example, the 32-bit integer '11' has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.</p>\n\n</div>",
        "solution": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int ans = 0;\n        while (n != 0) {\n            ans += n & 1;\n            n >>>= 1;\n        }\n        return ans;\n    }\n\n    // n & (n - 1) drops the lowest set bit. It's a neat little bit trick.\n}",
        "tags": "22",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 46,
        "number": 198,
        "title": "House Robber",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n    <p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <b>without alerting the police</b>.</p>\n\n</div>",
        "solution": "public class Solution {\n    public int rob(int[] num) {\n        // Algorithm\n        // case 1: current house is not robbed:\n        //      Max. amount is Max(Max Amount When last house is robbed,\n        //             Max Amount when last house is not robbed)\n        // case 2: current house is robbed:\n        //   Max. amount is Max Amount when last house is not robbed + current house's value\n        // repeat this from first two until the last\n        // Compare case 1 and case 2 to return the Max\n        if(num.length == 0) return 0;\n        if(num.length == 1) return num[0];\n        if(num.length == 2) return Math.max(num[0], num[1]);\n\n        // start from index = 2\n        int lastNotRobbed = Math.max(num[0], num[1]);\n        int lastRobbed = num[0] + num[2];\n        int index = 3;\n\n        while(index <= num.length-1){\n            int tempLastNotRobbed = Math.max(lastNotRobbed, lastRobbed);\n            lastRobbed = lastNotRobbed + num[index++];\n            lastNotRobbed = tempLastNotRobbed;\n        }\n\n        return Math.max(lastRobbed, lastNotRobbed);\n    }\n}",
        "tags": "9",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 47,
        "number": 202,
        "title": "Happy Number",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write an algorithm to determine if a number is \"happy\".</p>\n\n    <p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>\n\n    <p><b>Example:&nbsp;</b>19 is a happy number</p>\n\n    <ul style=\"list-style: none;\">\n        <li>1<sup>2</sup> + 9<sup>2</sup> = 82</li>\n        <li>8<sup>2</sup> + 2<sup>2</sup> = 68</li>\n        <li>6<sup>2</sup> + 8<sup>2</sup> = 100</li>\n        <li>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</li>\n    </ul>\n</div>",
        "solution": "public class Solution {\n    public boolean isHappy(int n) {\n        Set<Integer> wordMap = new HashSet<Integer>();\n        while(n != 1 && !wordMap.contains(n)){\n            wordMap.add(n);\n            int temp = n;\n            n = 0;\n            while(temp >= 1){\n                n += (temp%10)*(temp%10);\n                temp /= 10;\n            }\n        }\n        return n == 1;\n    }\n}",
        "tags": "1, 3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 48,
        "number": 203,
        "title": "Remove Linked List Elements",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Remove all elements from a linked list of integers that have value <b><i>val</i></b>.</p>\n    <p>\n        <b>Example</b><br>\n        <i><b>Given:</b></i> 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6,  <b><i>val</i></b> = 6<br>\n        <i><b>Return:</b></i> 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5\n    </p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if(head == null) return null;\n\n        ListNode fakeHead = new ListNode(-1);\n        ListNode pre = fakeHead;\n        fakeHead.next = head;\n        while(head != null && head.val == val){\n            head = head.next;\n            fakeHead.next = head;\n        }\n\n        while(head != null){\n            if(head.val != val){\n                pre = head;\n                head = head.next;\n            }\n            else {\n                head = head.next;\n                pre.next = head;\n            }\n        }\n        return fakeHead.next;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 49,
        "number": 204,
        "title": "Count Primes",
        "difficulty": "Easy",
        "description": "Count the number of prime numbers less than a non-negative number, n.",
        "solution": "public class Solution {\n    public int countPrimes(int n) {\n        int res = 0;\n        if (n <= 2)  return res; // A prime number must be >= 2.\n        boolean[] flags = new boolean[n+1];\n\n        int rootN = (int)Math.sqrt(n);\n        for (int i=2; i<=rootN; ++i) {  // [1]\n            // flags[i]==true means it has been marked before and\n            // thus all its multiples can be skipped\n            if (!flags[i]) {\n                // Note: if we get here, i itself is a prime number\n\n                // mark its multiples\n                for (int j=i*i; j<=n; j+=i) {  // [2]\n                    flags[j] = true;\n                }\n            }\n        }\n\n        for (int i=2; i<n; ++i) {\n            if (!flags[i]) res++;\n        }\n        return res;\n    }\n}",
        "tags": "1, 3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 50,
        "number": 205,
        "title": "Isomorphic Strings",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given two strings <b><i>s</i></b> and <b><i>t</i></b>, determine if they are isomorphic.</p>\n\n    <p>Two strings are isomorphic if the characters in <b><i>s</i></b> can be replaced to get <b><i>t</i></b>.</p>\n\n    <p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>\n\n    <p>For example,<br>\n        Given <code>\"egg\"</code>, <code>\"add\"</code>, return true.</p>\n\n    <p>Given <code>\"foo\"</code>, <code>\"bar\"</code>, return false.</p>\n\n    <p>Given <code>\"paper\"</code>, <code>\"title\"</code>, return true.</p>\n\n    <p><b>Note:</b><br>\n        You may assume both <b><i>s</i></b> and <b><i>t</i></b> have the same length.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if(s == null || s.length() <= 1)\n            return true;\n        Map<Character, Character> map = new HashMap<Character, Character>();\n        for(int i = 0 ; i< s.length(); i++){\n            char a = s.charAt(i);\n            char b = t.charAt(i);\n            if(map.containsKey(a) && !map.get(a).equals(b) ||\n                    !map.containsKey(a) && map.containsValue(b))\n                return false;\n            map.put(a,b);\n        }\n        return true;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 51,
        "number": 206,
        "title": "Reverse Linked List",
        "difficulty": "Easy",
        "description": "Reverse a singly linked list.\n<br>\nHint:\nA linked list can be reversed either iteratively or recursively. Could you implement both?",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Iterative Solution\n    public ListNode reverseList(ListNode head) {\n        if(head == null || head.next == null) return head;\n\n        ListNode fakeHead = new ListNode(-1);\n        fakeHead.next = head;\n        ListNode curNode = head.next;\n\n        while(curNode != null){\n            head.next = curNode.next;\n            curNode.next = fakeHead.next;\n            fakeHead.next = curNode;\n            curNode = head.next;\n        }\n        return fakeHead.next;\n    }\n    // Recursive Solution\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode p = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return p;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 52,
        "number": 219,
        "title": "Contains Duplicate II",
        "difficulty": "Easy",
        "description": "Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.",
        "solution": "public class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for(int i=0; i<nums.length; i++){\n            List<Integer> indexes = map.containsKey(nums[i]) ?\n                map.get(nums[i]) : new ArrayList<Integer>();\n            for(int ind=0; ind < indexes.size(); ind++){\n                if(Math.abs(i - indexes.get(ind)) <= k) return true;\n            }\n            indexes.add(i);\n            map.put(nums[i], indexes);\n        }\n        return false;\n    }\n}",
        "tags": "0, 1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 53,
        "number": 225,
        "title": "Implement Stack using Queues",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Implement the following operations of a stack using queues.\n</p><ul>\n    <li>\n        push(x) -- Push element x onto stack.\n    </li>\n    <li>\n        pop() -- Removes the element on top of the stack.\n    </li>\n    <li>\n        top() -- Get the top element.\n    </li>\n    <li>\n        empty() -- Return whether the stack is empty.\n    </li>\n</ul>\n    <b>Notes:</b><br>\n    <ul>\n        <li>You must use <i>only</i> standard operations of a queue -- which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n        <li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>\n        <li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>\n    </ul>\n\n</div>",
        "solution": "class MyStack {\n\n\tDeque<Integer> queue1 = null, queue2 = null;\n\n\tpublic MyStack(){\n\t\tthis.queue1 = new ArrayDeque<Integer>();\n\t\tthis.queue2 = new ArrayDeque<Integer>();\n\t}\n\n\t// Push element x onto stack.\n    public void push(int x) {\n    \tthis.queue1.offer(x);\n        this.queue2.offer(x);\n    }\n\n    // Removes the element on top of the stack.\n    public int pop() {\n        int topElem = -1;\n    \tthis.queue2.clear();\n    \twhile(!this.queue1.isEmpty()){\n    \t\ttopElem = this.queue1.poll();\n    \t\tif(!this.queue1.isEmpty())\n    \t\t\tthis.queue2.offer(topElem);\n        }\n    \tthis.queue1 = new ArrayDeque<Integer>(this.queue2);\n    \treturn topElem;\n    }\n\n    // Get the top element.\n    public int top() {\n    \twhile(!this.queue1.isEmpty()){\n        \tint res = this.queue1.poll();\n        \tif(this.queue1.isEmpty()){\n            \tthis.queue1 = new ArrayDeque<Integer>(this.queue2);\n            \treturn res;\n        \t}\n        }\n    \treturn -1;\n    }\n\n    // Return whether the stack is empty.\n    public boolean empty() {\n        return this.queue2.isEmpty();\n    }\n}",
        "tags": "10, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 54,
        "number": 226,
        "title": "Invert Binary Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p>Invert a binary tree.\n    </p><pre>     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9</pre>\n\n    to\n    <pre>     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1</pre>\n\n    <b>Trivia:</b><br>\n    This problem was inspired by <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\">this original tweet</a> by <a href=\"https://twitter.com/mxcl\" target=\"_blank\">Max Howell</a>:\n    <blockquote>Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off.</blockquote><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode invertTree(TreeNode root) {\n\t\tif (root == null) return root;\n\t\tswapNodes(root, null);\n\t\treturn root;\n\t}\n\n\tprivate void swapNodes(TreeNode firstNode, TreeNode secondNode) {\n\t\tif (firstNode == null && secondNode == null) return;\n\n\t\tif (firstNode != null){\n\t\t\tTreeNode temp = firstNode.left;\n\t\t\tfirstNode.left = firstNode.right;\n\t\t\tfirstNode.right = temp;\n\t\t\tswapNodes(firstNode.left, firstNode.right);\n\t\t}\n\n\t\tif (secondNode != null){\n\t\t\tTreeNode temp = secondNode.left;\n\t\t\tsecondNode.left = secondNode.right;\n\t\t\tsecondNode.right = temp;\n\t\t\tswapNodes(secondNode.left, secondNode.right);\n\t\t}\n\t\treturn;\n\t}\n}",
        "tags": "12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 55,
        "number": 231,
        "title": "Power of Two",
        "difficulty": "Easy",
        "description": "Given an integer, write a function to determine if it is a power of two.",
        "solution": "public class Solution {\n    public boolean isPowerOfTwo(int n) {\n        if(n <= 0) return false;\n        boolean gotOne = false;\n        for(int i=0; i<32; i++){\n            int bit = n & (1 << i);\n            if(bit != 0 && gotOne) return false;\n            if(bit != 0)\n                gotOne = true;\n        }\n        return true;\n    }\n}",
        "tags": "3, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 56,
        "number": 232,
        "title": "Implement Queue using Stacks",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Implement the following operations of a queue using stacks.\n</p><ul>\n    <li>\n        push(x) -- Push element x to the back of queue.\n    </li>\n    <li>\n        pop() -- Removes the element from in front of queue.\n    </li>\n    <li>\n        peek() -- Get the front element.\n    </li>\n    <li>\n        empty() -- Return whether the queue is empty.\n    </li>\n</ul>\n    <b>Notes:</b><br>\n    <ul>\n        <li>You must use <i>only</i> standard operations of a stack -- which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n        <li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>\n        <li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>\n    </ul>\n    <p></p><p></p>\n</div>",
        "solution": "class MyQueue {\n    Stack<Integer> mainStack = new Stack<Integer>();\n    Stack<Integer> assistStack = new Stack<Integer>();\n\n    // Push element x to the back of queue.\n    public void push(int x) {\n        assistStack.push(x);\n    }\n\n    // Removes the element from in front of queue.\n    public int pop() {\n        if(mainStack.isEmpty()){\n            while(!assistStack.isEmpty()){\n                mainStack.push(assistStack.pop());\n            }\n        }\n        return mainStack.pop();\n    }\n\n    // Get the front element.\n    public int peek() {\n        if(mainStack.isEmpty()){\n            while(!assistStack.isEmpty()){\n                mainStack.push(assistStack.pop());\n            }\n        }\n        return mainStack.peek();\n    }\n\n    // Return whether the queue is empty.\n    public boolean empty() {\n        return mainStack.isEmpty() && assistStack.isEmpty();\n    }\n}",
        "tags": "10, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 57,
        "number": 234,
        "title": "Palindrome Linked List",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a singly linked list, determine if it is a palindrome.</p>\n\n    <p><b>Follow up:</b><br>\n        Could you do it in O(n) time and O(1) space?</p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head == null || head.next==null)\n            return true;\n\n        //find list center\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast.next!=null && fast.next.next!=null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        ListNode secondHead = slow.next;\n        slow.next = null;\n        //reverse second part of the list\n        ListNode p1 = secondHead;\n        ListNode p2 = p1.next;\n        while(p1!=null && p2!=null){\n            ListNode temp = p2.next;\n            p2.next = p1;\n            p1 = p2;\n            p2 = temp;\n        }\n\n        secondHead.next = null;\n        //compare two sublists now\n        ListNode p = (p2==null?p1:p2);\n        ListNode q = head;\n        while(p!=null){\n            if(p.val != q.val)\n                return false;\n            p = p.next;\n            q = q.next;\n        }\n        return true;\n    }\n}",
        "tags": "2, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 58,
        "number": 235,
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\n</p>\n\n\n\n    <pre>        _______6______\n       /              \\\n    ___2__          ___8__\n   /      \\        /      \\\n   0      _4       7       9\n         /  \\\n         3   5\n</pre>\n\n    <p>\n        For example, the lowest common ancestor (LCA) of nodes <code>2</code> and <code>8</code> is <code>6</code>. Another example is LCA of nodes <code>2</code> and <code>4</code> is <code>2</code>, since a node can be a descendant of itself according to the LCA definition.</p><p></p>\n\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        int rootVal = root.val;\n        if(p.val == rootVal || q.val == rootVal || p.val < rootVal && q.val > rootVal\n                || p.val > rootVal && q.val < rootVal){\n            return root;\n        }\n        if(p.val < root.val && q.val < root.val){\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        return lowestCommonAncestor(root.right, p, q);\n    }\n}",
        "tags": "12",
        "companies": "",
        "specialtags": "2"
    },
    {
        "id": 59,
        "number": 237,
        "title": "Delete Node in a Linked List",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\n</p>\n\n    <p>\n        Supposed the linked list is <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> and you are given the third node with value <code>3</code>, the linked list should become <code>1 -&gt; 2 -&gt; 4</code> after calling your function.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void deleteNode(ListNode node) {\n        if(node == null) return;\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 60,
        "number": 242,
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>Given two strings <i>s</i> and <i>t</i>, write a function to determine if <i>t</i> is an anagram of <i>s</i>.</p>\n\n    <p>For example,<br>\n        <i>s</i> = \"anagram\", <i>t</i> = \"nagaram\", return true.<br>\n        <i>s</i> = \"rat\", <i>t</i> = \"car\", return false.\n    </p>\n\n    <p><b>Note:</b><br> You may assume the string contains only lowercase alphabets.</p>\n\n    <p><b>Follow up:</b><br> What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length() != t.length()) return false;\n        if(s.length() == 0) return true;\n        \n        int[] sAlphCounts = new int[26];\n        int[] tAlphCounts = new int[26];\n        for(int i=0; i<s.length(); i++){\n            sAlphCounts[s.charAt(i)-'a']++;\n            tAlphCounts[t.charAt(i)-'a']++;\n        }\n        \n        for(int i=0; i<26; i++){\n            if(sAlphCounts[i] != tAlphCounts[i]) return false;\n        }\n        return true;\n    }\n}",
        "tags": "1, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 61,
        "number": 246,
        "title": "Strobogrammatic Number",
        "difficulty": "Easy",
        "description": "<blockquote>\n    <p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>\n    <p>Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p>\n    <p>For example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic.</p>\n</blockquote>",
        "solution": "public class Solution {\n    public boolean isStrobogrammatic(String num) {\n        HashMap<Character, Character> map = new HashMap<Character, Character>();\n        map.put('1','1');\n        map.put('0','0');\n        map.put('6','9');\n        map.put('9','6');\n        map.put('8','8');\n        int left = 0, right = num.length() - 1;\n        while(left <= right){\n            // 如果字母不存在映射或映射不对，则返回假\n            if(!map.containsKey(num.charAt(right)) || num.charAt(left) != map.get(num.charAt(right))){\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n",
        "tags": "1",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 62,
        "number": 252,
        "title": "Meeting Rooms",
        "difficulty": "Easy",
        "description": "<p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei),\n    determine if a person could attend all meetings. For example, Given [[0, 30],[5, 10],[15, 20]], return false.</p>",
        "solution": "class Solution {\n    public boolean canAttendMeetings(Interval[] intervals) {\n        Arrays.sort(intervals, new Comparator<Interval>() {\n            public int compare(Interval a, Interval b) {\n                return a.start - b.start;\n            }\n        });\n\n        for (int i = 0; i < intervals.length - 1; i++) {\n            if (intervals[i].end > intervals[i + 1].start) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}\n",
        "tags": "13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 63,
        "number": 257,
        "title": "Binary Tree Paths",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven a binary tree, return all root-to-leaf paths.\n</p>\n<p>\nFor example, given the following binary tree:\n</p>\n<p>\n</p><pre>   1\n /   \\\n2     3\n \\\n  5\n</pre>\n<p></p>\n<p>\nAll root-to-leaf paths are:\n</p><pre>[\"1-&gt;2-&gt;5\", \"1-&gt;3\"]</pre>\n<p></p>\n</div>\n",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> answer = new ArrayList<String>();\n        if (root != null)\n            searchBT(root, \"\", answer);\n        return answer;\n    }\n    \n    private void searchBT(TreeNode root, String path, List<String> answer) {\n        if (root.left == null && root.right == null) \n            answer.add(path + root.val);\n        if (root.left != null)\n            searchBT(root.left, path + root.val + \"->\", answer);\n        if (root.right != null)\n            searchBT(root.right, path + root.val + \"->\", answer);\n    }\n}",
        "tags": "12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 64,
        "number": 258,
        "title": "Add Digits",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit.\n</p>\n\n    <p>\n        For example:\n    </p>\n    <p>\n        Given <code>num = 38</code>, the process is like: <code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>. Since <code>2</code> has only one digit, return it.\n    </p>\n\n    <p><b>Follow up:</b><br>\n        Could you do it without any loop/recursion in O(1) runtime?\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    // Observe the pattern of num % 9\n    public int addDigits(int num) {\n        if(num == 0) return num;\n        return num % 9 == 0 ? 9 : num % 9;\n    }\n\n    /***\n     * Traditional solution\n     *\n     * res = 0\n     * digitCount = digit count of num\n     * mostSig = 10^(digitCount - 1)\n     *\n     * while(num > 9){\n     *  digitCount = digit count of num\n     *  mostSig = 10^(digitCount - 1)\n     *  int temp = 0\n     *  while(mostSig > 0){\n     *      temp += num / mostSig\n     *      num %= mostSig\n     *      mostSig /= 10\n     *  }\n     *  num = temp\n     * }\n     *\n     */\n    public int addDigits(int num) {\n        if(num == 0) return num;\n        while(num > 9){\n            int digitCount = String.valueOf(num).length();\n            int mostSig = (int)Math.pow(10, digitCount-1);\n            int temp = 0;\n            while(mostSig > 0){\n                temp += num / mostSig;\n                num %= mostSig;\n                mostSig /= 10;\n            }\n            num = temp;\n        }\n        return num;\n    }\n}\n\n",
        "tags": "3",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 65,
        "number": 263,
        "title": "Ugly Number",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>\n        Write a program to check whether a given number is an ugly number.\n    </p>\n\n    <p>\n        Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code>        are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.\n    </p>\n\n    <p>\n        Note that <code>1</code> is typically treated as an ugly number.\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    public boolean isUgly(int num) {\n        if(num <= 0) \n            return false;\n        if(num < 7)\n            return true;\n        while(num % 5 == 0) num /= 5;\n        while(num % 3 == 0) num /= 3;\n        while(num % 2 == 0) num /= 2;\n        return num == 1;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 66,
        "number": 268,
        "title": "Missing Number",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>\n        Given an array containing <i>n</i> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is\n        missing from the array.\n    </p>\n\n    <p>For example,<br> Given <i>nums</i> = <code>[0, 1, 3]</code> return <code>2</code>.\n    </p>\n\n    <p>\n        <b>Note</b>:<br> Your algorithm should run in linear runtime complexity. Could you implement it using only constant\n        extra space complexity?\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    public int missingNumber(int[] nums) {\n        if (nums.length == 0) return 0;\n        int min = nums[0], max = nums[0];\n        for(int num : nums){\n            min = min < num ? min : num;\n            max = max > num ? max : num;\n        }\n        if (min > 0) return 0;\n        if (max == (nums.length - 1)) return nums.length;\n        int total = max*(max+1)/2;\n        for(int num : nums){\n            total -= num;\n        }\n        return total;\n    }\n}",
        "tags": "0, 3, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 67,
        "number": 278,
        "title": "First Bad Version",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>\n        You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your\n        product fails the quality check. Since each version is developed based on the previous version, all the versions\n        after a bad version are also bad.\n    </p>\n\n    <p>\n        Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one,\n        which causes all the following ones to be bad.\n    </p>\n\n    <p>\n        You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad.\n        Implement a function to find the first bad version. You should minimize the number of calls to the API.\n    </p>\n\n</div>",
        "solution": "/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        if(n == 1) return 1;\n        int startIndex = 1, endIndex = n;\n        while(startIndex < endIndex){\n            int midIndex = startIndex + (endIndex - startIndex)/2;\n            if(isBadVersion(midIndex)){\n                endIndex = midIndex;\n            }\n            else{\n                startIndex = midIndex+1;\n            }\n        }\n        return endIndex;\n    }\n}",
        "tags": "6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 68,
        "number": 283,
        "title": "Move Zeroes",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given an array <code>nums</code>, write a function to move all <code>0</code>'s to the end of it while maintaining the relative order of the non-zero elements.\n</p>\n\n    <p>\n        For example, given <code>nums  = [0, 1, 0, 3, 12]</code>, after calling your function, <code>nums</code> should be <code>[1, 3, 12, 0, 0]</code>.\n    </p>\n\n    <p>\n        <b>Note</b>:<br>\n    </p><ol>\n    <li>You must do this <b>in-place</b> without making a copy of the array.</li>\n    <li>Minimize the total number of operations.</li>\n</ol>\n    <p></p>\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Put nonzero numbers ahead\n     * Set rest to be zeros\n     */\n    public void moveZeroes(int[] nums) {\n        int curInd = 0;\n        int scanInd = 0;\n        while(scanInd < nums.length){\n            if(nums[scanInd] == 0){\n                scanInd++;\n            } else {\n                nums[curInd++] = nums[scanInd++];\n            }\n        }\n\n        while(curInd < nums.length){\n            nums[curInd++] = 0;\n        }\n    }\n}",
        "tags": "0, 4",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 69,
        "number": 290,
        "title": "Word Pattern",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>\n<p> Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>str</code>.</p>\n<p>\n<b>Examples:</b><br>\n</p><ol>\n<li>pattern = <code>\"abba\"</code>, str = <code>\"dog cat cat dog\"</code> should return true.</li>\n<li>pattern = <code>\"abba\"</code>, str = <code>\"dog cat cat fish\"</code> should return false.</li>\n<li>pattern = <code>\"aaaa\"</code>, str = <code>\"dog cat cat dog\"</code> should return false.</li>\n<li>pattern = <code>\"abba\"</code>, str = <code>\"dog dog dog dog\"</code> should return false.</li>\n</ol>\n<p></p>\n\n<p>\n<b>Notes:</b><br>\nYou may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters separated by a single space.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] strs = str.split(\" \");\n        if(pattern.length() != strs.length) return false;\n        Map<Character, String> pMaptos = new HashMap<>();\n        Map<String, Character> sMaptop = new HashMap<>();\n        for(int i = 0; i < pattern.length(); i++){\n            if(pMaptos.containsKey(pattern.charAt(i))){\n                if(!pMaptos.get(pattern.charAt(i)).equals(strs[i])) \n                    return false;\n            } else {\n                pMaptos.put(pattern.charAt(i), strs[i]);   \n            }\n            \n            if(sMaptop.containsKey(strs[i])){\n                if(!sMaptop.get(strs[i]).equals(pattern.charAt(i)))\n                    return false;\n            } else {\n                sMaptop.put(strs[i], pattern.charAt(i));   \n            }\n        }\n        return true;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 70,
        "number": 292,
        "title": "Nim Game",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n</p>\n\n<p>\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n</p>\n\n<p>\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public boolean canWinNim(int n) {\n        if (n <= 3) return true;\n        return n % 4 != 0;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 71,
        "number": 303,
        "title": "Range Sum Query - Immutable",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given an integer array <i>nums</i>, find the sum of the elements between indices <i>i</i> and <i>j</i> (<i>i</i> <= <i>j</i>), inclusive.</p>\n\n<p><b>Example:</b><br>\n</p><pre>Given nums = [-2, 0, 3, -5, 2, -1]\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume that the array does not change.</li>\n<li>There are many calls to <i>sumRange</i> function.</li>\n</ol>\n<p></p><p></p>\n      </div>",
        "solution": "public class NumArray {\n    int[] sums;\n    int arrayLen;\n\n    public NumArray(int[] nums) {\n        this.arrayLen = nums.length;\n        this.sums = new int[this.arrayLen];\n        \n        if(this.arrayLen > 0){\n            this.sums[0] = nums[0];\n            if(this.arrayLen > 1){\n                for(int i = 1; i< nums.length; i++){\n                    this.sums[i] = sums[i-1]+nums[i];\n                }\n            }\n        }\n    }\n\n    public int sumRange(int i, int j) {\n        if(i < 0 || j > arrayLen-1) return 0;\n        return this.sums[j]-(i <= 0 ? 0 : this.sums[i-1]);\n    }\n}\n\n\n// Your NumArray object will be instantiated and called as such:\n// NumArray numArray = new NumArray(nums);\n// numArray.sumRange(0, 1);\n// numArray.sumRange(1, 2);",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 72,
        "number": 326,
        "title": "Power of Three",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given an integer, write a function to determine if it is a power of three.\n</p>\n<p>\n    <b>Follow up:</b><br>\n    Could you do it without using any loop / recursion?\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    /**\n     * n = 3^(log(n)/log(3))\n    **/\n    public boolean isPowerOfThree(int n) {\n        if(n == 0) return false;\n        return n == Math.pow(3, Math.round(Math.log(n) / Math.log(3)));\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 73,
        "number": 342,
        "title": "Power of Four",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven an integer (signed 32 bits), write a function to check whether it is a power of 4.\n</p>\n<p><b>Example:</b><br>\nGiven num = 16, return true.\nGiven num = 5, return false.\n</p>\n<p>\n<b>Follow up</b>: Could you solve it without loops/recursion?\n</p>\n      </div>",
        "solution": "public class Solution {\n    public boolean isPowerOfFour(int num) {\n        // first check only one bit is set:\n        if ((num & (num -1)) != 0) return false;\n        // next check if it's a bit in pos 1, 3, 5 ... 31\n        if ((num & 0x55555555) != 0) return true;\n        return false;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 74,
        "number": 344,
        "title": "Reverse String",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write a function that takes a string as input and returns the string reversed.</p>\n\n    <p>\n        <b>Example:</b><br>\n        Given s = \"hello\", return \"olleh\".\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String reverseString(String s) {\n        char[] stringChars = s.toCharArray();\n        int start = 0;\n        int end = stringChars.length - 1;\n        while(start < end){\n            char temp = stringChars[start];\n            stringChars[start] = stringChars[end];\n            stringChars[end] = temp;\n            start++;\n            end--;\n        }\n        return String.valueOf(stringChars);\n    }\n}",
        "tags": "4, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 75,
        "number": 345,
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>\n\n<p>\n<b>Example 1:</b><br>\nGiven s = \"hello\", return \"holle\".\n</p>\n\n<p>\n<b>Example 2:</b><br>\nGiven s = \"leetcode\", return \"leotcede\".\n</p>\n\n<p>\n<b>Note:</b><br>\nThe vowels does not include the letter \"y\".\n</p><p></p>\n      </div>",
        "solution": "public class Solution {\n    public String reverseVowels(String s) {\n        if(s.length() <= 1) return s;\n        char[] chars = s.toCharArray();\n        int start = 0, end = chars.length - 1;\n        while(start < end){\n            while(start < end && !isVowel(chars[start])) start++;\n            while(start < end && !isVowel(chars[end])) end--;\n            if(start == end) return new String(chars);\n            char temp  = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;\n            end--;\n        }\n        return new String(chars);\n    }\n    \n    boolean isVowel(char c){\n        char[] vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        for(char vowel : vowels){\n            if(vowel == c) return true;\n        }\n        return false;\n    }\n}",
        "tags": "4, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 76,
        "number": 345,
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>\n\n<p>\n<b>Example 1:</b><br>\nGiven s = \"hello\", return \"holle\".\n</p>\n\n<p>\n<b>Example 2:</b><br>\nGiven s = \"leetcode\", return \"leotcede\".\n</p>\n\n<p>\n<b>Note:</b><br>\nThe vowels does not include the letter \"y\".\n</p><p></p>\n      </div>",
        "solution": "public class Solution {\n    public String reverseVowels(String s) {\n        if(s.length() <= 1) return s;\n        char[] chars = s.toCharArray();\n        int start = 0, end = chars.length - 1;\n        while(start < end){\n            while(start < end && !isVowel(chars[start])) start++;\n            while(start < end && !isVowel(chars[end])) end--;\n            if(start == end) return new String(chars);\n            char temp  = chars[start];\n            chars[start] = chars[end];\n            chars[end] = temp;\n            start++;\n            end--;\n        }\n        return new String(chars);\n    }\n    \n    boolean isVowel(char c){\n        char[] vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        for(char vowel : vowels){\n            if(vowel == c) return true;\n        }\n        return false;\n    }\n}",
        "tags": "4, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 77,
        "number": 349,
        "title": "Intersection of Two Arrays",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven two arrays, write a function to compute their intersection.\n</p>\n\n<p><b>Example:</b><br>\nGiven <i>nums1</i> = <code>[1, 2, 2, 1]</code>, <i>nums2</i> = <code>[2, 2]</code>, return <code>[2]</code>.\n</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>Each element in the result must be unique.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p></p><p></p>\n      </div>",
        "solution": "public class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Set<Integer> intersect = new HashSet<>();\n        for (int i = 0; i < nums1.length; i++) {\n            set.add(nums1[i]);\n        }\n        for (int i = 0; i < nums2.length; i++) {\n            if (set.contains(nums2[i])) {\n                intersect.add(nums2[i]);\n            }\n        }\n        int[] result = new int[intersect.size()];\n        int i = 0;\n        for (Integer num : intersect) {\n            result[i++] = num;\n        }\n        return result;\n    }\n}",
        "tags": "1, 4, 6, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 78,
        "number": 350,
        "title": "Intersection of Two Arrays II",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven two arrays, write a function to compute their intersection.\n</p>\n\n<p><b>Example:</b><br>\nGiven <i>nums1</i> = <code>[1, 2, 2, 1]</code>, <i>nums2</i> = <code>[2, 2]</code>, return <code>[2, 2]</code>.\n</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p></p>\n\n<p><b>Follow up:</b><br>\n</p><ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if <i>nums1</i>'s size is small compared to <i>nums2</i>'s size? Which algorithm is better?</li>\n<li>What if elements of <i>nums2</i> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n<p></p><p></p>\n      </div>",
        "solution": "public class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int i: nums1){\n            if(map.containsKey(i)){\n                map.put(i, map.get(i)+1);\n            }else{\n                map.put(i, 1);\n            }\n        }\n \n        ArrayList<Integer> list = new ArrayList<Integer>();\n        for(int i: nums2){\n            if(map.containsKey(i)){\n                if(map.get(i) > 1){\n                    map.put(i, map.get(i)-1);\n                }else{\n                    map.remove(i);\n                }\n                list.add(i);\n            }\n        }\n \n        int[] result = new int[list.size()];\n        int i =0;\n        while(i<list.size()){\n            result[i]=list.get(i);\n            i++;\n        }\n        return result;\n    }\n}",
        "tags": "1, 4, 6, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 79,
        "number": 367,
        "title": "Valid Perfect Square",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a positive integer <i>num</i>, write a function which returns True if <i>num</i> is a perfect square else False.</p>\n\n<p>\n<b>Note:</b> <b>Do not</b> use any built-in library function such as <code>sqrt</code>.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre>Input: 16\nReturns: True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input: 14\nReturns: False\n</pre>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    public boolean isPerfectSquare(int num) {\n        long L = 1, R = (num >> 1) + 1;\n\t\twhile (L <= R) {\n\t\t\tlong  m = L + ((R - L) >> 1);\n\t\t\tlong  mul = m * m;\n\t\t\tif (mul == num) return true;\n\t\t\telse if (mul > num) R = m - 1;\n\t\t\telse L = m + 1;\n\t\t}\n\t\treturn false;\n    }\n}",
        "tags": "3, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 80,
        "number": 371,
        "title": "Sum of Two Integerst",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>Calculate the sum of two integers <i>a</i> and <i>b</i>, but you are <b>not allowed</b> to use the operator <code>+</code> and <code>-</code>.</p>\n\n<p><b>Example:</b><br>\nGiven <i>a</i> = 1 and <i>b</i> = 2, return 3.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public int getSum(int a, int b) {\n        if(b == 0) return a;\n        return getSum(a^b, ((a & b) << 1));\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 81,
        "number": 374,
        "title": "Guess Number Higher or Lower",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n        <p></p><p>We are playing the Guess Game. The game is as follows:</p><p> \n\n</p><p>I pick a number from <b>1</b> to <b><i>n</i></b>. You have to guess which number I picked.</p>\n\n<p>Every time you guess wrong, I'll tell you whether the number is higher or lower.</p>\n\n<p>You call a pre-defined API <code>guess(int num)</code> which returns 3 possible results (<code>-1</code>, <code>1</code>, or <code>0</code>):</p>\n<pre>-1 : My number is lower\n 1 : My number is higher\n 0 : Congrats! You got it!\n</pre>\n\n<p><b>Example:</b><br>\n</p><pre>n = 10, I pick 6.\n\nReturn 6.\n</pre>\n<p></p><p></p>\n      </div>",
        "solution": "/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int res = guess(mid);\n            if (res == 0)\n                return mid;\n            else if (res < 0)\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return -1;\n    }\n}",
        "tags": "6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 82,
        "number": 383,
        "title": "Ransom Note",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom\n    note can be constructed from the magazines ; otherwise, it will return false.\n</p>\n    <p>\n        Each letter in the magazine string can only be used once in your ransom note.\n    </p>\n\n    <p><b>Note:</b><br>\n        You may assume that both strings contain only lowercase letters.\n    </p>\n\n    <pre>canConstruct(\"a\", \"b\") -&gt; false\ncanConstruct(\"aa\", \"ab\") -&gt; false\ncanConstruct(\"aa\", \"aab\") -&gt; true\n</pre>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] arr = new int[26];\n        for (int i = 0; i < magazine.length(); i++) {\n            arr[magazine.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < ransomNote.length(); i++) {\n            if(--arr[ransomNote.charAt(i)-'a'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 83,
        "number": 387,
        "title": "First Unique Character in a String",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n</p>\n    <p><b>Examples:</b>\n    </p><pre>s = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\n</pre>\n    <p></p>\n\n    <p>\n        <b>Note:</b> You may assume the string contain only lowercase letters.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int firstUniqChar(String s) {\n        if (s == null || s.length() == 0) return -1;\n        int len = s.length();\n        if (len == 1) return 0;\n        char[] cc = s.toCharArray();\n        int slow = 0, fast = 1;\n        int[] count = new int[256];\n        count[cc[slow]]++;\n        while (fast < len) {\n            count[cc[fast]]++;\n            // if slow pointer is not a unique character anymore,\n            // move to the next unique one\n            while (slow < len && count[cc[slow]] > 1) slow++;\n            // no unique character exist\n            if (slow >= len) return -1;\n            // not yet visited by the fast pointer\n            if (count[cc[slow]] == 0) {\n                count[cc[slow]]++;\n                fast = slow; // reset the fast pointer\n            }\n            fast++;\n        }\n        return slow;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 84,
        "number": 389,
        "title": "Find the Difference",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two strings <b><i>s</i></b> and <b><i>t</i></b> which consist of only lowercase letters.</p>\n\n    <p>String <b><i>t</i></b> is generated by random shuffling string <b><i>s</i></b> and then add one more letter at a random position.</p>\n\n    <p>Find the letter that was added in <b><i>t</i></b>.</p>\n\n    <p><b>Example:</b>\n    </p><pre>Input:\ns = \"abcd\"\nt = \"abcde\"\n\nOutput:\ne\n\nExplanation:\n'e' is the letter that was added.\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public char findTheDifference(String s, String t) {\n        int n = t.length();\n        char c = t.charAt(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            c ^= s.charAt(i);\n            c ^= t.charAt(i);\n        }\n        return c;\n    }\n}",
        "tags": "1, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 85,
        "number": 400,
        "title": "Nth Digit",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Find the <i>n</i><sup>th</sup> digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... </p>\n\n    <p><b>Note:</b><br>\n        <i>n</i> is positive and will fit within the range of a 32-bit signed integer (<i>n</i> &lt; 2<sup>31</sup>).\n    </p>\n\n    <p><b>Example 1:</b>\n    </p><pre><b>Input:</b>\n3\n\n<b>Output:</b>\n3\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre><b>Input:</b>\n11\n\n<b>Output:</b>\n0\n\n<b>Explanation:</b>\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     1. find the length of the number where the nth digit is from\n     2. find the actual number where the nth digit is from\n     3. find the nth digit and return\n     **/\n    public int findNthDigit(int n) {\n        int len = 1;\n        long count = 9;\n        int start = 1;\n\n        while (n > len * count) {\n            n -= len * count;\n            len += 1;\n            count *= 10;\n            start *= 10;\n        }\n\n        start += (n - 1) / len;\n        String s = Integer.toString(start);\n        return Character.getNumericValue(s.charAt((n - 1) % len));\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 86,
        "number": 401,
        "title": "Binary Watch",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>A binary watch has 4 LEDs on the top which represent the <b>hours</b> (<b>0-11</b>), and the 6 LEDs on the bottom represent the <b>minutes</b> (<b>0-59</b>).</p>\n    <p>Each LED represents a zero or one, with the least significant bit on the right.</p>\n    <img src=\"https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg\" height=\"300\">\n    <p>For example, the above binary watch reads \"3:25\".</p>\n\n    <p>Given a non-negative integer <i>n</i> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>\n\n    <p><b>Example:</b>\n    </p><pre>Input: n = 1<br>Return: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ul>\n    <li>The order of output does not matter.</li>\n    <li>The hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\".</li>\n    <li>The minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".</li>\n</ul>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<String> readBinaryWatch(int num) {\n        List<String> result = new ArrayList<>();\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 60; j++) {\n                if (Integer.bitCount(i) + Integer.bitCount(j) == num) {\n                    result.add(String.format(\"%d:%02d\", i, j));\n                }\n            }\n        }\n        return result;\n    }\n}",
        "tags": "8, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 87,
        "number": 404,
        "title": "Sum of Left Leaves",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Find the sum of all left leaves in a given binary tree.</p>\n\n    <p><b>Example:</b>\n    </p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nThere are two left leaves in the binary tree, with values <b>9</b> and <b>15</b> respectively. Return <b>24</b>.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        if(root == null) return 0;\n        int ans = 0;\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.push(root);\n\n        while(!stack.empty()) {\n            TreeNode node = stack.pop();\n            if(node.left != null) {\n                if (node.left.left == null && node.left.right == null)\n                    ans += node.left.val;\n                else\n                    stack.push(node.left);\n            }\n            if(node.right != null) {\n                if (node.right.left != null || node.right.right != null)\n                    stack.push(node.right);\n            }\n        }\n        return ans;\n    }\n}",
        "tags": "12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 88,
        "number": 405,
        "title": "Convert a Number to Hexadecimal",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">two's complement</a> method is used.\n</p>\n\n    <p><b>Note:</b>\n    </p><ol>\n    <li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>\n    <li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>'0'</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>\n    <li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>\n    <li>You <b>must not use <i>any</i> method provided by the library</b> which converts/formats the number to hex directly.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b>\n    </p><pre>Input:\n26\n\nOutput:\n\"1a\"\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre>Input:\n-1\n\nOutput:\n\"ffffffff\"\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /*\n    Basic idea: each time we take a look at the last four digits of\n            binary verion of the input, and maps that to a hex char\n            shift the input to the right by 4 bits, do it again\n            until input becomes 0.\n    */\n    public String toHex(int num) {\n        char[] map = {'0','1','2','3','4','5','6','7','8','9',\n                'a','b','c','d','e','f'};\n        if(num == 0) return \"0\";\n        String result = \"\";\n        while(num != 0){\n            result = map[(num & 15)] + result;\n            num = (num >>> 4);\n        }\n        return result;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 89,
        "number": 409,
        "title": "Longest Palindrome",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>\n\n    <p>This is case sensitive, for example <code>\"Aa\"</code> is not considered a palindrome here.</p>\n\n    <p><b>Note:</b><br>\n        Assume the length of given string will not exceed 1,010.\n    </p>\n\n    <p><b>Example: </b>\n    </p><pre>Input:\n\"abccccdd\"\n\nOutput:\n7\n\nExplanation:\nOne longest palindrome that can be built is \"dccaccd\", whose length is 7.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int longestPalindrome(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        Set<Character> hs = new HashSet<>();\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (hs.contains(s.charAt(i))) {\n                hs.remove(s.charAt(i));\n                count++;\n            } else {\n                hs.add(s.charAt(i));\n            }\n        }\n        if (!hs.isEmpty())\n            return count * 2 + 1;\n        return count * 2;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 90,
        "number": 412,
        "title": "Fizz Buzz",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write a program that outputs the string representation of numbers from 1 to <i>n</i>.</p>\n\n    <p>But for multiples of three it should output \"Fizz\" instead of the number and for the multiples of five output \"Buzz\". For numbers which are multiples of both three and five output \"FizzBuzz\".</p>\n\n    <p><b>Example:</b>\n    </p><pre>n = 15,\n\nReturn:\n[\n    \"1\",\n    \"2\",\n    \"Fizz\",\n    \"4\",\n    \"Buzz\",\n    \"Fizz\",\n    \"7\",\n    \"8\",\n    \"Fizz\",\n    \"Buzz\",\n    \"11\",\n    \"Fizz\",\n    \"13\",\n    \"14\",\n    \"FizzBuzz\"\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<String> fizzBuzz(int n) {\n        List<String> res = new ArrayList<String>();\n        int i = 1;\n        while(i <= n){\n            if(i % 3 == 0 && i % 5 == 0){\n                res.add(\"FizzBuzz\");\n            } else if (i % 3 == 0){\n                res.add(\"Fizz\");\n            } else if (i % 5 == 0){\n                res.add(\"Buzz\");\n            } else {\n                res.add(String.valueOf(i));\n            }\n            i++;\n        }\n        return res;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 91,
        "number": 414,
        "title": "Third Maximum Number",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <b>non-empty</b> array of integers, return the <b>third</b> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [3, 2, 1]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> The third maximum is 1.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [1, 2]\n\n<b>Output:</b> 2\n\n<b>Explanation:</b> The third maximum does not exist, so the maximum (2) is returned instead.\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b> [2, 2, 3, 1]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int thirdMax(int[] nums) {\n        Integer max1 = null;\n        Integer max2 = null;\n        Integer max3 = null;\n        for (Integer n : nums) {\n            if (n.equals(max1) || n.equals(max2) || n.equals(max3)) continue;\n            if (max1 == null || n > max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = n;\n            } else if (max2 == null || n > max2) {\n                max3 = max2;\n                max2 = n;\n            } else if (max3 == null || n > max3) {\n                max3 = n;\n            }\n        }\n        return max3 == null ? max1 : max3;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 92,
        "number": 415,
        "title": "Add Strings",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p>\n\n    <p><b>Note:</b>\n    </p><ol>\n    <li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li>\n    <li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>\n    <li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>\n    <li>You <b>must not use any built-in BigInteger library</b> or <b>convert the inputs to integer</b> directly.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Time Complexity: O(m + n)\n    // Auxiliary Space: O(m + n)\n    public String addStrings(String num1, String num2) {\n        int i = num1.length() - 1;\n        int j = num2.length() - 1;\n        int carry = 0;\n        char[] num1Array = num1.toCharArray();\n        char[] num2Array = num2.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        while (i >= 0 || j >= 0 || carry == 1) {\n            int a = i >= 0 ? (num1Array[i--] - '0') : 0;\n            int b = j >= 0 ? (num2Array[j--] - '0') : 0;\n            int sum = a + b + carry;\n            sb.insert(0, sum % 10);\n            carry = sum / 10;\n        }\n        return sb.toString();\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 93,
        "number": 434,
        "title": "Number of Segments in a String",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p>\n\n    <p>Please note that the string does not contain any <b>non-printable</b> characters.</p>\n\n    <p><b>Example:</b></p>\n    <pre><b>Input:</b> \"Hello, my name is John\"\n<b>Output:</b> 5\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int countSegments(String s) {\n        String trimmed = s.trim();\n        return trimmed.length() == 0 ? 0 : trimmed.split(\"\\\\s+\").length;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 94,
        "number": 437,
        "title": "Path Sum III",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>You are given a binary tree in which each node contains an integer value.</p>\n\n    <p>Find the number of paths that sum to a given value.</p>\n\n    <p>The path does not need to start or end at the root or a leaf, but it must go downwards\n        (traveling only from parent nodes to child nodes).</p>\n\n    <p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n\n    </p><p><b>Example:</b>\n</p><pre>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    <b>5</b>   <b>-3</b>\n   <b>/</b> <b>\\</b>    <b>\\</b>\n  <b>3</b>   <b>2</b>   <b>11</b>\n / \\   <b>\\</b>\n3  -2   <b>1</b>\n\nReturn 3. The paths that sum to 8 are:\n\n1.  5 -&gt; 3\n2.  5 -&gt; 2 -&gt; 1\n3. -3 -&gt; 11\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int pathSum(TreeNode root, int sum) {\n        if (root == null) return 0;\n        return pathSumFrom(root, sum) + pathSum(root.left, sum) +\n                pathSum(root.right, sum);\n    }\n\n    private int pathSumFrom(TreeNode node, int sum) {\n        if (node == null) return 0;\n        return (node.val == sum ? 1 : 0)\n                + pathSumFrom(node.left, sum - node.val)\n                + pathSumFrom(node.right, sum - node.val);\n    }\n}",
        "tags": "12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 95,
        "number": 438,
        "title": "Find All Anagrams in a String",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string <b>s</b> and a <b>non-empty</b> string <b>p</b>, find all the start indices of <b>p</b>'s anagrams in <b>s</b>.</p>\n\n    <p>Strings consists of lowercase English letters only and the length of both strings <b>s</b> and <b>p</b> will not be larger than 20,100.</p>\n\n    <p>The order of output does not matter.</p>\n\n    <p><b>Example 1:</b>\n    </p><pre><b>Input:</b>\ns: \"cbaebabacd\" p: \"abc\"\n\n<b>Output:</b>\n[0, 6]\n\n<b>Explanation:</b>\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre><b>Input:</b>\ns: \"abab\" p: \"ab\"\n\n<b>Output:</b>\n[0, 1, 2]\n\n<b>Explanation:</b>\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int[] chars = new int[26];\n        List<Integer> result = new ArrayList<>();\n\n        if (s == null || p == null || s.length() < p.length())\n            return result;\n        for (char c : p.toCharArray())\n            chars[c - 'a']++;\n\n        int start = 0, end = 0, count = p.length();\n        // Go over the string\n        while (end < s.length()) {\n            // If the char at start appeared in p, we increase count\n            if (end - start == p.length() && chars[s.charAt(start++) - 'a']++ >= 0)\n                count++;\n            // If the char at end appeared in p (since it's not -1 after decreasing),\n            // we decrease count\n            if (--chars[s.charAt(end++) - 'a'] >= 0)\n                count--;\n            if (count == 0)\n                result.add(start);\n        }\n        return result;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 96,
        "number": 441,
        "title": "Arranging Coins",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>You have a total of <i>n</i> coins that you want to form in a staircase shape, where every <i>k</i>-th row must have exactly <i>k</i> coins.</p>\n\n    <p>Given <i>n</i>, find the total number of <b>full</b> staircase rows that can be formed.</p>\n\n    <p><i>n</i> is a non-negative integer and fits within the range of a 32-bit signed integer.</p>\n\n    <p><b>Example 1:</b>\n    </p><pre>n = 5\n\nThe coins can form the following rows:\n¤\n¤ ¤\n¤ ¤\n\nBecause the 3rd row is incomplete, we return 2.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre>n = 8\n\nThe coins can form the following rows:\n¤\n¤ ¤\n¤ ¤ ¤\n¤ ¤\n\nBecause the 4th row is incomplete, we return 3.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int arrangeCoins(int n) {\n        int start = 0;\n        int end = n;\n        int mid = 0;\n        while (start <= end) {\n            mid = (start + end) >>> 1;\n            if ((0.5 * mid * mid + 0.5 * mid) <= n) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n        return start - 1;\n    }\n}",
        "tags": "4, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 97,
        "number": 447,
        "title": "Number of Boomerangs",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given <i>n</i> points in the plane that are all pairwise distinct, a \"boomerang\" is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<b>the order of the tuple matters</b>).</p>\n\n    <p>Find the number of boomerangs. You may assume that <i>n</i> will be at most <b>500</b> and coordinates of points are all in the range <b>[-10000, 10000]</b> (inclusive).</p>\n\n    <p><b>Example:</b><br>\n    </p><pre><b>Input:</b>\n[[0,0],[1,0],[2,0]]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nThe two boomerangs are <b>[[1,0],[0,0],[2,0]]</b> and <b>[[1,0],[2,0],[0,0]]</b>\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Time complexity:  O(n^2)\n    // Space complexity: O(n)\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < points.length; i++) {\n            for (int j = 0; j < points.length; j++) {\n                if (i == j)\n                    continue;\n                int d = getDistance(points[i], points[j]);\n                map.put(d, map.getOrDefault(d, 0) + 1);\n            }\n            for (int val : map.values()) {\n                res += val * (val - 1);\n            }\n            map.clear();\n        }\n        return res;\n    }\n\n    private int getDistance(int[] a, int[] b) {\n        int dx = a[0] - b[0];\n        int dy = a[1] - b[1];\n\n        return dx * dx + dy * dy;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 98,
        "number": 448,
        "title": "Find All Numbers Disappeared in an Array",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array of integers where 1 ? a[i] ? <i>n</i> (<i>n</i> = size of array), some elements appear twice and others appear once.</p>\n\n    <p>Find all the elements of [1, <i>n</i>] inclusive that do not appear in this array.</p>\n\n    <p>Could you do it without extra space and in O(<i>n</i>) runtime? You may assume the returned list does not count as extra space.</p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b>\n[4,3,2,7,8,2,3,1]\n\n<b>Output:</b>\n[5,6]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     * 1. mark elements as negative using nums[nums[i] -1] = -nums[nums[i]-1].\n     * In this way all the numbers that we have seen will be marked as negative.\n     * 2. In the second iteration, if a value is not marked as negative,\n     * it implies we have never seen that index before, so just add it to the return list.\n     **/\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> ret = new ArrayList<Integer>();\n\n        for (int i = 0; i < nums.length; i++) {\n            int val = Math.abs(nums[i]) - 1;\n            if (nums[val] > 0) {\n                nums[val] = -nums[val];\n            }\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                ret.add(i + 1);\n            }\n        }\n        return ret;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 99,
        "number": 453,
        "title": "Minimum Moves to Equal Array Elements",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <b>non-empty</b> integer array of size <i>n</i>, find the minimum number of moves required to make all array elements equal, where a move is incrementing <i>n</i> - 1 elements by 1.</p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b>\n[1,2,3]\n\n<b>Output:</b>\n3\n\n<b>Explanation:</b>\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     * Adding 1 to n - 1 elements is the same as subtracting 1 from one element,\n     * w.r.t goal of making the elements in the array equal.\n     * So, best way to do this is make all the elements in the array equal to the min element.\n     * sum(array) - n * minimum\n     **/\n    public int minMoves(int[] nums) {\n        if (nums.length == 0) return 0;\n        int min = nums[0];\n        for (int n : nums) min = Math.min(min, n);\n        int res = 0;\n        for (int n : nums) res += n - min;\n        return res;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 100,
        "number": 455,
        "title": "Assign Cookies",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g<sub>i</sub>, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s<sub>j</sub>. If s<sub>j</sub> &gt;= g<sub>i</sub>, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n</p>\n\n    <p><b>Note:</b><br>\n        You may assume the greed factor is always positive. <br>\n        You cannot assign more than one cookie to one child.\n    </p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [1,2,3], [1,1]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [1,2], [1,2,3]\n\n<b>Output:</b> 2\n\n<b>Explanation:</b> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.\nYou have 3 cookies and their sizes are big enough to gratify all of the children,\nYou need to output 2.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Just assign the cookies starting from the child with\n    // less greediness to maximize the number of happy children\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0;\n        for (int j = 0; i < g.length && j < s.length; j++) {\n            if (g[i] <= s[j]) i++;\n        }\n        return i;\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 101,
        "number": 459,
        "title": "Repeated Substring Pattern",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.  You may assume the given string consists of lowercase English letters only and its length  will not exceed 10000.\n\n    </p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \"abab\"\n\n<b>Output:</b> True\n\n<b>Explanation:</b> It's the substring \"ab\" twice.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> \"aba\"\n\n<b>Output:</b> False\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b> \"abcabcabcabc\"\n\n<b>Output:</b> True\n\n<b>Explanation:</b> It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.)\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        //This is the kmp issue\n        int[] prefix = getOverlay(s);\n        int len = prefix[s.length() - 1];\n        int n = s.length();\n        return (len > 0 && n % (n - len) == 0);\n    }\n\n    // Generate the prefix function for pattern itself\n    int[] getOverlay(String pattern) {\n        int[] res = new int[pattern.length()];\n        res[0] = 0;\n        for (int i = 1; i < pattern.length(); i++) {\n            int index = res[i - 1];\n            while (index > 0 && pattern.charAt(index) != pattern.charAt(i))\n                index = res[index - 1];\n            res[i] = (pattern.charAt(index) == pattern.charAt(i)) ? index + 1 : 0;\n        }\n        return res;\n    }\n\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 102,
        "number": 461,
        "title": "Hamming Distance",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n    <p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p>\n\n    <p><b>Note:</b><br>\n        0 <= <code>x</code>, <code>y</code> &lt; 2<sup>31</sup>.\n    </p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b> x = 1, y = 4\n\n<b>Output:</b> 2\n\n<b>Explanation:</b>\n1   (0 0 0 1)\n4   (0 1 0 0)\n       |   |\n\nThe above arrows point to positions where the corresponding bits are different.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int hammingDistance(int x, int y) {\n        int z = x ^ y;\n        int res = 0;\n        for(int i = 0; i <=31; i++){\n            int offset = (1 << i);\n            if((z & offset) > 0)\n                res++;\n        }\n        return res;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 103,
        "number": 463,
        "title": "Island Perimeter",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have \"lakes\" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.</p>\n\n    <p><b>Example:</b>\n    </p><pre>[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n\nAnswer: 16\nExplanation: The perimeter is the 16 yellow stripes in the image below:\n<img src=\"https://leetcode.com/static/images/problemset/island.png\">\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     * 1. loop over the matrix and count the number of islands;\n     * 2. if the current dot is an island,\n     * count if it has any right neighbour or down neighbour;\n     * 3. the result is islands * 4 - neighbours * 2\n     **/\n    public int islandPerimeter(int[][] grid) {\n        int islands = 0, neighbours = 0;\n\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == 1) {\n                    islands++; // count islands\n                    if (i < grid.length - 1 && grid[i + 1][j] == 1)\n                        neighbours++; // count down neighbours\n                    if (j < grid[i].length - 1 && grid[i][j + 1] == 1)\n                        neighbours++; // count right neighbours\n                }\n            }\n        }\n\n        return islands * 4 - neighbours * 2;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 104,
        "number": 475,
        "title": "Heaters",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p>\n\n    <p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n\n    <p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n    <li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n    <li>As long as a house is in the heaters' warm radius range, it can be warmed.</li>\n    <li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [1,2,3],[2]\n<b>Output:</b> 1\n<b>Explanation:</b> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [1,2,3,4],[1,4]\n<b>Output:</b> 1\n<b>Explanation:</b> The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        if (houses == null || houses.length == 0) return 0;\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n        int ans = 0;\n        int i = 0;\n        int j = 0;\n        while (i < houses.length) {\n            // if house is located after some heater\n            if (houses[i] > heaters[j]) {\n                // then find a heater that stands after the house\n                while (j != heaters.length - 1 && heaters[j] < houses[i]) {\n                    j++;\n                }\n            }\n            // corner case when the heater is the first  one\n            if (j == 0 || heaters[j] < houses[i]) {\n                ans = Math.max(ans, Math.abs(heaters[j] - houses[i]));\n                i++;\n                continue;\n            }\n            // if house is located between jth and j-1th heaters\n            int dist = Math.min(houses[i] - heaters[j - 1], heaters[j] - houses[i]);\n            ans = Math.max(ans, dist);\n            i++;\n        }\n        return ans;\n    }\n}",
        "tags": "6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 105,
        "number": 476,
        "title": "Number Complement",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\n    <li>You could assume no leading zero bit in the integer’s binary representation.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> 5\n<b>Output:</b> 2\n<b>Explanation:</b> The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> 1\n<b>Output:</b> 0\n<b>Explanation:</b> The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findComplement(int num) {\n        int mask = (Integer.highestOneBit(num) << 1) - 1;\n        num = ~num;\n        return num & mask;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 106,
        "number": 479,
        "title": "Largest Palindrome Product",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Find the largest palindrome made from the product of two n-digit numbers.</p>\n    <p> Since the result could be very large, you should return the largest palindrome mod 1337.</p>\n\n    <p><b>Example:</b>\n    </p><p>Input: 2</p>\n    <p>Output: 987</p>\n    <p>Explanation: 99 x 91 = 9009, 9009 % 1337 = 987\n    </p>\n    <p></p>\n\n\n    <p><b>Note:</b>\n    </p><p>The range of n is [1,8].</p>\n    <p></p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public int largestPalindrome(int n) {\n        if (n == 1) return 9;\n        int max = (int) Math.pow(10, n) - 1;\n        for (int v = max - 1; v > max / 10; v--) {\n            StringBuilder vStr = new StringBuilder().append(v);\n            long u = Long.valueOf(v + vStr.reverse().toString());\n            for (long x = max; x * x >= u; x--)\n                if (u % x == 0)\n                    return (int) (u % 1337);\n        }\n        return 0;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 107,
        "number": 485,
        "title": "Max Consecutive Ones",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [1,1,0,1,1,1]\n<b>Output:</b> 3\n<b>Explanation:</b> The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b>\n    </p><ul>\n    <li>The input array will only contain <code>0</code> and <code>1</code>.</li>\n    <li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int result = 0;\n        int count = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 1) {\n        \tcount++;\n        \tresult = Math.max(count, result);\n            }\n            else count = 0;\n        }\n\n        return result;\n    }\n}",
        "tags": "0",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 108,
        "number": 500,
        "title": "Keyboard Row",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a List of words, return the words that can be typed using letters of <b>alphabet</b> on only one row's of American keyboard like the image below. </p>\n\n    <br>\n    <p>\n        <img src=\"https://leetcode.com/static/images/problemset/keyboard.png\" alt=\"American keyboard\">\n    </p>\n    <br>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\n<b>Output:</b> [\"Alaska\", \"Dad\"]\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>You may use one character in the keyboard more than once.</li>\n    <li>You may assume the input string will only contain letters of alphabet.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String[] findWords(String[] words) {\n        boolean[] inds = new boolean[words.length];\n        int count = 0;\n        for(int i = 0; i < words.length; i++){\n            int wordLen = words[i].length();\n            if(wordLen == 0) continue;\n            int j = 0;\n            int initalRow = getRowNum(words[i].charAt(j++));\n            boolean rowChanged = false;\n            while(j < wordLen){\n            \tif(initalRow != getRowNum(words[i].charAt(j++))){\n            \t\trowChanged = true;\n            \t\tbreak;\n            \t}\n            }\n            if(!rowChanged){\n            \tinds[i] = true;\n                count++;\n            }\n        }\n\n        String[] res = new String[count];\n        int ind = 0;\n        for(int i = 0; i < words.length; i++){\n            if(inds[i]){\n                res[ind] = words[i];\n                ind++;\n            }\n        }\n        return res;\n    }\n\n    private int getRowNum(char c){\n        char[] firstRow = {'Q', 'q', 'W', 'w', 'E', 'e', 'R', 'r', 'T', 't', 'Y', 'y', 'U', 'u', 'I', 'i', 'O', 'o', 'P', 'p'};\n        char[] secondRow = {'A', 'a', 'S', 's', 'D', 'd', 'F', 'f', 'G', 'g', 'H', 'h', 'J', 'j', 'K', 'k', 'L', 'l'};\n\n        for(int i = 0; i < firstRow.length; i++){\n            if(firstRow[i] == c) return 1;\n        }\n\n        for(int i = 0; i < secondRow.length; i++){\n            if(secondRow[i] == c) return 2;\n        }\n        return 3;\n    }\n}",
        "tags": "1",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 109,
        "number": 543,
        "title": "Diameter of Binary Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <b>longest</b> path between any two nodes in a tree. This path may or may not pass through the root.\n</p>\n\n    <p>\n        <b>Example:</b><br>\n        Given a binary tree <br>\n    </p><pre>          1\n         / \\\n        2   3\n       / \\\n      4   5\n</pre>\n    <p></p>\n    <p>\n        Return <b>3</b>, which is the length of the path [4,2,1,3] or [5,2,1,3].\n    </p>\n\n    <p><b>Note:</b>\n        The length of path between two nodes is represented by the number of edges between them.\n    </p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int diameterOfBinaryTree(TreeNode root) {\n        if(root == null || root.left == null && root.right == null)\n            return 0;\n        int diameterOfLeftTree = diameterOfBinaryTree(root.left);\n        int diameterOfRightTree = diameterOfBinaryTree(root.right);\n        // Get edges' number of left subtree\n        int leftTreeLen = root.left == null ? 0 : getLen(root.left) + 1;\n        // Get edges' number of right subtree\n        int rightTreeLen = root.right == null ? 0 : getLen(root.right) + 1;\n        int rootLen = leftTreeLen + rightTreeLen;\n        return Math.max(Math.max(diameterOfLeftTree, diameterOfRightTree), rootLen);\n    }\n\n    private int getLen(TreeNode node){\n        if(node == null)\n            return 0;\n        int leftTreeLen = node.left == null ? 0 : getLen(node.left) + 1;\n        int rightTreeLen = node.right == null ? 0 : getLen(node.right) + 1;\n        return Math.max(leftTreeLen, rightTreeLen);\n    }\n}",
        "tags": "12",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 110,
        "number": 551,
        "title": "Student Attendance Record I",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p>You are given a string representing an attendance record for a student. The record only contains the following three characters:\n\n    </p><p>\n</p><ol>\n    <li><b>'A'</b> : Absent. </li>\n    <li><b>'L'</b> : Late.</li>\n    <li> <b>'P'</b> : Present. </li>\n</ol>\n    <p></p>\n\n    <p>\n        A student could be rewarded if his attendance record doesn't contain <b>more than one 'A' (absent)</b> or <b>more than two continuous 'L' (late)</b>.    </p>\n\n    <p>You need to return whether the student could be rewarded according to his attendance record.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> \"PPALLP\"\n<b>Output:</b> True\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> \"PPALLL\"\n<b>Output:</b> False\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean checkRecord(String s) {\n        int Acount = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == 'A'){\n                Acount++;\n                if(Acount > 1)\n                    return false;\n            }\n            if(i > 1 && s.charAt(i) == 'L' &&\n                s.charAt(i - 1) == 'L' && s.charAt(i - 2) == 'L')\n                return false;\n        }\n        return true;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 111,
        "number": 557,
        "title": "Reverse Words in a String III",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> \"Let's take LeetCode contest\"\n<b>Output:</b> \"s'teL ekat edoCteeL tsetnoc\"\n</pre>\n    <p></p>\n\n    <p><b>Note:</b>\n        In the string, each word is separated by single space and there will not be any extra space in the string.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String reverseWords(String s) {\n        StringBuilder res = new StringBuilder();\n        String[] strs = s.split(\" \");\n        for(int i = 0; i < strs.length; i++){\n            StringBuilder sb = new StringBuilder(strs[i]);\n            res.append(sb.reverse());\n            if(i != strs.length-1){\n                res.append(\" \");\n            }\n        }\n        return res.toString();\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 112,
        "number": 575,
        "title": "Distribute Candies",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p>Given an integer array with <b>even</b> length, where different numbers in this array represent different <b>kinds</b> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <b>equally</b> in number to brother and sister. Return the maximum number of <b>kinds</b> of candies the sister could gain.\n\n    </p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> candies = [1,1,2,2,3,3]\n<b>Output:</b> 3\n<b>Explanation:</b>\nThere are three different kinds of candies (1, 2 and 3), and two candies for each kind.\nOptimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.\nThe sister has three different kinds of candies.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> candies = [1,1,2,3]\n<b>Output:</b> 2\n<b>Explanation:</b> For example, the sister has candies [2,3] and the brother has candies [1,1].\nThe sister has two different kinds of candies, the brother has only one kind of candies.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b>\n    </p><ol>\n    <li>The length of the given array is in range [2, 10,000], and will be even.</li>\n    <li>The number in given array is in range [-100,000, 100,000].</li>\n    <ol>\n        <p></p><p></p>\n    </ol></ol></div>",
        "solution": "public class Solution {\n    public int distributeCandies(int[] candies) {\n        HashSet < Integer > set = new HashSet < > ();\n        for (int candy: candies) {\n            set.add(candy);\n        }\n        return Math.min(set.size(), candies.length / 2);\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 113,
        "number": 581,
        "title": "Shortest Unsorted Continuous Subarray",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer array, you need to find one <b>continuous subarray</b> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. </p>\n\n    <p>You need to find the <b>shortest</b> such subarray and output its length.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [2, 6, 4, 8, 10, 9, 15]\n<b>Output:</b> 5\n<b>Explanation:</b> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>Then length of the input array is in range [1, 10,000].</li>\n    <li>The input array may contain duplicates, so ascending order here means <b>&lt;=</b>. </li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        // Find where the unsorted array sure start\n        // and get min after the turning point\n        boolean flag = false;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < nums[i - 1])\n                flag = true;\n            if (flag)\n                min = Math.min(min, nums[i]);\n        }\n        // Find where the unsorted array sure end\n        // and get the max after the turning point\n        flag = false;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            if (nums[i] > nums[i + 1])\n                flag = true;\n            if (flag)\n                max = Math.max(max, nums[i]);\n        }\n        // Find the actual start point where\n        // it is less than min\n        int l, r;\n        for (l = 0; l < nums.length; l++) {\n            if (min < nums[l])\n                break;\n        }\n        // Find the actual start point where\n        // it is greater than max\n        for (r = nums.length - 1; r >= 0; r--) {\n            if (max > nums[r])\n                break;\n        }\n        return r - l < 0 ? 0 : r - l + 1;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 114,
        "number": 594,
        "title": "Longest Harmonious Subsequence",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is <b>exactly</b> 1.</p>\n\n    <p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible <a href=\"https://en.wikipedia.org/wiki/Subsequence\">subsequences</a>.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [1,3,2,2,5,2,3,7]\n<b>Output:</b> 5\n<b>Explanation:</b> The longest harmonious subsequence is [3,2,2,2,3].\n</pre>\n    <p></p>\n\n    <p><b>Note:</b>\n        The length of the input array will not exceed 20,000.\n    </p>\n\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public int findLHS(int[] nums) {\n        if(nums.length <= 1) return 0;\n        Map<Integer, Integer> numsMap = new HashMap<>();\n        int res = 0;\n        int cur = 0;\n\n        for(int num : nums){\n            numsMap.putIfAbsent(num, 0);\n            numsMap.put(num, numsMap.get(num) + 1);\n        }\n\n        for(int num : nums){\n            if(numsMap.containsKey(num + 1)){\n                cur = numsMap.get(num) + numsMap.get(num + 1);\n            }\n            res = cur > res ? cur : res;\n        }\n        return res;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 115,
        "number": 598,
        "title": "Range Addition II",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an m * n matrix <b>M</b> initialized with all <b>0</b>'s and several update operations.</p>\n    <p>Operations are represented by a 2D array, and each operation is represented by an array with two <b>positive</b> integers <b>a</b> and <b>b</b>, which means <b>M[i][j]</b> should be <b>added by one</b> for all <b>0 &lt;= i &lt; a</b> and <b>0 &lt;= j &lt; b</b>. </p>\n    <p>You need to count and return the number of maximum integers in the matrix after performing all the operations.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b>\nm = 3, n = 3\noperations = [[2,2],[3,3]]\n<b>Output:</b> 4\n<b>Explanation:</b>\nInitially, M =\n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n\nAfter performing [2,2], M =\n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n\nAfter performing [3,3], M =\n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\n\nSo the maximum integer in M is 2, and there are four of it in M. So return 4.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The range of m and n is [1,40000].</li>\n    <li>The range of a is [1,m], and the range of b is [1,n].</li>\n    <li>The range of operations size won't exceed 10,000.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Just find the size of the left upper corner\n    // Time complexity : O(x)\n    // Space complexity : O(1)\n    public int maxCount(int m, int n, int[][] ops) {\n        for (int[] op: ops) {\n            m = Math.min(m, op[0]);\n            n = Math.min(n, op[1]);\n        }\n        return m * n;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 116,
        "number": 599,
        "title": "Minimum Index Sum of Two Lists",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.\n</p>\n    <p>\n        You need to help them find out their <b>common interest</b> with the <b>least list index sum</b>. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\n    </p>\n\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b>\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\n[\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n<b>Output:</b> [\"Shogun\"]\n<b>Explanation:</b> The only restaurant they both like is \"Shogun\".\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b>\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\n[\"KFC\", \"Shogun\", \"Burger King\"]\n<b>Output:</b> [\"Shogun\"]\n<b>Explanation:</b> The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1).\n</pre>\n    <p></p>\n\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The length of both lists will be in the range of [1, 1000].</li>\n    <li>The length of strings in both lists will be in the range of [1, 30].</li>\n    <li>The index is starting from 0 to the list length minus 1.</li>\n    <li>No duplicates in both lists.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        Map<String, Integer> string1ToIndex = new HashMap<>();\n        Map<String, Integer> commonToSum = new HashMap<>();\n        int minSum = Integer.MAX_VALUE;\n        // Put list 1 into map\n        for(int i = 0; i <list1.length; i++){\n            string1ToIndex.put(list1[i], i);\n        }\n        // Get common interests and track min sum of indexes\n        for(int i = 0; i <list2.length; i++){\n            if(string1ToIndex.containsKey(list2[i])){\n                int indexSum = string1ToIndex.get(list2[i]) + i;\n                minSum = Math.min(minSum, indexSum);\n                commonToSum.put(list2[i], indexSum);\n            }\n        }\n        List<String> resList = new ArrayList<>();\n        for(Map.Entry<String, Integer> entry : commonToSum.entrySet()){\n            if(entry.getValue() == minSum)\n                resList.add(entry.getKey());\n        }\n        String[] res = new String[resList.size()];\n        for(int i = 0; i < resList.size(); i++){\n            res[i] = resList.get(i);\n        }\n        return res;\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 117,
        "number": 605,
        "title": "Can Place Flowers",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>\n\n    <p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number <b>n</b>, return if <b>n</b> new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> flowerbed = [1,0,0,0,1], n = 1\n<b>Output:</b> True\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> flowerbed = [1,0,0,0,1], n = 2\n<b>Output:</b> False\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The input array won't violate no-adjacent-flowers rule.</li>\n    <li>The input array size is in the range of [1, 20000].</li>\n    <li><b>n</b> is a non-negative integer which won't exceed the input array size.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int i = 0, count = 0;\n        while (i < flowerbed.length) {\n            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) &&\n                  (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n                flowerbed[i] = 1;\n                count++;\n            }\n            i++;\n        }\n        return count >= n;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 118,
        "number": 606,
        "title": "Construct String from Binary Tree",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>\n\n    <p>The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> Binary tree: [1,2,3,4]\n       1\n     /   \\\n    2     3\n   /\n  4\n\n<b>Output:</b> \"1(2(4))(3)\"\n<br><b>Explanation:</b> Originallay it needs to be \"1(2(4)())(3()())\", <br>but you need to omit all the unnecessary empty parenthesis pairs. <br>And it will be \"1(2(4))(3)\".\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> Binary tree: [1,2,3,null,4]\n       1\n     /   \\\n    2     3\n     \\\n      4\n\n<b>Output:</b> \"1(2()(4))(3)\"\n<br><b>Explanation:</b> Almost the same as the first example, <br>except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Recursive Solution\n    public String tree2str(TreeNode t) {\n        if(t == null)\n            return \"\";\n        // Case 2: None of the left or the right child exist for the current node.\n        if(t.left == null && t.right == null)\n            return t.val + \"\";\n        // Case 3: Only the left child exists for the current node.\n        if(t.right == null)\n            return t.val + \"(\" + tree2str(t.left) + \")\";\n        // Case 1: Both the left child and the right child exist for the current node.\n        // Case 4: Only the right child exists for the current node.\n        return t.val + \"(\" + tree2str(t.left) + \")(\" + tree2str(t.right) + \")\";\n    }\n\n    // Iterative Solution\n    public String tree2str(TreeNode t) {\n        if (t == null)\n            return \"\";\n        Stack < TreeNode > stack = new Stack < > ();\n        stack.push(t);\n        Set < TreeNode > visited = new HashSet < > ();\n        String s = \"\";\n        while (!stack.isEmpty()) {\n            t = stack.peek();\n            if (visited.contains(t)) {\n                stack.pop();\n                s += \")\";\n            } else {\n                visited.add(t);\n                s += \"(\" + t.val;\n                if (t.left == null && t.right != null)\n                    s += \"()\";\n                if (t.right != null)\n                    stack.push(t.right);\n                if (t.left != null)\n                    stack.push(t.left);\n            }\n        }\n        return s.substring(1, s.length() - 1);\n    }\n}",
        "tags": "5, 12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 119,
        "number": 617,
        "title": "Merge Two Binary Trees",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.\n</p>\n    <p>\n        You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\n    </p>\n\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b>\n\tTree 1                     Tree 2\n          1                         2\n         / \\                       / \\\n        3   2                     1   3\n       /                           \\   \\\n      5                             4   7\n<b>Output:</b>\nMerged tree:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\\n\t 5   4   7\n</pre>\n    <p></p>\n\n\n    <p><b>Note:</b>\n        The merging process must start from the root nodes of both trees.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if(t1 == null) return t2;\n        if(t2 == null) return t1;\n        TreeNode newRoot = new TreeNode(t1.val + t2.val);\n        newRoot.left = mergeTrees(t1.left, t2.left);\n        newRoot.right = mergeTrees(t1.right, t2.right);\n        return newRoot;\n    }\n}",
        "tags": "12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 120,
        "number": 624,
        "title": "Maximum Distance in Arrays",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given <code>m</code> arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers <code>a</code> and <code>b</code> to be their absolute difference <code>|a-b|</code>. Your task is to find the maximum distance.\n</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b>\n[[1,2,3],\n [4,5],\n [1,2,3]]\n<b>Output:</b> 4\n<b>Explanation:</b>\nOne way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>Each given array will have at least 1 number. There will be at least two non-empty arrays.</li>\n    <li>The total number of the integers in <b>all</b> the <code>m</code> arrays will be in the range of [2, 10000].</li>\n    <li>The integers in the <code>m</code> arrays will be in the range of [-10000, 10000].</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int maxDistance(List<List<Integer>> arrays) {\n        int min = arrays.get(0).get(0);\n        int max = arrays.get(0).get(arrays.get(0).size() - 1);\n        int res = 0;\n        for(int i = 1; i < arrays.size(); i++){\n            int len = arrays.get(i).size();\n            int curMin = arrays.get(i).get(0);\n            int curMax = arrays.get(i).get(len - 1);\n            res = Math.max(res, curMax - min);\n            res = Math.max(res, max - curMin);\n            min = Math.min(min, curMin);\n            max = Math.max(max, curMax);\n        }\n        return res;\n    }\n}",
        "tags": "0, 1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 121,
        "number": 628,
        "title": "Maximum Product of Three Numbers",
        "difficulty": "Easy",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [1,2,3]\n<b>Output:</b> 6\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [1,2,3,4]\n<b>Output:</b> 24\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].</li>\n    <li>Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int maximumProduct(int[] nums) {\n        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\n        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;\n        for (int n: nums) {\n            if (n <= min1) {\n                min2 = min1;\n                min1 = n;\n            } else if (n <= min2) {     // n lies between min1 and min2\n                min2 = n;\n            }\n            if (n >= max1) {            // n is greater than max1, max2 and max3\n                max3 = max2;\n                max2 = max1;\n                max1 = n;\n            } else if (n >= max2) {     // n lies betweeen max1 and max2\n                max3 = max2;\n                max2 = n;\n            } else if (n >= max3) {     // n lies betwen max2 and max3\n                max3 = n;\n            }\n        }\n        return Math.max(min1 * min2 * max1, max1 * max2 * max3);\n    }\n}",
        "tags": "0, 3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 122,
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>You are given two <b>non-empty</b> linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n\n    <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n    <p style=\"font-family:monospace\">\n        <b>Input:</b> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>\n        <b>Output:</b> 7 -&gt; 0 -&gt; 8</p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(1)\n     *\n     * Create carry to track the carry over\n     * Create a pointer to track the node position\n     * build the list while l1 not null or l2 not null or carry > 0\n     *      reset next node and carry\n     *\n     */\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // Since both lists are non-empty\n        ListNode head = new ListNode((l1.val + l2.val) % 10);\n        int carry = (l1.val + l2.val) / 10;\n        ListNode cur = head;\n        // Go to next nodes\n        l1 = l1.next;\n        l2 = l2.next;\n        while(l1 != null || l2 != null || carry > 0){\n            int totalVal = carry;\n            totalVal += l1 == null ? 0 : l1.val;\n            totalVal += l2 == null ? 0 : l2.val;\n            carry = totalVal / 10;\n            cur.next = new ListNode(totalVal % 10);\n            cur = cur.next;\n            l1 = l1 == null ? null : l1.next;\n            l2 = l2 == null ? null : l2.next;\n        }\n        return head;\n    }\n}",
        "tags": "2, 3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 123,
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a string, find the length of the <b>longest substring</b> without repeating characters.</p>\n\n    <p><b>Examples:</b></p>\n\n    <p>Given <code>\"abcabcbb\"</code>, the answer is <code>\"abc\"</code>, which the length is 3.</p>\n\n    <p>Given <code>\"bbbbb\"</code>, the answer is <code>\"b\"</code>, with the length of 1.</p>\n\n    <p>Given <code>\"pwwkew\"</code>, the answer is <code>\"wke\"</code>, with the length of 3. Note that the answer must be a <b>substring</b>, <code>\"pwke\"</code> is a <i>subsequence</i> and not a substring.</p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Time Complexity: O(n)\n     * Space Complexity: O(n)\n     *\n     * Create a pointer to track the end of the substring\n     * Create a pointer to track the start of the substring\n     * Create a map for char to its latest index\n     * Set both start and end pointer to the first char\n     * while end is not the end of the s\n     *  if(map have end char)\n     *      update start pointer\n     *  update max length\n     *  put the index into the map for the char     *\n     */\n    public int lengthOfLongestSubstring(String s) {\n        if(s.length() <= 1)\n            return s.length();\n        int startInd = 0;\n        int endInd = 0;\n        int maxLen = 0;\n        Map<Character, Integer> charToIndMap = new HashMap<>();\n\n        while(endInd < s.length()){\n            char c = s.charAt(endInd);\n            if(charToIndMap.containsKey(c)){\n                startInd = (charToIndMap.get(c) + 1) > startInd ?\n                        (charToIndMap.get(c) + 1) : startInd;\n            }\n            maxLen = Math.max(maxLen, endInd - startInd + 1);\n            charToIndMap.put(c, endInd++);\n        }\n        return maxLen;\n    }\n}",
        "tags": "1, 4, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 124,
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a string <b>s</b>, find the longest palindromic substring in <b>s</b>. You may assume that the maximum length of <b>s</b> is 1000.</p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b> \"babad\"\n\n<b>Output:</b> \"bab\"\n\n<b>Note:</b> \"aba\" is also a valid answer.\n</pre>\n    <p></p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b> \"cbbd\"\n\n<b>Output:</b> \"bb\"\n</pre>\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Time Complexity: O(n^2)\n     * Space Complexity: O(1)\n     *\n     *\n     * 1. Palindrome with center in the middle\n     *  for each element scan both side until they are different\n     * 2. Palindrome with center of two elements in the middle\n     *  for every two elements scan both side until they are different\n     *\n     */\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() <= 1) { return s;}\n\n        String longest = s.substring(0, 1);\n        for (int i = 0; i < s.length(); i++) {\n            // get longest palindrome with center of i\n            String tmp = helper(s, i, i);\n            if (tmp.length() > longest.length()) {\n                longest = tmp;\n            }\n\n            // get longest palindrome with center of i, i+1\n            tmp = helper(s, i, i + 1);\n            if (tmp.length() > longest.length()) {\n                longest = tmp;\n            }\n        }\n        return longest;\n    }\n\n    // Given a center, either one letter or two letter,\n    // Find longest palindrome\n    public String helper(String s, int begin, int end) {\n        while (begin >= 0 && end <= s.length() - 1\n                && s.charAt(begin) == s.charAt(end)) {\n            begin--;\n            end++;\n        }\n        return s.substring(begin + 1, end);\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 125,
        "number": 6,
        "title": "ZigZag Conversion",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    The string <code>\"PAYPALISHIRING\"</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n</p><pre>P   A   H   N\nA P L S I I G\nY   I   R\n</pre>\n\n    And then read line by line: <code>\"PAHNAPLSIIGYIR\"</code><p></p>\n\n    <p>\n        Write the code that will take a string and make this conversion given a number of rows:\n\n    </p><pre>string convert(string text, int nRows);</pre>\n\n    <code>convert(\"PAYPALISHIRING\", 3)</code> should return <code>\"PAHNAPLSIIGYIR\"</code>.\n    <p></p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public String convert(String s, int numRows) {\n        if(s == null || s.length() == 0 || numRows == 1)\n            return s;\n        // string builders for each row\n        StringBuilder[] sbs = new StringBuilder[numRows];\n        // Have to initialize each element this way\n        for(int i = 0; i < sbs.length; i++){\n            sbs[i] = new StringBuilder();\n        }\n        int rowFlag = 1; // flag to incr or decr\n        int rowInd = 0; // index for rows\n        for(int i = 0; i < s.length(); i++){\n            sbs[rowInd].append(s.charAt(i));\n            if(rowInd == numRows - 1)\n                rowFlag = -1;\n            if(rowInd == 0)\n                rowFlag = 1;\n            rowInd += rowFlag;\n        }\n        StringBuilder res = new StringBuilder();\n        for(StringBuilder sb : sbs){\n            res.append(sb);\n        }\n        return res.toString();\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 126,
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement <span style=\"font-family:monospace\">atoi</span> to convert a string to an integer.</p>\n\n    <p><b>Hint:</b> Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>\n\n    <p>\n        <b>Notes:</b>\n        It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. </p>\n\n    <div class=\"spoilers\" style=\"display: none;\"><b>Requirements for atoi:</b>\n\n        <p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>\n\n        <p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>\n\n        <p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>\n\n        <p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.\n        </p>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n    public int myAtoi(String str) {\n        String curStr = str.trim();\n\n        int ind = 0;\n        boolean isPositive = true;\n        long longRes = 0;\n\n        if(curStr.length() > 0 && (curStr.charAt(0) == '+' || curStr.charAt(0) == '-')) {\n            isPositive = curStr.charAt(0) == '+';\n            ind++;\n        }\n\n        while(ind < curStr.length() && Character.isDigit(curStr.charAt(ind))){\n            longRes = longRes*10 + curStr.charAt(ind) - '0';\n            if(isPositive && longRes >= Integer.MAX_VALUE){\n                return Integer.MAX_VALUE;\n            }\n            if(!isPositive && -1*longRes <= Integer.MIN_VALUE){\n                return Integer.MIN_VALUE;\n            }\n            ind++;\n        }\n\n        return isPositive ? (int)longRes : -1*(int)longRes;\n    }\n}",
        "tags": "3, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 127,
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given <i>n</i> non-negative integers <i>a<sub>1</sub></i>, <i>a<sub>2</sub></i>, ..., <i>a<sub>n</sub></i>, where each represents a point at coordinate (<i>i</i>, <i>a<sub>i</sub></i>). <i>n</i> vertical lines are drawn such that the two endpoints of line <i>i</i> is at (<i>i</i>, <i>a<sub>i</sub></i>) and (<i>i</i>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n</p>\n    <p>Note: You may not slant the container and <i>n</i> is at least 2.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int maxArea(int[] height) {\n        int front = 0;\n        int tail = height.length - 1;\n        int result = 0;\n\n        while (front < tail) {\n            result = Math.max(result, Math.min(height[front], height[tail]) * (tail - front));\n            if (height[front] < height[tail]) {\n                front++;\n            } else {\n                tail--;\n            }\n        }\n        return result;\n    }\n}",
        "tags": "0, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 128,
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer, convert it to a roman numeral.\n</p>\n\n    <p>Input is guaranteed to be within the range from 1 to 3999.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String intToRoman(int num) {\n        String[] romans = {\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\",\"C\", \"CD\", \"D\", \"CM\",\"M\"};\n        int[] numbers = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000};\n\n        StringBuilder res = new StringBuilder();\n\n        int index = numbers.length - 1;\n        while(num != 0 && index >= 0){\n            if((num - numbers[index]) >= 0){\n                num -= numbers[index];\n                res.append(romans[index]);\n            }else{\n                index--;\n            }\n        }\n\n        return res.toString();\n    }\n}",
        "tags": "3, 5",
        "companies": "",
        "specialtags": "2"
    },
    {
        "id": 129,
        "number": 15,
        "title": "3Sum",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n\n    <p><b>Note:</b> The solution set must not contain duplicate triplets.</p>\n\n    <pre>For example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(nums == null || nums.length < 3)\n            return res;\n        Arrays.sort(nums);\n        // i for first element\n        for(int i = 0; i < nums.length - 2; i++){\n            // Stop if first elem is positive\n            if(nums[i] > 0) break;\n            // Skip duplicate for first elem\n            if(i > 0 && nums[i] == nums[i - 1]) continue;\n            int secondElemInd = i + 1; // track second elem\n            int thirdElemInd = nums.length - 1; // track third elem\n            int sum = 0;\n            while(secondElemInd < thirdElemInd){\n                // secondElemInd > i + 1 to ensure not first element\n                if(secondElemInd > i + 1 && nums[secondElemInd] == nums[secondElemInd - 1]){\n                    secondElemInd++; // skip duplicate for second element\n                    continue;\n                }\n                // Stop if sum of first two element greater than 0\n                if(nums[secondElemInd] + nums[i] > 0) break;\n                sum = nums[i] + nums[secondElemInd] + nums[thirdElemInd];\n                if(sum == 0){\n                    List<Integer> li = new ArrayList<>();\n                    li.add(nums[i]);\n                    li.add(nums[secondElemInd]);\n                    li.add(nums[thirdElemInd]);\n                    res.add(li);\n                    thirdElemInd--;\n                    secondElemInd++;\n                } else if(sum > 0){\n                    thirdElemInd--;\n                } else {\n                    secondElemInd++;\n                }\n            }\n        }\n        return res;\n    }\n}",
        "tags": "0, 4",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 130,
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array <i>S</i> of <i>n</i> integers, find three integers in <i>S</i> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n\n    <pre>    For example, given array S = {-1 2 1 -4}, and target = 1.\n\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        int n = nums.length;\n        int ans = 0;\n        int sum = 0;\n\n        Arrays.sort(nums);\n        if(nums.length <= 3){\n            for(int i = 0; i < n; i++){\n                sum += nums[i];\n            }\n            return sum;\n        }\n\n        ans = nums[0] + nums[1] + nums[2];\n        for (int i = 0; i < n - 2; i++){\n            int j = i + 1;\n            int k = n - 1;\n            while(j < k){\n                sum = nums[i] + nums[j] + nums[k];\n                if(sum == target){\n                    return sum;\n                }\n                if(Math.abs(target - ans) > Math.abs(target - sum)){\n                    ans = sum;\n                }\n                if(sum > target){\n                    k--;\n                } else{\n                    j++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "tags": "0, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 131,
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": "Medium",
        "description": "<div class=\"row tab-content\" id=\"descriptionContent\">\n    <div class=\"col-md-12\">\n        <div class=\"question-info text-primary\">\n            <ul>\n                <li>Total Accepted: <strong>148194</strong></li>\n                <div class=\"newline-control-xs hide\"></div>\n                <li>Total Submissions: <strong>437141</strong></li>\n                <div class=\"newline-control-xs hide\"></div>\n                <li>Difficulty: <strong>Medium</strong></li>\n                <div class=\"newline-control-sm hide\"></div>\n\n                <li>\n                    Contributor:\n                    <strong>\n                        LeetCode\n                    </strong>\n                </li>\n\n            </ul>\n            <div class=\"sm-line hide\"></div>\n        </div>\n        <div class=\"question-content\">\n            <p></p><p>Given a digit string, return all possible letter combinations that the number could represent.\n        </p>\n\n            <p>\n                A mapping of digit to letters (just like on the telephone buttons) is given below.</p>\n            <p><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png\"></p>\n\n            <pre><b>Input:</b>Digit string \"23\"\n<b>Output:</b> [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n</pre>\n\n\n        </div>\n    </div>\n\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Time Complexity ~ O(3^n), Space Compelxity - O(n);\n     *\n     * backtracking，same as permutation\n     * backtracking for the letters for each number\n     *\n     */\n    public List<String> letterCombinations(String digits) {\n        List<String> re = new ArrayList<>();\n        if(digits.length() == 0){\n            return re;\n        }\n        char[][] pad = {\n                {'0'},\n                {'1'},\n                {'a','b','c'},\n                {'d','e','f'},\n                {'g','h','i'},\n                {'j','k','l'},\n                {'m','n','o'},\n                {'p','q','r','s'},\n                {'t','u','v'},\n                {'w','x','y','z'},\n        };\n\n        getletters(digits, pad, re, \"\", 0);\n        return re;\n    }\n\n    private void getletters(String digits, char[][] pad,\n                            List<String> re, String str, int start){\n        if(str.length() == digits.length()){\n            re.add(str);\n            return;\n        }\n\n        int temp = digits.charAt(start)-'0';\n        for(int j = 0; j < pad[temp].length; j++){\n            getletters(digits, pad, re, str + pad[temp][j], start+1);\n        }\n    }\n}",
        "tags": "5, 8",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 132,
        "number": 18,
        "title": "4Sum",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = target? Find all unique quadruplets in the array which gives the sum of target.</p>\n\n    <p><b>Note:</b> The solution set must not contain duplicate quadruplets.\n    </p>\n\n    <pre>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\n        if (nums.length < 4) {\n            return result;\n        }\n\n        Arrays.sort(nums);\n        Map<Integer, List<Integer>> toMatch = new HashMap<Integer, List<Integer>>();\n        for (int i = 0; i < nums.length - 1; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                int toMatchInt = target - nums[i] - nums[j];\n                List<Integer> tmpList = new LinkedList<Integer>();\n                if (toMatch.containsKey(toMatchInt)) {\n                    tmpList = toMatch.get(toMatchInt);\n                }\n\n                tmpList.add(i);\n                tmpList.add(j);\n                toMatch.put(toMatchInt, tmpList);\n            }\n        }\n\n        int firstValue = Integer.MAX_VALUE;\n        for (int firstIndex = 0; firstIndex < nums.length - 3; firstIndex++) {\n            if (nums[firstIndex] == firstValue) {\n                continue; // Skip first duplicate\n            }\n            firstValue = nums[firstIndex];\n            int secondIndex = firstIndex + 1;\n            while (secondIndex < nums.length - 2) {\n                int secondValue = nums[secondIndex];\n                int tempSum = nums[firstIndex] + nums[secondIndex];\n                if (toMatch.containsKey(tempSum)) {\n                    List<Integer> matchList = toMatch.get(tempSum);\n                    int count = Integer.MAX_VALUE;\n                    for (int i = 0; i < matchList.size() - 1; i += 2) {\n                        // If 3rd element Ind not greater then 2nd ind\n                        // or duplicate pair found\n                        if (matchList.get(i) <= secondIndex ||\n                                (i > count && nums[matchList.get(i - 2)] == nums[matchList.get(i)]\n                                        && nums[matchList.get(i - 1)] == nums[matchList.get(i + 1)])) {\n                            continue;\n                        }\n                        List<Integer> tmpList = new LinkedList<Integer>();\n                        tmpList.add(nums[firstIndex]);\n                        tmpList.add(nums[secondIndex]);\n                        tmpList.add(nums[matchList.get(i)]);\n                        tmpList.add(nums[matchList.get(i + 1)]);\n                        result.add(tmpList);\n                        count = i;\n                    }\n                }\n                while (++secondIndex < nums.length - 2 && nums[secondIndex] == secondValue) ;\n            }\n        }\n        return result;\n    }\n}",
        "tags": "0, 1, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 133,
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a linked list, remove the <i>n</i><sup>th</sup> node from the end of list and return its head.</p>\n\n    <p>\n        For example,</p>\n\n    <pre>   Given linked list: <b>1-&gt;2-&gt;3-&gt;4-&gt;5</b>, and <b><i>n</i> = 2</b>.\n\n   After removing the second node from the end, the linked list becomes <b>1-&gt;2-&gt;3-&gt;5</b>.\n</pre>\n\n    <p>\n        <b>Note:</b><br>\n        Given <i>n</i> will always be valid.<br>\n        Try to do this in one pass.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode p = new ListNode(-1);\n        p.next = head;\n\n        ListNode q = head;\n        head = p;\n\n        for (int i = 0; i < n; i++)\n            q = q.next;\n\n        while (q != null) {\n            q = q.next;\n            p = p.next;\n        }\n        p.next = p.next.next;\n        return head.next;\n    }\n}",
        "tags": "2, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 134,
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given <i>n</i> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n</p>\n\n    <p>\n        For example, given <i>n</i> = 3, a solution set is:\n    </p>\n    <pre>[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> re = new ArrayList<String>();\n        if(n == 0) return re;\n\n        String str = \"\";\n        getParenthesis(n, n, str, re);\n        return re;\n    }\n\n    private void getParenthesis(int left, int right, String str, List<String>re){\n        if(left == 0 && right == 0){\n            re.add(str);\n            return;\n        }\n\n        if(left>0){\n            getParenthesis(left-1,right,str+\"(\",re);\n        }\n\n        if(right>left){\n            getParenthesis(left,right-1,str+\")\",re);\n        }\n    }\n}",
        "tags": "5, 8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 135,
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a linked list, swap every two adjacent nodes and return its head.\n</p>\n\n    <p>\n        For example,<br>\n        Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.\n    </p>\n\n    <p>\n        Your algorithm should use only constant space. You may <b>not</b> modify the values in the list, only nodes itself can be changed.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode current = dummy;\n        while (current.next != null && current.next.next != null) {\n            ListNode first = current.next;\n            ListNode second = current.next.next;\n            first.next = second.next;\n            second.next = first;\n            current.next = second;\n            current = current.next.next;\n        }\n        return dummy.next;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 136,
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Divide two integers without using multiplication, division and mod operator.\n</p>\n    <p>\n        If it is overflow, return MAX_INT.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    // The time complexity is O(logn).\n    // This problem can be solved based on the fact that any number\n    // can be converted to the format of the following:\n    // num=a_0*2^0+a_1*2^1+a_2*2^2+...+a_n*2^n\n    public int divide(int dividend, int divisor) {\n        if(divisor==-1 && dividend == Integer.MIN_VALUE)\n            return Integer.MAX_VALUE;\n        int sign = 1;\n        if (dividend < 0) {\n            sign *= -1;\n        }\n        if (divisor < 0) {\n            sign *= -1;\n        }\n        long a = dividend;\n        long b = divisor;\n        // must cast to long here for dealing with the Integer.MIN_VALUE\n        // because Math.abs(-2147483648) > Integer.MAX_VALUE\n        a = Math.abs(a);\n        b = Math.abs(b);\n        int count = 0;\n        while (a >= b) {\n            long temp = b;\n            int multi = 1;\n            while (a >= temp) {\n                count += multi;\n                a -= temp;\n                temp += temp;\n                multi += multi;\n            }\n        }\n        return count * sign;\n    }\n}",
        "tags": "3, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 137,
        "number": 31,
        "title": "Next Permutation",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n</p>\n    <p>\n        If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n    </p>\n    <p>\n        The replacement must be in-place, do not allocate extra memory.\n    </p>\n    <p>\n        Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>\n        <code>1,2,3</code> -> <code>1,3,2</code><br>\n        <code>3,2,1</code> -> <code>1,2,3</code><br>\n        <code>1,1,5</code> -> <code>1,5,1</code><br>\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public void nextPermutation(int[] nums) {\n        if (nums.length <= 1) {\n            return;\n        }\n\n        int indexdisorder = nums.length - 1;\n        while (indexdisorder > 0 && nums[indexdisorder] <= nums[indexdisorder - 1]) {\n            indexdisorder--;\n        }\n        if (indexdisorder == 0) {\n            reverse(nums, 0, nums.length - 1);\n            return;\n        }\n        indexdisorder--;\n\n        int firstlarger = nums.length - 1;\n        while (firstlarger > 0 && nums[firstlarger] <= nums[indexdisorder]) {\n            firstlarger--;\n        }\n\n        swap(nums, indexdisorder, firstlarger);\n        reverse(nums, indexdisorder + 1, nums.length - 1);\n    }\n\n    private void reverse(int[] nums, int first, int last) {\n        while (first < last) {\n            swap(nums, first, last);\n            first++;\n            last--;\n        }\n    }\n\n    private void swap(int[] nums, int first, int last) {\n        nums[first] = nums[first] + nums[last];\n        nums[last] = nums[first] - nums[last];\n        nums[first] = nums[first] - nums[last];\n    }\n}",
        "tags": "0",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 138,
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n    <p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n    <p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>\n\n    <p>You may assume no duplicate exists in the array.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int search(int[] A, int target) {\n        int l = 0, r = A.length - 1;\n        while (l <= r) {\n            int m = l + (r - l) / 2;\n            if (A[m] == target)\n                return m;\n            if (A[l] <= A[m]) {\n                if (target >= A[l] && target <= A[m])\n                    r = m;\n                else\n                    l = m + 1;\n            } else {\n                if (target <= A[r] && target >= A[m])\n                    l = m;\n                else\n                    r = m - 1;\n            }\n        }\n        return -1;\n    }\n}",
        "tags": "0, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 139,
        "number": 34,
        "title": "Search for a Range",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>\n\n    <p>Your algorithm's runtime complexity must be in the order of <i>O</i>(log <i>n</i>).</p>\n\n    <p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>\n\n    <p>\n        For example,<br>\n        Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>\n        return <code>[3, 4]</code>.\n    </p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] res = new int[]{-1, -1};\n        if(nums == null || nums.length == 0)\n            return res;\n        res[0] = searchLeft(nums, target);\n        if(res[0] != -1)\n            res[1] = searchRight(nums, target);\n        return res;\n    }\n\n    private int searchLeft(int[] nums, int target){\n        int left = 0;\n        int right = nums.length - 1;\n        int mid = left + (right - left)/2;\n        while(left < right - 1){\n            if(nums[mid] < target)\n                left = mid + 1;\n            else {\n                right = nums[mid] > target ? mid - 1 : mid;\n            }\n            mid = left + (right - left)/2;\n        }\n        // Check left first\n        return nums[left] == target ? left :\n                nums[right] == target ? right : -1;\n    }\n\n    private int searchRight(int[] nums, int target){\n        int left = 0;\n        int right = nums.length - 1;\n        int mid = left + (right - left)/2;\n        while(left < right - 1){\n            if(nums[mid] > target)\n                right = mid - 1;\n            else {\n                left = nums[mid] < target ? mid + 1 : mid;\n            }\n            mid = left + (right - left)/2;\n        }\n        // Check right first\n        return nums[right] == target ? right :\n                nums[left] == target ? left : -1;\n    }\n}",
        "tags": "0, 6",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 140,
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Determine if a Sudoku is valid, according to: <a href=\"http://sudoku.com.au/TheRules.aspx\">Sudoku Puzzles - The Rules</a>.</p>\n\n    <p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.</p>\n\n    <p>\n        <img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\"><br>\n    </p><p style=\"font-size: 11px\">A partially filled sudoku which is valid.</p>\n    <p></p>\n\n    <p><b>Note:</b><br>\n        A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean isValidSudoku(char[][] board) {\n\n        HashMap<Character, ArrayList<Integer>> numHashset = new HashMap<Character, ArrayList<Integer>>();\n        ArrayList<Integer> coords = new ArrayList<Integer>();\n\n        for (int row = 0; row < board.length; row++) {\n            for (int col = 0; col < board[0].length; col++) {\n                if (board[row][col] == '.')\n                    continue;\n                coords = new ArrayList<Integer>();\n                if (numHashset.containsKey(board[row][col])) {\n                    coords = numHashset.get(board[row][col]);\n                    if (!isValid(coords, row, col)) {\n                        return false;\n                    }\n                }\n                coords.add(row);\n                coords.add(col);\n                numHashset.put(board[row][col], coords);\n            }\n        }\n        return true;\n    }\n\n    private boolean isValid(ArrayList<Integer> coords, int row, int col) {\n        for (int i = 0; i < coords.size(); i += 2) {\n            if (coords.get(i) == row || coords.get(i + 1) == col)\n                return false;\n\n            int dx = coords.get(i) / 3;\n            int dy = coords.get(i + 1) / 3;\n            for (int j = dx * 3; j < dx * 3 + 3; j++) {\n                for (int k = dy * 3; k < dy * 3 + 3; k++)\n                    if (j == row && k == col)\n                        return false;\n            }\n        }\n\n        return true;\n    }\n}",
        "tags": "1, 8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 141,
        "number": 39,
        "title": "Combination Sum",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a <b>set</b> of candidate numbers (<b><i>C</i></b>) <b>(without duplicates)</b> and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>.\n</p>\n\n    <p>The <b>same</b> repeated number may be chosen from <b><i>C</i></b> unlimited number of times.\n    </p>\n\n    <p><b>Note:</b><br>\n    </p><ul>\n    <li>All numbers (including target) will be positive integers.</li>\n    <li>The solution set must not contain duplicate combinations.</li>\n</ul>\n    <p></p>\n\n    <p>\n        For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>, <br>\n        A solution set is: <br>\n    </p><pre>[\n  [7],\n  [2, 2, 3]\n]\n</pre>\n\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Time Complexity: C(n,1) + C(n,2) + ..C(n, n) = O(2^n)\n     * where n is the size of candidates,\n     * and k is the max repeated times for each candidates.\n     * Space complexity: O(m) where m is the size of array for the solution\n     *\n     * @param candidates\n     * @param target\n     * @return\n     */\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> re = new ArrayList<>();\n        List<Integer> li = new ArrayList<>();\n        getList(candidates, target, li, re, 0);\n        return re;\n    }\n\n    private void getList(int[] candidates, int target, List<Integer> li,\n                         List<List<Integer>> re, int start) {\n        if(target==0){\n            List<Integer> templi = new ArrayList<>(li);\n            if(!re.contains(templi)){\n                re.add(templi);\n            }\n            return;\n        }\n\n        for(int i=start; i<candidates.length; i++){\n            if(target-candidates[i]>=0){\n                li.add(candidates[i]);\n                getList(candidates, target-candidates[i], li, re, i);\n                li.remove(li.size()-1);\n            }\n        }\n    }\n}",
        "tags": "0, 8",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 142,
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a collection of candidate numbers (<b><i>C</i></b>) and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>.\n</p>\n\n    <p>Each number in <b><i>C</i></b> may only be used <b>once</b> in the combination.\n    </p>\n    <p><b>Note:</b><br>\n    </p><ul>\n    <li>All numbers (including target) will be positive integers.</li>\n    <li>The solution set must not contain duplicate combinations.</li>\n</ul>\n    <p></p>\n\n    <p>\n        For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>, <br>\n        A solution set is: <br>\n    </p><pre>[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n</pre>\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Time Complexity: C(n,1) + C(n,2) + ..C(n, n) = O(2^n)\n     * where n is the size of candidates,\n     * and k is the max repeated times for each candidates.\n     * Space complexity: O(m) where m is the size of array for the solution\n     *\n     * @param candidates\n     * @param target\n     * @return\n     */\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> re = new ArrayList<>();\n        List<Integer> li = new ArrayList<>();\n        getList(candidates, target, li, re, 0);\n        return re;\n    }\n\n    private void getList(int[] candidates, int target, List<Integer> li,\n                         List<List<Integer>> re, int start) {\n        if(target==0){\n            List<Integer> templi = new ArrayList<>(li);\n            if(!re.contains(templi)){\n                re.add(templi);\n            }\n            return;\n        }\n\n        for(int i=start; i<candidates.length; i++){\n            if(target-candidates[i]>=0){\n                li.add(candidates[i]);\n                // Use i+1 instead of i compared with combination sum\n                getList(candidates, target-candidates[i], li, re, i+1);\n                li.remove(li.size()-1);\n            }\n        }\n    }\n}",
        "tags": "0, 8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 143,
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>.</p>\n\n    <p><b>Note:</b>\n    </p><ol>\n    <li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>\n    <li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>\n    <li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>\n    <li>You <b>must not use any built-in BigInteger library</b> or <b>convert the inputs to integer</b> directly.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String multiply(String num1, String num2) {\n        int[] num = new int[num1.length() + num2.length()];\n        for (int i = 0; i < num1.length(); i++) {\n            int carry = 0;\n            int a = num1.charAt(num1.length() - 1 - i) - '0';\n            for (int j = 0; j < num2.length(); j++) {\n                int b = num2.charAt(num2.length() - 1 - j) - '0';\n                num[i + j] += carry + a * b;\n                carry = num[i + j] / 10;\n                num[i + j] %= 10;\n            }\n            num[i + num2.length()] += carry;\n        }\n        int i = num.length - 1;\n        while (i > 0 && num[i] == 0){\n            i--;\n        }\n\n        StringBuilder temp = new StringBuilder(\"\");\n        while (i >= 0)\n            temp.append((char) ('0' + num[i--]));\n\n        return temp.toString();\n    }\n}",
        "tags": "3, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 144,
        "number": 46,
        "title": "Permutations",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a collection of <b>distinct</b> numbers, return all possible permutations.\n</p>\n\n    <p>\n        For example,<br>\n        <code>[1,2,3]</code> have the following permutations:<br>\n    </p><pre>[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> permute(int[] num) {\n\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> curPer = new ArrayList<Integer>();\n\n        int len = num.length;\n        int[] used = new int[len];\n\n        getPermutations(num, used, len, curPer, res);\n\n        return res;\n\n    }\n\n    private void getPermutations(int[] num, int[] used, int len,\n                                 List<Integer> curPer, List<List<Integer>> res) {\n\n        if(curPer.size() == len){\n            ArrayList<Integer> temp = new ArrayList<Integer>(curPer);\n            res.add(temp);\n            return;\n        }\n\n        for(int i=0; i<len; i++){\n            if(used[i] != 1){\n                used[i] = 1;\n                curPer.add(num[i]);\n                getPermutations(num, used, len, curPer, res);\n                used[i] = 0;\n                curPer.remove(curPer.size()-1);\n            }\n        }\n    }\n}",
        "tags": "8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 145,
        "number": 47,
        "title": "Permutations II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a collection of numbers that might contain duplicates, return all possible unique permutations.\n</p>\n\n    <p>\n        For example,<br>\n        <code>[1,1,2]</code> have the following unique permutations:<br>\n    </p><pre>[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<Integer> cal = new ArrayList<Integer>();\n        List<List<Integer>> re = new ArrayList<List<Integer>>();\n\n        Arrays.sort(nums);\n        int[] used = new int[nums.length];\n        getpermute(nums, used, cal, re);\n        return re;\n    }\n\n    void getpermute(int[] nums, int[] used, List<Integer> cal, List<List<Integer>> re){\n        if(cal.size() == nums.length){\n            List<Integer> temp = new ArrayList<Integer>(cal);\n            re.add(temp);\n            return;\n        }\n\n        for(int i = 0; i < nums.length; i++){\n            if(i > 0 && nums[i-1] == nums[i]) continue;\n            if(used[i] == 1){\n                continue;\n            }\n            cal.add(nums[i]);\n            used[i] = 1;\n            getpermute(nums, used, cal, re);\n            used[i] = 0;\n            cal.remove(cal.size()-1);\n            while(i < nums.length-1 && nums[i] == nums[i+1]){\n                i++;\n            }\n        }\n    }\n}",
        "tags": "8",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 146,
        "number": 48,
        "title": "Rotate Image",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>You are given an <i>n</i> x <i>n</i> 2D matrix representing an image.</p>\n    <p>Rotate the image by 90 degrees (clockwise).</p>\n    <p>Follow up:<br>\n        Could you do this in-place?</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public void rotate(int[][] matrix) {\n        int msize = matrix.length;\n        if(msize==1) return;\n        int i=0;\n        int j=msize-1;\n\n        while(i<j){\n            rotateOutside(matrix, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    public void rotateOutside(int[][] matrix, int i, int j){\n        for(int k=0; k<j-i; k++){\n            swap(matrix, i, i+k, j-k, i);\n            swap(matrix, j-k, i, j, j-k);\n            swap(matrix, j, j-k, i+k, j);\n        }\n    }\n\n    public void swap(int[][] matrix, int i, int j, int k, int l){\n        int temp = matrix[i][j];\n        matrix[i][j] = matrix[k][l];\n        matrix[k][l] = temp;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 147,
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array of strings, group anagrams together.\n</p>\n\n    <p>For example, given: <code>[\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]</code>, <br>\n        Return:\n    </p><pre>[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]</pre><p></p>\n\n    <p><b>Note:</b> All inputs will be in lower-case.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> rst = new ArrayList<List<String>>();\n        HashMap<String, List<String>> map = new HashMap<String, List<String>>();\n        Arrays.sort(strs);\n\n        for(int i = 0; i < strs.length; i++) {\n            char[] strChar = strs[i].toCharArray();\n            Arrays.sort(strChar);\n            String str = new String(strChar);\n            if(map.containsKey(str)) {\n                map.get(str).add(strs[i]);\n            }\n            else {\n                List<String> list = new ArrayList<String>();\n                list.add(strs[i]);\n                map.put(str, list);\n            }\n        }\n\n        for(List<String> val : map.values()) {\n            rst.add(val);\n        }\n\n        return rst;\n    }\n}",
        "tags": "1, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 148,
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": "Medium",
        "description": "Implement pow(x, n).",
        "solution": "public class Solution {\n    public double myPow(double x, int n) {\n        if(n==0) return 1;\n        if(n==1) return x;\n        if(n==-1) return 1/x;\n        if(n==2) return x*x;\n\n        double temp = myPow(x, n / 2);\n        if (n % 2 == 0)\n            return temp*temp;\n        else {\n            if (n > 0)\n                return x * temp*temp;\n            else\n                return 1 / x * temp*temp;\n        }\n    }\n}",
        "tags": "3, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 149,
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a matrix of <i>m</i> x <i>n</i> elements (<i>m</i> rows, <i>n</i> columns), return all elements of the matrix in spiral order.\n</p>\n\n    <p>\n        For example,<br>\n        Given the following matrix:\n    </p>\n    <pre>[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n</pre>\n    <p>\n        You should return <code>[1,2,3,6,9,8,7,4,5]</code>.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (matrix.length == 0) {\n            return res;\n        }\n\n        int rowBegin = 0;\n        int rowEnd = matrix.length - 1;\n        int colBegin = 0;\n        int colEnd = matrix[0].length - 1;\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\n            // Traverse Right\n            for (int j = colBegin; j <= colEnd; j++) {\n                res.add(matrix[rowBegin][j]);\n            }\n            rowBegin++;\n            // Traverse Down\n            for (int j = rowBegin; j <= rowEnd; j++) {\n                res.add(matrix[j][colEnd]);\n            }\n            colEnd--;\n            // Traverse Left\n            if (rowBegin <= rowEnd) {\n                for (int j = colEnd; j >= colBegin; j--) {\n                    res.add(matrix[rowEnd][j]);\n                }\n            }\n            rowEnd--;\n            // Traver Up\n            if (colBegin <= colEnd) {\n                for (int j = rowEnd; j >= rowBegin; j--) {\n                    res.add(matrix[j][colBegin]);\n                }\n            }\n            colBegin++;\n        }\n        return res;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 150,
        "number": 55,
        "title": "Jump Game",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array of non-negative integers, you are initially positioned at the first index of the array.\n</p>\n    <p>\n        Each element in the array represents your maximum jump length at that position.\n    </p>\n    <p>\n        Determine if you are able to reach the last index.\n    </p>\n\n    <p>\n        For example:<br>\n        A = <code>[2,3,1,1,4]</code>, return <code>true</code>.\n    </p>\n    <p>\n        A = <code>[3,2,1,0,4]</code>, return <code>false</code>.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean canJump(int[] nums) {\n        int reach = 1;\n        for (int i = 0; i < reach && reach < nums.length; ++i)\n            reach = Math.max(reach, nums[i] + i + 1);\n        return reach >= nums.length;\n    }\n}",
        "tags": "0, 17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 151,
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a collection of intervals, merge all overlapping intervals.</p>\n\n    <p>\n        For example,<br>\n        Given <code>[1,3],[2,6],[8,10],[15,18]</code>,<br>\n        return <code>[1,6],[8,10],[15,18]</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        List<Interval> result = new ArrayList<Interval>();\n        if (intervals.size() == 0)\n            return result;\n        Collections.sort(intervals, new Comparator<Interval>() {\n            public int compare(Interval o1, Interval o2) {\n                return o1.start - o2.start;\n            }\n        });\n        Interval travel = intervals.get(0);\n        if (intervals.size() == 1) {\n            result.add(travel);\n            return result;\n        }\n\n        for (int i = 1; i < intervals.size(); i++) {\n            Interval temp = intervals.get(i);\n            if (temp.end < travel.start || temp.start > travel.end) {\n                result.add(travel);\n                travel = temp;\n            } else {\n                travel.start = Math.min(travel.start, temp.start);\n                travel.end = Math.max(travel.end, temp.end);\n            }\n        }\n        result.add(travel);\n        return result;\n    }\n}",
        "tags": "0, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 152,
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer <i>n</i>, generate a square matrix filled with elements from 1 to <i>n</i><sup>2</sup> in spiral order.</p>\n\n    <p>\n        For example,<br>\n        Given <i>n</i> = <code>3</code>,\n    </p>\n    You should return the following matrix:\n    <pre>[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] matrix = new int[n][n];\n\n        if (n == 1) {\n            matrix[0][0] = 1;\n            return matrix;\n        }\n\n        int i = 0;\n        int j = n - 1;\n        int m = 1;\n\n        while (j >= i) {\n            m = spiral(m, i, j, matrix);\n            i++;\n            j--;\n        }\n        return matrix;\n    }\n\n    public int spiral(int m, int i, int j, int[][] matrix) {\n        if (i == j) {\n            matrix[i][i] = m;\n            m++;\n            return m;\n        }\n\n        for (int p = i; p < j; p++) {\n            matrix[i][p] = m;\n            m++;\n        }\n\n        for (int p = i; p < j; p++) {\n            matrix[p][j] = m;\n            m++;\n        }\n\n        for (int p = j; p > i; p--) {\n            matrix[j][p] = m;\n            m++;\n        }\n\n        for (int p = j; p > i; p--) {\n            matrix[p][i] = m;\n            m++;\n        }\n\n        return m;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 153,
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>The set <code>[1,2,3,...,<i>n</i>]</code> contains a total of <i>n</i>! unique permutations.</p>\n\n    <p>By listing and labeling all of the permutations in order,<br>\n        We get the following sequence (ie, for <i>n</i> = 3):\n    </p><ol>\n    <li><code>\"123\"</code></li>\n    <li><code>\"132\"</code></li>\n    <li><code>\"213\"</code></li>\n    <li><code>\"231\"</code></li>\n    <li><code>\"312\"</code></li>\n    <li><code>\"321\"</code></li>\n</ol>\n    <p></p>\n\n    <p>Given <i>n</i> and <i>k</i>, return the <i>k</i><sup>th</sup> permutation sequence.</p>\n\n    <p><b>Note:</b> Given <i>n</i> will be between 1 and 9 inclusive.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String getPermutation(int n, int k) {\n        int t = 1; // n! to each i\n        List<Integer> numbers = new ArrayList<>(n);\n        for (int i = 1; i <= n; i++) {\n            t = t * i;\n            numbers.add(i);\n        }\n        t /= n; // (n - 1)!\n        k--;\n        StringBuilder sb = new StringBuilder();\n        for (int i = n - 1; i >= 1; i--) {\n            int p = k / t; // find which number to use\n            int np = numbers.get(p); // get the number to use\n            sb.append(String.valueOf(np));\n            numbers.remove(p); // remove used number\n            k %= t; // what left for k\n            t /= i; //(n - i)!\n        }\n        // append the last number\n        sb.append(String.valueOf(numbers.get(0)));\n        return sb.toString();\n    }\n}",
        "tags": "3, 8",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 154,
        "number": 61,
        "title": "Rotate List",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a list, rotate the list to the right by <i>k</i> places, where <i>k</i> is non-negative.</p>\n\n    <p>For example:<br>\n        Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <i>k</i> = <code>2</code>,<br>\n        return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public ListNode rotateRight(ListNode head, int n) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy, slow = dummy;\n\n        int len = 0;\n        //Get the total length\n        while (fast.next != null){\n            len++;\n            fast = fast.next;\n        }\n        //Get the i-n%i th node\n        for (int j = len - n % len; j > 0; j--)\n            slow = slow.next;\n        //Do the rotation\n        fast.next = dummy.next;\n        dummy.next = slow.next;\n        slow.next = null;\n\n        return dummy.next;\n    }\n}",
        "tags": "2, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 155,
        "number": 62,
        "title": "Unique Paths",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>A robot is located at the top-left corner of a <i>m</i> x <i>n</i> grid (marked 'Start' in the diagram below).</p>\n\n    <p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p>\n\n    <p>How many possible unique paths are there?</p>\n\n    <p>\n        <img src=\"https://leetcode.com/static/images/problemset/robot_maze.png\"><br>\n    </p><p style=\"font-size: 11px\">Above is a 3 x 7 grid. How many possible unique paths are there?\n</p>\n\n    <p><b>Note:</b> <i>m</i> and <i>n</i> will be at most 100.</p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public int uniquePaths(int m, int n) {\n        if(m <= 1 || n <= 1) return 1;\n        int[][] dpTable = new int[m][n];\n\n        // Only one way for first column or row\n        for(int i = 0; i < n; i++){\n            dpTable[0][i] = 1;\n        }\n        for(int i = 0; i < m; i++){\n            dpTable[i][0] = 1;\n        }\n        for(int row = 1; row < m; row++){\n            for(int col = 1; col < n; col++){\n                // Ways to get current grid =\n                // ways to get top of left grid\n                dpTable[row][col] = dpTable[row-1][col] + dpTable[row][col-1];\n            }\n        }\n        return dpTable[m-1][n-1];\n    }\n}",
        "tags": "0, 9",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 156,
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Follow up for \"Unique Paths\":</p>\n\n    <p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>\n\n    <p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>\n\n    <p>For example,<br>\n    </p><p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>\n    <pre>[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n</pre>\n    <p>The total number of unique paths is <code>2</code>.</p>\n\n    <p><b>Note:</b> <i>m</i> and <i>n</i> will be at most 100.</p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if(obstacleGrid == null || obstacleGrid.length == 0 ||\n                obstacleGrid[0].length == 0) return 0;\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n        // If top left or bottom right element is 1\n        if(obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return 0;\n\n        int[][] dpTable = new int[m][n];\n        dpTable[0][0] = 1;\n        // First row\n        for(int i = 1; i < n; i++){\n            dpTable[0][i] = (obstacleGrid[0][i] == 1 ||\n                    dpTable[0][i - 1] == 0) ? 0 : 1;\n        }\n        // First col\n        for(int i = 1; i < m; i++){\n            dpTable[i][0] = (obstacleGrid[i][0] == 1 ||\n                    dpTable[i - 1][0] == 0) ? 0 : 1;\n        }\n        for(int row = 1; row < m; row++){\n            for(int col = 1; col < n; col++){\n                // If has obstacle\n                if(obstacleGrid[row][col] == 1){\n                    dpTable[row][col] = 0;\n                } else {\n                    // update ways to current grid to be sum of\n                    // ways to get top or left grid\n                    dpTable[row][col] = dpTable[row-1][col] + dpTable[row][col-1];\n                }\n            }\n        }\n        return dpTable[m - 1][n - 1];\n    }\n}",
        "tags": "0, 9",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 157,
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <i>m</i> x <i>n</i> grid filled with non-negative numbers, find a path from top left to bottom right which <i>minimizes</i> the sum of all numbers along its path.</p>\n\n    <p><b>Note:</b> You can only move either down or right at any point in time.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int minPathSum(int[][] grid) {\n        int rows = grid.length;\n        if(rows == 0)\n            return 0;\n        int cols = grid[0].length;\n\n        int sum = 0;\n        int[][] path = new int[rows][cols];\n        path[0][0] = grid[0][0];\n\n        for(int i = 0; i < rows; i++){\n            for(int j = 0; j < cols; j++){\n                if(i == 0 && j == 0) continue;\n                if(i == 0 && j > 0){\n                    path[i][j] = path[i][j - 1] + grid[i][j];\n                } else if (j == 0 && i > 0){\n                    path[i][j] = path[i - 1][j] + grid[i][j];\n                } else {\n                    path[i][j] = Math.min(path[i][j - 1], path[i - 1][j]) + grid[i][j];\n                }\n            }\n        }\n        return path[rows-1][cols-1];\n    }\n}",
        "tags": "0, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 158,
        "number": 71,
        "title": "Simplify Path",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an absolute path for a file (Unix-style), simplify it.</p>\n\n    <p>For example,<br>\n        <b>path</b> = <code>\"/home/\"</code>, =&gt; <code>\"/home\"</code><br>\n        <b>path</b> = <code>\"/a/./b/../../c/\"</code>, =&gt; <code>\"/c\"</code><br>\n    </p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show corner cases.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Corner Cases:</b>\n\n        <p>\n        </p><ul>\n            <li>Did you consider the case where <b>path</b> = <code>\"/../\"</code>?<br>\n                In this case, you should return <code>\"/\"</code>.</li>\n            <li>Another corner case is the path might contain multiple slashes <code>'/'</code> together, such as <code>\"/home//foo/\"</code>.<br>\n                In this case, you should ignore redundant slashes and return <code>\"/home/foo\"</code>.</li>\n            <p></p>\n        </ul></div><p></p>\n</div>",
        "solution": "public class Solution {\n    public String simplifyPath(String path) {\n        String[] sts = path.split(\"/\");\n        Deque<String> pathDeque = new ArrayDeque<String>();\n        for (String st : sts) {\n            st = st.trim();\n            if (st.length() == 0 || st.equals(\".\")){\n                continue;\n            } else if (st.equals(\"..\")){\n                if (pathDeque.isEmpty())\n                    continue;\n                else\n                    pathDeque.removeLast();\n            } else {\n                pathDeque.addLast(st);\n            }\n        }\n        StringBuilder result = new StringBuilder(\"/\");\n        if (pathDeque.isEmpty()) return result.toString();\n        while (!pathDeque.isEmpty()){\n            result.append(pathDeque.removeFirst() + \"/\");\n        }\n        return result.substring(0, result.length()-1);\n    }\n}",
        "tags": "5, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 159,
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a <i>m</i> x <i>n</i> matrix, if an element is 0, set its entire row and column to 0. Do it in place.\n</p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show follow up.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Follow up:</b>\n\n        <p>\n            Did you use extra space?<br>\n            A straight forward solution using O(<i>m</i><i>n</i>) space is probably a bad idea.<br>\n            A simple improvement uses O(<i>m</i> + <i>n</i>) space, but still not the best solution.<br>\n            Could you devise a constant space solution?\n        </p>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n    public void setZeroes(int[][] matrix) {\n        int zero_frow = 0;\n        int zero_fcol = 0;\n\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        for (int i = 0; i < cols; i++) {\n            if (matrix[0][i] == 0) {\n                zero_frow = 1;\n                break;\n            }\n        }\n\n        for (int i = 0; i < rows; i++) {\n            if (matrix[i][0] == 0) {\n                zero_fcol = 1;\n                break;\n            }\n        }\n\n        for (int i = 1; i < rows; i++) {\n            for (int j = 1; j < cols; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for (int j = 1; j < cols; j++) {\n            if (matrix[0][j] == 0) {\n                for (int i = 1; i < rows; i++)\n                    matrix[i][j] = 0;\n            }\n        }\n\n        for (int i = 1; i < rows; i++) {\n            if (matrix[i][0] == 0) {\n                for (int j = 1; j < cols; j++)\n                    matrix[i][j] = 0;\n            }\n        }\n\n        if (zero_frow == 1) {\n            for (int i = 0; i < cols; i++)\n                matrix[0][i] = 0;\n        }\n\n        if (zero_fcol == 1) {\n            for (int i = 0; i < rows; i++)\n                matrix[i][0] = 0;\n        }\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 160,
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write an efficient algorithm that searches for a value in an <i>m</i> x <i>n</i> matrix. This matrix has the following properties:</p>\n\n    <p>\n    </p><ul>\n    <li>Integers in each row are sorted from left to right.</li>\n    <li>The first integer of each row is greater than the last integer of the previous row.</li>\n</ul>\n    <p></p>\n\n    <p>\n        For example,</p>\n    <p>\n        Consider the following matrix:\n    </p>\n    <pre>[\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\n</pre>\n\n    <p>Given <b>target</b> = <code>3</code>, return <code>true</code>.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    // rowMid = (rowLeft + rowRight)/2, columnMid = (columnUp + columnDown)/2\n    // 1, First use columnMid index to search line number.\n    // 2, Second use rowMid to search for the element.\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // Special cases\n        if (matrix == null || matrix.length == 0  || matrix[0].length == 0) {\n            return false;\n        }\n        int rowNum = matrix.length - 1;\n        int colNum = matrix[0].length - 1;\n        if (target < matrix[0][0] || target > matrix[rowNum][colNum]) {\n            return false;\n        }\n\n        //1. Binary search for column first\n        int start = 0;\n        int end = rowNum;\n        int mid = (end - start) / 2 + start;\n        while (start < end){\n            if (target == matrix[mid][0]) { return true; }\n            if (target < matrix[mid][0]){\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n            mid = (end - start) / 2 + start;\n        }\n        int rowToSearch = target < matrix[start][0] ? start-1: start;\n        //2. Binary search in the row\n        start = 0;\n        end = colNum;\n        mid = (end - start) / 2 + start;\n        while (start < end) {\n            if (target == matrix[rowToSearch][mid]) { return true; }\n            if (target < matrix[rowToSearch][mid]){\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n            mid = (end - start) / 2 + start;\n        }\n        return target == matrix[rowToSearch][start];\n    }\n}",
        "tags": "5, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 161,
        "number": 75,
        "title": "Sort Colors",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array with <i>n</i> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n</p>\n\n    <p>\n        Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        You are not suppose to use the library's sort function for this problem.\n    </p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show follow up.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\">\n        <p><b>Follow up:</b><br>\n            A rather straight forward solution is a two-pass algorithm using counting sort.<br>\n            First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.</p>\n        <p>Could you come up with an one-pass algorithm using only constant space?<br>\n        </p>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n    public void sortColors(int[] A) {\n        int oneIndex = 0, twoIndex = A.length - 1, cur = 0;\n\n        while (cur <= twoIndex) {\n            switch (A[cur]) {\n                case 0:\n                    A[cur] = A[oneIndex];\n                    A[oneIndex] = 0;\n                    cur++;\n                    oneIndex++;\n                    break;\n                case 1:\n                    cur++;\n                    break;\n                case 2:\n                    A[cur] = A[twoIndex];\n                    A[twoIndex] = 2;\n                    twoIndex--;\n                    break;\n            }\n        }\n    }\n}",
        "tags": "0, 4, 13",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 162,
        "number": 77,
        "title": "Combinations",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two integers <i>n</i> and <i>k</i>, return all possible combinations of <i>k</i> numbers out of 1 ... <i>n</i>.\n</p>\n    <p>\n        For example,<br>\n        If <i>n</i> = 4 and <i>k</i> = 2, a solution is:\n    </p>\n\n    <pre>[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> combination = new ArrayList<Integer>();\n\n        getCombinations(n, k, 1, combination, res);\n        return res;\n    }\n\n    private void getCombinations(int n, int k, int start,\n                                 List<Integer> combination, List<List<Integer>> res) {\n        if (combination.size() == k) {\n            List<Integer> temp = new ArrayList<Integer>(combination);\n            res.add(temp);\n            return;\n        }\n\n        for (int i = start; i < n + 1; i++) {\n            combination.add(i);\n            getCombinations(n, k, i + 1, combination, res);\n            combination.remove(combination.size() - 1);\n        }\n    }\n}",
        "tags": "8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 163,
        "number": 78,
        "title": "Subsets",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a set of <b>distinct</b> integers, <i>nums</i>, return all possible subsets.\n</p>\n    <p><b>Note:</b> The solution set must not contain duplicate subsets.\n    </p>\n    <p>\n        For example,<br>\n        If <b><i>nums</i></b> = <code>[1,2,3]</code>, a solution is:\n    </p>\n\n    <pre>[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> subsets(int[] S) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        List<Integer> subset = new ArrayList<Integer>();\n\n        for (int level = 0; level <= S.length; level++) {\n            getSubsets(S, level, 0, subset, res);\n            subset = new ArrayList<Integer>();\n        }\n        return res;\n    }\n\n    private void getSubsets(int[] S, int level, int start, List<Integer> subset, List<List<Integer>> res) {\n        if (start == level) {\n            ArrayList<Integer> temp = new ArrayList<Integer>(subset);\n            res.add(temp);\n            return;\n        }\n\n        for (int s : S) {\n            if (subset.size() == 0 || subset.get(subset.size() - 1) < s) {\n                subset.add(s);\n                getSubsets(S, level, start + 1, subset, res);\n                subset.remove(subset.size() - 1);\n            }\n        }\n    }\n}",
        "tags": "0, 8, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 164,
        "number": 79,
        "title": "Word Search",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a 2D board and a word, find if the word exists in the grid.\n</p>\n    <p>\n        The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n    </p>\n\n    <p>\n        For example,<br>\n        Given <b>board</b> =\n    </p><pre>[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n</pre>\n\n    <b>word</b> = <code>\"ABCCED\"</code>, -&gt; returns <code>true</code>,<br>\n    <b>word</b> = <code>\"SEE\"</code>, -&gt; returns <code>true</code>,<br>\n    <b>word</b> = <code>\"ABCB\"</code>, -&gt; returns <code>false</code>.<br>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean exist(char[][] board, String word) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[i].length; j++) {\n                if(exist(board, i, j, word, 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean exist(char[][] board, int x, int y, String word, int start) {\n        if(start >= word.length()) return true;\n        if(x < 0 || x >= board.length || y < 0 || y >= board[0].length)\n            return false;\n        if (board[x][y] == word.charAt(start++)) {\n            char c = board[x][y];\n            board[x][y] = '#';\n            boolean res = exist(board, x + 1, y, word, start) ||\n                    exist(board, x - 1, y, word, start) ||\n                    exist(board, x, y + 1, word, start) ||\n                    exist(board, x, y - 1, word, start);\n            board[x][y] = c;\n            return res;\n        }\n        return false;\n    }\n}",
        "tags": "0, 8",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 165,
        "number": 80,
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Follow up for \"Remove Duplicates\":<br>\n    What if duplicates are allowed at most <i>twice</i>?</p>\n\n    <p>\n        For example,<br>\n        Given sorted array <i>nums</i> = <code>[1,1,1,2,2,3]</code>,\n    </p>\n    <p>\n        Your function should return length = <code>5</code>, with the first five elements of <i>nums</i> being <code>1</code>, <code>1</code>, <code>2</code>, <code>2</code> and <code>3</code>. It doesn't matter what you leave beyond the new length.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int removeDuplicates(int[] A) {\n        if (A.length == 0)\n            return 0;\n        if (A.length == 1)\n            return 1;\n\n        int p = 0;\n        int q = 1;\n        int count = 0;\n\n        while (q < A.length) {\n            if (A[p] == A[q]) {\n                count++;\n                if (count < 2)\n                    A[++p] = A[q];\n            } else {\n                A[++p] = A[q];\n                count = 0;\n            }\n            q++;\n        }\n        return p + 1;\n    }\n}",
        "tags": "0, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 166,
        "number": 81,
        "title": "Search in Rotated Sorted Array II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><blockquote>\n    <p><i>Follow up</i> for \"Search in Rotated Sorted Array\":<br>\n        What if <i>duplicates</i> are allowed?</p>\n\n    <p>Would this affect the run-time complexity? How and why?</p>\n</blockquote>\n\n    <p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n    <p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n    <p>Write a function to determine if a given target is in the array.</p>\n\n    <p>The array may contain duplicates.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean search(int[] A, int target) {\n        int l = 0, r = A.length - 1;\n\n        while (l <= r) {\n            int m = l + (r - l) / 2;\n            if (A[m] == target)\n                return true;\n            if (A[l] <= A[m]) {\n                while (A[l] == A[m] && l < m)\n                    m--;\n                if (target >= A[l] && target <= A[m])\n                    r = m;\n                else\n                    l = m + 1;\n            } else if (A[l] >= A[m]) {\n                while (A[l] == A[m] && m < r)\n                    m++;\n                if (target <= A[r] && target >= A[m])\n                    l = m;\n                else\n                    r = m - 1;\n            }\n        }\n        return false;\n    }\n}",
        "tags": "0, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 167,
        "number": 82,
        "title": "Remove Duplicates from Sorted List II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <i>distinct</i> numbers from the original list.\n</p>\n    <p>\n        For example,<br>\n        Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>\n        Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n\n        if (head == null || head.next == null) return head;\n\n        ListNode pre = new ListNode(Integer.MAX_VALUE);\n        pre.next = head;\n        head = pre;\n        ListNode cur = head.next, post = cur.next;\n\n        if (cur.val != post.val) pre = pre.next;\n\n        while (post.next != null) {\n            if (cur.val == post.val || post.val == post.next.val) {\n                cur = cur.next;\n                post = post.next;\n            } else {\n                cur = cur.next;\n                post = post.next;\n                pre.next = cur;\n                pre = pre.next;\n            }\n        }\n\n        if (cur.val != post.val) {\n            pre.next = post;\n        } else {\n            pre.next = null;\n        }\n        return head.next;\n\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 168,
        "number": 86,
        "title": "Partition List",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a linked list and a value <i>x</i>, partition it such that all nodes less than <i>x</i> come before nodes greater than or equal to <i>x</i>.\n</p>\n    <p>\n        You should preserve the original relative order of the nodes in each of the two partitions.\n    </p>\n    <p>\n        For example,<br>\n        Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <i>x</i> = 3,<br>\n        return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public ListNode partition(ListNode head, int x) {\n        if (head == null) return head;\n        ListNode larger, smaller, pre, cur, fakehead = new ListNode(-1), temp;\n        fakehead.next = head;\n        smaller = fakehead;\n        larger = head;\n        while (larger != null && larger.val < x) {\n            smaller = smaller.next;\n            larger = larger.next;\n        }\n\n        if (larger == null) return head;\n\n        pre = larger;\n        cur = pre.next;\n        while (cur != null) {\n            if (cur.val >= x) {\n                cur = cur.next;\n                pre = pre.next;\n            } else {\n                temp = cur.next;\n                pre.next = cur.next;\n                cur.next = larger;\n                smaller.next = cur;\n                smaller = smaller.next;\n                cur = temp;\n            }\n        }\n        return fakehead.next;\n    }\n}",
        "tags": "2, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 169,
        "number": 89,
        "title": "Gray Code",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>\n\n    <p>Given a non-negative integer <i>n</i> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>\n\n    <p>For example, given <i>n</i> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>\n    <pre>00 - 0\n01 - 1\n11 - 3\n10 - 2\n</pre>\n\n    <p><b>Note:</b><br>\n        For a given <i>n</i>, a gray code sequence is not uniquely defined.\n    </p>\n    <p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>\n\n    <p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> re = new ArrayList<>();\n        re.add(0);\n        if (n == 0) return re;\n        re.add(1);\n        if (n == 1) return re;\n        int i = 2;\n        int times = 2;\n        while (i++ <= n) {\n            int s = re.size();\n            for (int j = s - 1; j >= 0; j--) {\n                re.add(re.get(j) + times);\n            }\n            times *= 2;\n        }\n        return re;\n    }\n}",
        "tags": "8",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 170,
        "number": 90,
        "title": "Subsets II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a collection of integers that might contain duplicates, <b><i>nums</i></b>, return all possible subsets.\n</p>\n    <p><b>Note:</b> The solution set must not contain duplicate subsets.\n    </p>\n    <p>\n        For example,<br>\n        If <b><i>nums</i></b> = <code>[1,2,2]</code>, a solution is:\n    </p>\n\n    <pre>[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] num) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n\n        Arrays.sort(num);\n        for (int level = 0; level <= num.length; level++) {\n            List<Integer> subset = new ArrayList<Integer>();\n            getSubsets(num, level, 0, subset, res);\n        }\n        return res;\n    }\n\n    private void getSubsets(int[] num, int level, int start,\n                            List<Integer> subset, List<List<Integer>> res) {\n        if (subset.size() == level) {\n            List<Integer> temp = new ArrayList<Integer>(subset);\n            res.add(temp);\n            return;\n        }\n\n        for (int i = start; i < num.length; i++) {\n            subset.add(num[i]);\n            getSubsets(num, level, i + 1, subset, res);\n            subset.remove(subset.size() - 1);\n            while (i < num.length - 1 && num[i + 1] == num[i])\n                i++;\n        }\n    }\n}",
        "tags": "0, 8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 171,
        "number": 91,
        "title": "Decode Ways",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:\n</p>\n\n    <pre>'A' -&gt; 1\n'B' -&gt; 2\n...\n'Z' -&gt; 26\n</pre>\n\n    <p>\n        Given an encoded message containing digits, determine the total number of ways to decode it.\n    </p>\n\n    <p>\n        For example,<br>\n        Given encoded message <code>\"12\"</code>,\n        it could be decoded as <code>\"AB\"</code> (1 2) or <code>\"L\"</code> (12).\n    </p>\n\n    <p>\n        The number of ways decoding <code>\"12\"</code> is 2.\n    </p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public int numDecodings(String s) {\n        if(s == null || s.length() == 0 || s.charAt(0) == '0')\n            return 0;\n        if(s.length() == 1)\n            return 1;\n\n        int[] dp = new int[s.length()];\n        dp[0] = 1;\n        if(Integer.parseInt(s.substring(0,2)) > 26){\n            dp[1] = s.charAt(1) != '0' ? 1 : 0;\n        } else {\n            dp[1] = s.charAt(1) != '0' ? 2 : 1;\n        }\n\n        for(int i = 2; i < s.length(); i++){\n            if(s.charAt(i) != '0'){\n                dp[i] += dp[i-1]; // way to decode without last digit\n            }\n\n            int val = Integer.parseInt(s.substring(i-1, i+1)); // the val form by last two digits\n            if(val <= 26 && val >= 10){\n                dp[i] += dp[i-2]; // way to decode without last two digits\n            }\n        }\n        return dp[s.length()-1];\n    }\n}",
        "tags": "5, 9",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 172,
        "number": 92,
        "title": "Reverse Linked List II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Reverse a linked list from position <i>m</i> to <i>n</i>. Do it in-place and in one-pass.\n</p>\n\n    <p>\n        For example:<br>\n        Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <i>m</i> = 2 and <i>n</i> = 4,\n    </p>\n    <p>\n        return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.\n    </p>\n    <p>\n        <b>Note:</b><br>\n        Given <i>m</i>, <i>n</i> satisfy the following condition:<br>\n        1 <= <i>m</i> <= <i>n</i> <= length of list.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        if(m==n) return head;\n\n        ListNode first = new ListNode(-1);\n        first.next = head;\n        ListNode p = head;\n        ListNode q, r;\n        head = first;\n\n        for(int i=1; i<m; i++){\n            first = first.next;\n            p = p.next;\n        }\n\n        if(p.next == null)\n            return head.next;\n\n        q = p.next;\n        r = q.next;\n        int count = 1;\n        while(count<n-m){\n            q.next = p;\n            p = q;\n            q = r;\n            r = q.next;\n            count++;\n        }\n\n        q.next = p;\n        first.next.next = r;\n        first.next = q;\n\n        return head.next;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 173,
        "number": 93,
        "title": "Restore IP Addresses",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>\n\n    <p>\n        For example:<br>\n        Given <code>\"25525511135\"</code>,\n    </p>\n    <p>\n        return <code>[\"255.255.11.135\", \"255.255.111.35\"]</code>. (Order does not matter)\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> re = new ArrayList<String>();\n        String[] sb = new String[4];\n        getIpAddresses(re, sb, s, 0);\n        return re;\n    }\n\n    public void getIpAddresses(List<String> re, String[] sb, String s, int level) {\n        int len = s.length();\n        // Too few or too many chars left for rest levels\n        // Last level but still has chars left\n        if (level < 4 && (len < 4 - level || len > 3 * (4 - level)) || level == 4 && len > 0)\n            return;\n        // If reach level 4\n        if (level == 4) {\n            StringBuilder temp = new StringBuilder();\n            for (int i = 0; i < 4; i++) {\n                temp.append(sb[i]);\n                temp.append('.');\n            }\n            temp.deleteCharAt(temp.length() - 1);\n            re.add(temp.toString());\n            return;\n        }\n        // If first char is 0\n        if (s.charAt(0) == '0') {\n            sb[level] = \"0\";\n            getIpAddresses(re, sb, s.substring(1), level + 1);\n            return;\n        }\n        // Get each possible ip address of 1 to 3 chars\n        for (int j = 1; j < 4; j++) {\n            if (j > len) break;\n            String ipStr = s.substring(0, j);\n            if (Integer.parseInt(ipStr) <= 255) {\n                sb[level] = ipStr;\n                getIpAddresses(re, sb, s.substring(j), level + 1);\n            }\n        }\n    }\n}",
        "tags": "5, 8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 174,
        "number": 94,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a binary tree, return the <i>inorder</i> traversal of its nodes' values.</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>[1,null,2,3]</code>,<br>\n    </p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n    <p></p>\n    <p>\n        return <code>[1,3,2]</code>.\n    </p>\n\n    <p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Recursive Solution\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> re = new ArrayList<>();\n        if(root == null) return re;\n        re.addAll(inorderTraversal(root.left));\n        re.add(root.val);\n        re.addAll(inorderTraversal(root.right));\n        return re;\n    }\n\n    // Iterative Solution\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> re = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        if (root == null) return re;\n        while (!stack.empty() || root != null) {\n            if (root != null) {\n                stack.push(root);\n                root = root.left;\n            } else {\n                root = stack.pop();\n                re.add(root.val);\n                root = root.right;\n            }\n        }\n        return re;\n    }\n\n    // Morris Traversal method\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        TreeNode temp = null;\n        while(root!=null){\n            if(root.left!=null){\n                // connect threading for root\n                temp = root.left;\n                while(temp.right!=null && temp.right != root)\n                    temp = temp.right;\n                // the threading already exists\n                if(temp.right!=null){\n                    temp.right = null;\n                    res.add(root.val);\n                    root = root.right;\n                }else{\n                    // construct the threading\n                    temp.right = root;\n                    root = root.left;\n                }\n            }else{\n                res.add(root.val);\n                root = root.right;\n            }\n        }\n        return res;\n    }\n}",
        "tags": "1, 12, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 175,
        "number": 95,
        "title": "Unique Binary Search Trees II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer <i>n</i>, generate all structurally unique <b>BST's</b> (binary search trees) that store values 1...<i>n</i>.</p>\n\n    <p>\n        For example,<br>\n        Given <i>n</i> = 3, your program should return all 5 unique BST's shown below.\n\n    </p><pre>   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<TreeNode> generateTrees(int n) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n        return createTree(1, n);\n    }\n\n    public List<TreeNode> createTree(int start, int end) {\n        List<TreeNode> trees = new ArrayList<>();\n        if (end <= start) {\n            TreeNode head = end < start ? null : new TreeNode(start);\n            trees.add(head);\n            return trees;\n        }\n\n        for (int i = start; i <= end; i++) {\n            List<TreeNode> lefts = createTree(start, i - 1);\n            List<TreeNode> rights = createTree(i + 1, end);\n            for (TreeNode l : lefts) {\n                for (TreeNode r : rights) {\n                    TreeNode head = new TreeNode(i);\n                    head.left = l;\n                    head.right = r;\n                    trees.add(head);\n                }\n            }\n        }\n        return trees;\n    }\n}",
        "tags": "9, 12",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 176,
        "number": 96,
        "title": "Unique Binary Search Trees",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given <i>n</i>, how many structurally unique <b>BST's</b> (binary search trees) that store values 1...<i>n</i>?</p>\n\n    <p>\n        For example,<br>\n        Given <i>n</i> = 3, there are a total of 5 unique BST's.\n\n    </p><pre>   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int numTrees(int n) {\n        int[] count = new int[n+1];\n        count[0] =1;\n        count[1] =1;\n        for(int i =2; i<=n; i++){\n            for(int j =0; j<i; j++){\n                count[i] += count[j]*count[i-j-1];\n            }\n        }\n        return count[n];\n    }\n}",
        "tags": "9, 12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 177,
        "number": 98,
        "title": "Validate Binary Search Tree",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a binary tree, determine if it is a valid binary search tree (BST).\n</p>\n\n    <p>\n        Assume a BST is defined as follows:\n    </p><ul>\n    <li>The left subtree of a node contains only nodes with keys <b>less than</b> the node's key.</li>\n    <li>The right subtree of a node contains only nodes with keys <b>greater than</b> the node's key.</li>\n    <li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n    <p></p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre>    2\n   / \\\n  1   3\n</pre>\n    Binary tree <code>[2,1,3]</code>, return true.\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre>    1\n   / \\\n  2   3\n</pre>\n    Binary tree <code>[1,2,3]</code>, return false.\n    <p></p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Recursive Solution\n    public boolean isValidBST(TreeNode root) {\n        // Make sure use Long\n        return validBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n    }\n\n    private boolean validBST(TreeNode root, long min, long max){\n        if(root == null) return true;\n        if(root.val >= max || root.val <= min )\n            return false;\n        return validBST(root.left, min, root.val) &&\n                validBST(root.right, root.val, max);\n    }\n\n    // Iterative solution\n    public boolean isValidBST(TreeNode root) {\n        if (root == null) return true;\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode pre = null;\n        while (root != null || !stack.isEmpty()) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            if(pre != null && root.val <= pre.val)\n                return false;\n            pre = root;\n            root = root.right;\n        }\n        return true;\n    }\n}",
        "tags": "12, 14",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 178,
        "number": 102,
        "title": "Binary Tree Level Order Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, return the <i>level order</i> traversal of its nodes' values. (ie, from left to right, level by level).</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br>\n    </p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n    <p></p>\n    <p>\n        return its level order traversal as:<br>\n    </p><pre>[\n  [3],\n  [9,20],\n  [15,7]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        if(root == null) return res;\n\n        Deque<TreeNode> curLevel = new ArrayDeque<TreeNode>();\n        Deque<TreeNode> nextLevel = new ArrayDeque<TreeNode>();\n        curLevel.addLast(root);\n\n        while(!curLevel.isEmpty()){\n            List<Integer> curList = new ArrayList<Integer>();\n            for(TreeNode n : curLevel){\n                curList.add(n.val);\n                if(n.left != null) nextLevel.addLast(n.left);\n                if(n.right != null) nextLevel.addLast(n.right);\n            }\n            res.add(curList);\n            curLevel = new ArrayDeque<TreeNode>(nextLevel);\n            nextLevel.clear();\n        }\n        return res;\n    }\n}",
        "tags": "12, 19",
        "companies": "",
        "specialtags": "2"
    },
    {
        "id": 179,
        "number": 103,
        "title": "Binary Tree Zigzag Level Order Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, return the <i>zigzag level order</i> traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br>\n    </p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n    <p></p>\n    <p>\n        return its zigzag level order traversal as:<br>\n    </p><pre>[\n  [3],\n  [20,9],\n  [15,7]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n        boolean order = true;\n        List<TreeNode> toVisit = new ArrayList<>();\n        toVisit.add(root);\n        while (!toVisit.isEmpty()) {\n            List<TreeNode> next = new ArrayList<>();\n            List<Integer> temp = new ArrayList<>();\n            for (TreeNode node : toVisit) {\n                temp.add(node.val);\n            }\n            res.add(temp);\n            for (int i = toVisit.size() - 1; i >= 0; i--) {\n                TreeNode node = toVisit.get(i);\n                if (order) {\n                    if (node.right != null) next.add(node.right);\n                    if (node.left != null) next.add(node.left);\n                } else {\n                    if (node.left != null) next.add(node.left);\n                    if (node.right != null) next.add(node.right);\n                }\n            }\n            order = order ? false : true;\n            toVisit = new ArrayList<TreeNode>(next);\n        }\n        return res;\n    }\n}",
        "tags": "12, 15, 19",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 180,
        "number": 105,
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>\n\n    <p><b>Note:</b><br>\n        You may assume that duplicates do not exist in the tree.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder.length == 0 || preorder.length != inorder.length) return null;\n        return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n    }\n\n    public TreeNode build(int[] pre, int start1, int end1, int[] in, int start2, int end2) {\n        if (start1 > end1 || start2 > end2) return null;\n        int val = pre[start1];\n        TreeNode cur = new TreeNode(val);\n        int k = start2;\n        for (; k <= end2; k++)\n            if (in[k] == val) break;\n        cur.left = build(pre, start1 + 1, start1 + k - start2, in, start2, k - 1);\n        cur.right = build(pre, start1 + k - start2 + 1, end1, in, k + 1, end2);\n        return cur;\n    }\n}",
        "tags": "0, 12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 181,
        "number": 106,
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>\n\n    <p><b>Note:</b><br>\n        You may assume that duplicates do not exist in the tree.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        int inStart = 0;\n        int inEnd = inorder.length-1;\n        int postStart =0;\n        int postEnd = postorder.length-1;\n\n        return buildTree(inorder, inStart, inEnd, postorder, postStart, postEnd);\n    }\n\n    public TreeNode buildTree(int[] inorder, int inStart, int inEnd,\n                              int[] postorder, int postStart, int postEnd){\n        if(inStart > inEnd || postStart > postEnd)\n            return null;\n\n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n\n        int k=0;\n        for(int i=0; i< inorder.length; i++){\n            if(inorder[i]==rootValue){\n                k = i;\n                break;\n            }\n        }\n\n        root.left = buildTree(inorder, inStart, k-1, postorder, postStart, postStart+k-(inStart+1));\n        // Becuase k is not the length, it it need to -(inStart+1) to get the length\n        root.right = buildTree(inorder, k+1, inEnd, postorder, postStart+k-inStart, postEnd-1);\n        // postStart+k-inStart = postStart+k-(inStart+1) +1\n\n        return root;\n    }\n}",
        "tags": "0, 12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 182,
        "number": 109,
        "title": "Convert Sorted List to Binary Search Tree",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; next = null; }\n * }\n */\n/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // calculate list length\n        int len = 0;\n        ListNode cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            len++;\n        }\n        // build the BST\n        return listToBST(head, 0, len - 1);\n    }\n\n    private TreeNode listToBST(ListNode head, int low, int high) {\n        if (low > high)\n            return null;\n        int mid = low + (high - low) / 2;\n        // build up tree recursively\n        TreeNode left = listToBST(head, low, mid - 1);\n        TreeNode root = new TreeNode(head.val);\n        root.left = left;\n        // Java pass in Object by reference, so we can't change head but we can\n        // change its content :)\n        if (head.next != null) { // \"move to next\"\n            head.val = head.next.val;\n            head.next = head.next.next;\n            root.right = listToBST(head, mid + 1, high);\n        }\n        return root;\n    }\n}",
        "tags": "2, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 183,
        "number": 113,
        "title": "Path Sum II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\n</p>\n\n    For example:<br>\n    Given the below binary tree and <code>sum = 22</code>,\n    <pre>              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n</pre>\n\n    <p>\n        return<br>\n    </p><pre>[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> resSet = new ArrayList<>();\n        findPathSum(root, sum, new ArrayList<Integer>(), resSet);\n        return resSet;\n    }\n\n    private void findPathSum(TreeNode root, int sum,\n                             List<Integer> path, List<List<Integer>> resSet) {\n        if (root == null) return;\n        path.add(root.val);\n        // get to a leaf and found a path\n        if (root.left == null && root.right == null && sum == root.val) {\n            // has to make a copy, otherwise the content may be changed\n            List<Integer> curPath = new ArrayList<>(path);\n            resSet.add(curPath);\n        }\n        findPathSum(root.left, sum - root.val, path, resSet);\n        findPathSum(root.right, sum - root.val, path, resSet);\n        path.remove(path.size()-1);\n    }\n}",
        "tags": "2, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 184,
        "number": 114,
        "title": "Flatten Binary Tree to Linked List",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a binary tree, flatten it to a linked list in-place.\n</p>\n\n    <p>\n        For example,<br>\n        Given\n    </p><pre>         1\n        / \\\n       2   5\n      / \\   \\\n     3   4   6\n</pre>\n    <p></p>\n\n    The flattened tree should look like:<br>\n    <pre>   1\n    \\\n     2\n      \\\n       3\n        \\\n         4\n          \\\n           5\n            \\\n             6\n</pre>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show hints.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Hints:</b>\n        <p>If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.</p>\n    </div><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n\n    // Recursive Solution\n    public void flatten(TreeNode root) {\n        flattenTree(root);\n    }\n\n    private TreeNode flattenTree(TreeNode root){\n        if (root == null ||\n                root.left == null && root.right == null) return root;\n        // Convert right subtree before assign root.righ\n        TreeNode rightSubtree = flattenTree(root.right);\n        // Set root.right to flattened left subtree\n        root.right = flattenTree(root.left);\n        root.left = null; // set left to null\n        // Find tail of the linked list\n        TreeNode cur = root;\n        while(cur.right != null)\n            cur = cur.right;\n        // Set right pointer to right sub tree\n        cur.right = rightSubtree;\n        return root;\n    }\n\n    // Iterative Solution\n    public void flatten(TreeNode root) {\n        while (root != null) {\n            if (root.left != null) {\n                TreeNode p = root.left;\n                while (p.right != null) {\n                    p = p.right;\n                }\n                p.right = root.right;\n                root.right = root.left;\n                root.left = null;\n            }\n            root = root.right;\n        }\n    }\n}",
        "tags": "12, 14",
        "companies": "0",
        "specialtags": "0"
    },
    {
        "id": 185,
        "number": 116,
        "title": "Populating Next Right Pointers in Each Node",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a binary tree\n</p><pre>    struct TreeLinkNode {\n      TreeLinkNode *left;\n      TreeLinkNode *right;\n      TreeLinkNode *next;\n    }\n</pre>\n    <p></p>\n\n    <p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n    <p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n    <p>\n        <b>Note:</b>\n    </p><ul>\n    <li>You may only use constant extra space.</li>\n    <li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>\n</ul>\n    <p></p>\n\n    <p>\n        For example,<br>\n        Given the following perfect binary tree,<br>\n    </p><pre>         1\n       /  \\\n      2    3\n     / \\  / \\\n    4  5  6  7\n</pre>\n    <p></p>\n    <p>\n        After calling your function, the tree should look like:<br>\n    </p><pre>         1 -&gt; NULL\n       /  \\\n      2 -&gt; 3 -&gt; NULL\n     / \\  / \\\n    4-&gt;5-&gt;6-&gt;7 -&gt; NULL\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree with next pointer.\n * public class TreeLinkNode {\n *     int val;\n *     TreeLinkNode left, right, next;\n *     TreeLinkNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void connect(TreeLinkNode root) {\n        if(root == null || root.left == null) return;\n\n        TreeLinkNode cur, level = root, head = root;\n        while(root.left != null){\n            root.left.next = root.right;\n            cur = root.right;\n            while(level.next != null){\n                level = level.next;\n                cur.next = level.left;\n                level.left.next = level.right;\n                cur = level.right;\n            }\n            level = root.left;\n            root = root.left;\n        }\n    }\n}",
        "tags": "12, 14",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 186,
        "number": 117,
        "title": "Populating Next Right Pointers in Each Node II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Follow up for problem \"<i>Populating Next Right Pointers in Each Node</i>\".</p>\n    <p>What if the given tree could be any binary tree? Would your previous solution still work?</p>\n    <p>\n        <b>Note:</b>\n    </p><ul><li>You may only use constant extra space.</li></ul>\n    <p></p>\n    <p>\n        For example,<br>\n        Given the following binary tree,<br>\n    </p><pre>         1\n       /  \\\n      2    3\n     / \\    \\\n    4   5    7\n</pre>\n    <p></p>\n    <p>\n        After calling your function, the tree should look like:<br>\n    </p><pre>         1 -&gt; NULL\n       /  \\\n      2 -&gt; 3 -&gt; NULL\n     / \\    \\\n    4-&gt; 5 -&gt; 7 -&gt; NULL\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree with next pointer.\n * public class TreeLinkNode {\n *     int val;\n *     TreeLinkNode left, right, next;\n *     TreeLinkNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void connect(TreeLinkNode root) {\n        TreeLinkNode first = root;\n        while (first != null) {\n            fillRow(first);\n            // move to next level\n            while (first != null && first.left == null\n                    && first.right == null) first = first.next;\n            if (first != null)\n                first = (first.left != null) ? first.left : first.right;\n        }\n    }\n\n    private void fillRow(TreeLinkNode cur) {\n        while (cur != null) {\n            if (cur.left != null && cur.right != null) {\n                cur.left.next = cur.right;\n            }\n\n            // find next has-child node\n            TreeLinkNode next = cur.next;\n            while (next != null && next.left == null && next.right == null) {\n                next = next.next;\n            }\n            if (next == null) break;\n            // find next child and link it\n            TreeLinkNode nextChild = (next.left != null) ? next.left : next.right;\n            if (cur.right != null) {\n                cur.right.next = nextChild;\n            } else if (cur.left != null) {\n                cur.left.next = nextChild;\n            }\n\n            // move to next has-child node directly\n            cur = next;\n        }\n    }\n}",
        "tags": "12, 14",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 187,
        "number": 120,
        "title": "Triangle",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>\n\n    <p>\n        For example, given the following triangle<br>\n    </p><pre>[\n     [<font color=\"red\">2</font>],\n    [<font color=\"red\">3</font>,4],\n   [6,<font color=\"red\">5</font>,7],\n  [4,<font color=\"red\">1</font>,8,3]\n]\n</pre>\n    <p></p>\n    <p>\n        The minimum path sum from top to bottom is <code>11</code> (i.e., <font color=\"red\">2</font> + <font color=\"red\">3</font> + <font color=\"red\">5</font> + <font color=\"red\">1</font> = 11).\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        Bonus point if you are able to do this using only <i>O</i>(<i>n</i>) extra space, where <i>n</i> is the total number of rows in the triangle.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        int[] total = new int[triangle.size()];\n        int l = triangle.size() - 1;\n        for (int i = 0; i < triangle.get(l).size(); i++) {\n            total[i] = triangle.get(l).get(i);\n        }\n\n        // iterate from last second row\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            for (int j = 0; j < triangle.get(i + 1).size() - 1; j++) {\n                total[j] = triangle.get(i).get(j) + Math.min(total[j], total[j + 1]);\n            }\n        }\n        return total[0];\n    }\n}",
        "tags": "0, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 188,
        "number": 127,
        "title": "Word Ladder",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary's word list, find the length of shortest transformation sequence from <i>beginWord</i> to <i>endWord</i>, such that:\n</p>\n    <ol>\n        <li>Only one letter can be changed at a time.</li>\n        <li>Each transformed word must exist in the word list. Note that <i>beginWord</i> is <i>not</i> a transformed word.</li>\n    </ol>\n\n    <p>\n        For example,\n    </p>\n    <p>\n        Given:<br>\n        <i>beginWord</i> = <code>\"hit\"</code><br>\n        <i>endWord</i> = <code>\"cog\"</code><br>\n        <i>wordList</i> = <code>[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</code><br>\n    </p>\n    <p>\n        As one shortest transformation is <code>\"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\"</code>,<br>\n        return its length <code>5</code>.\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n    </p><ul>\n    <li>Return 0 if there is no such transformation sequence.</li>\n    <li>All words have the same length.</li>\n    <li>All words contain only lowercase alphabetic characters.</li>\n    <li>You may assume no duplicates in the word list.</li>\n    <li>You may assume <i>beginWord</i> and <i>endWord</i> are non-empty and are not the same.</li>\n</ul>\n</div>",
        "solution": "public class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> dict = new HashSet<>();\n        dict.addAll(wordList);\n\n        if (dict.size() == 0) return 0;\n\n        LinkedList<String> wordQueue = new LinkedList<String>();\n        LinkedList<Integer> distanceQueue = new LinkedList<Integer>();\n\n        wordQueue.add(beginWord);\n        distanceQueue.add(1);\n\n        while (!wordQueue.isEmpty()) {\n            String currWord = wordQueue.pop();\n            Integer currDistance = distanceQueue.pop();\n\n            if (currWord.equals(endWord)) {\n                return currDistance;\n            }\n\n            for (int i = 0; i < currWord.length(); i++) {\n                char[] currCharArr = currWord.toCharArray();\n                for (char c = 'a'; c <= 'z'; c++) {\n                    currCharArr[i] = c;\n\n                    String newWord = new String(currCharArr);\n                    if (dict.contains(newWord)) {\n                        wordQueue.add(newWord);\n                        distanceQueue.add(currDistance + 1);\n                        dict.remove(newWord);\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n}",
        "tags": "0, 5, 14, 19",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 189,
        "number": 129,
        "title": "Sum Root to Leaf Numbers",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>\n    <p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>\n\n    <p>Find the total sum of all root-to-leaf numbers.</p>\n\n    <p>For example,\n    </p><pre>    1\n   / \\\n  2   3\n</pre>\n    <p></p>\n    <p>\n        The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>\n        The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.\n    </p>\n    <p>\n        Return the sum = 12 + 13 = <code>25</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root == null) return 0;\n        return sumNumbersHelper(root, root.val, 0);\n    }\n\n    // path is the sum from root to the current node\n    // sum is the sum of all root-to-leaf numbers up to the current node\n    private int sumNumbersHelper(TreeNode root, int path, int sum) {\n        if (root.left == null && root.right == null) { // reach a leaf\n            return sum + path;\n        }\n\n        if (root.left != null) { // go to left subtree\n            sum = sumNumbersHelper(root.left, path * 10 + root.left.val, sum);\n        }\n        if (root.right != null) { // go to right subtree\n            sum = sumNumbersHelper(root.right, path * 10 + root.right.val, sum);\n        }\n\n        return sum;\n    }\n}",
        "tags": "12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 190,
        "number": 130,
        "title": "Surrounded Regions",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a 2D board containing <code>'X'</code> and <code>'O'</code> (the <b>letter</b> O), capture all regions surrounded by <code>'X'</code>.</p>\n\n    <p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.\n    </p>\n\n    <p>\n        For example,<br>\n    </p><pre>X X X X\nX O O X\nX X O X\nX O X X\n</pre>\n    <p></p>\n\n    <p>\n        After running your function, the board should be:\n    </p><pre>X X X X\nX X X X\nX X X X\nX O X X\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public void solve(char[][] board) {\n        if (board.length <= 2 || board[0].length <= 2) return;\n        int rows = board.length, columns = board[0].length;\n\n        // Start from 'O's on the edge and mark connected ones as non-flipable.\n        // first and last columns\n        for (int i = 1; i < rows - 1; ++i) {\n            if (board[i][0] == 'O')\n                markBFS(board, i, 1);\n            if (board[i][columns - 1] == 'O')\n                markBFS(board, i, columns - 2);\n        }\n        // first and last rows\n        for (int j = 1; j < columns - 1; ++j) {\n            if (board[0][j] == 'O')\n                markBFS(board, 1, j);\n            if (board[rows - 1][j] == 'O')\n                markBFS(board, rows - 2, j);\n        }\n\n        // flip\n        for (int i = 1; i < rows - 1; ++i) {\n            for (int j = 1; j < columns - 1; ++j) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == 'N') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n\n    private void markBFS(char[][] board, int row, int col) {\n        Queue<Integer> que = new LinkedList<Integer>();\n        mark(board, row, col, que);\n        int rows = board.length, columns = board[0].length;\n        while (!que.isEmpty()) {\n            int cell = que.poll();\n            int x = cell / columns, y = cell % columns;\n            // push its neighbors to stack if needed\n            if (x + 1 < rows - 1)\n                mark(board, x + 1, y, que);\n            if (x - 1 > 0)\n                mark(board, x - 1, y, que);\n            if (y + 1 < columns - 1)\n                mark(board, x, y + 1, que);\n            if (y - 1 > 0)\n                mark(board, x, y - 1, que);\n        }\n    }\n\n    private void mark(char[][] board, int row, int col, Queue<Integer> que) {\n        if (board[row][col] != 'O') return;\n        board[row][col] = 'N';\n        int columns = board[0].length;\n        que.offer(row * columns + col);\n    }\n}",
        "tags": "16, 19",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 191,
        "number": 131,
        "title": "Palindrome Partitioning",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.\n</p>\n    <p>\n        Return all possible palindrome partitioning of <i>s</i>.\n    </p>\n    <p>\n        For example, given <i>s</i> = <code>\"aab\"</code>,<br>\n\n        Return\n    </p><pre>[\n  [\"aa\",\"b\"],\n  [\"a\",\"a\",\"b\"]\n]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> res = new ArrayList<List<String>>();\n        int len = s.length();\n        boolean[][] palindromeTable = new boolean[len][len];\n\n        // build palindrome dp table\n        for (int i = 0; i < len; i++) {\n            palindromeTable[i][i] = true;\n\n            int l = i, r = i + 1;\n            while (l >= 0 && r <= len - 1 && s.charAt(l) == s.charAt(r)) {\n                palindromeTable[l--][r++] = true;\n            }\n\n            l = i - 1;\n            r = i + 1;\n            while (l >= 0 && r <= len - 1 && s.charAt(l) == s.charAt(r)) {\n                palindromeTable[l--][r++] = true;\n            }\n        }\n        List<String> partition = new ArrayList<String>();\n        addPalindrome(s, 0, partition, res, palindromeTable);\n\n        return res;\n    }\n\n    private void addPalindrome(String s, int start, List<String> partition,\n                               List<List<String>> result, boolean[][] palindromeTable) {\n        // stop condition\n        if (start == s.length()) {\n            List<String> temp = new ArrayList<String>(partition);\n            result.add(temp);\n            return;\n        }\n\n        for (int i = start; i < s.length(); i++) {\n            if (palindromeTable[start][i]) {\n                String str = s.substring(start, i + 1);\n                partition.add(str);\n                addPalindrome(s, i + 1, partition, result, palindromeTable);\n                partition.remove(partition.size() - 1);\n            }\n        }\n    }\n}",
        "tags": "8",
        "companies": "",
        "specialtags": "2"
    },
    {
        "id": 192,
        "number": 133,
        "title": "Clone Graph",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.\n</p>\n\n    <div>\n        <br>\n        <b>OJ's undirected graph serialization:</b>\n\n        <p>\n            Nodes are labeled uniquely.\n        </p>\n\n        We use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.\n        <p></p>\n\n\n        <p>\n            As an example, consider the serialized graph <code><font color=\"red\">{<font color=\"black\">0</font>,1,2#</font><font color=\"blue\"><font color=\"black\">1</font>,2#</font><font color=\"green\"><font color=\"black\">2</font>,2}</font></code>.\n        </p>\n\n        <p>\n            The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.\n        </p><ol>\n        <li>First node is labeled as <code><font color=\"black\">0</font></code>. Connect node <code><font color=\"black\">0</font></code> to both nodes <code><font color=\"red\">1</font></code> and <code><font color=\"red\">2</font></code>.</li>\n        <li>Second node is labeled as <code><font color=\"black\">1</font></code>. Connect node <code><font color=\"black\">1</font></code> to node <code><font color=\"blue\">2</font></code>.</li>\n        <li>Third node is labeled as <code><font color=\"black\">2</font></code>. Connect node <code><font color=\"black\">2</font></code> to node <code><font color=\"green\">2</font></code> (itself), thus forming a self-cycle.</li>\n    </ol>\n        <p></p>\n\n        <p>\n            Visually, the graph looks like the following:\n        </p><pre>       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/\n</pre>\n        <p></p>\n\n    </div><p></p>\n</div>",
        "solution": "/**\n * Definition for undirected graph.\n * class UndirectedGraphNode {\n * int label;\n * ArrayList<UndirectedGraphNode> neighbors;\n * UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }\n * };\n */\npublic class Solution {\n\n    private UndirectedGraphNode cloneBFS(UndirectedGraphNode root) {\n        if (root == null)\n            return root;\n\n        ArrayDeque<UndirectedGraphNode> que = new ArrayDeque<UndirectedGraphNode>();\n        que.addLast(root);\n\n        HashMap<UndirectedGraphNode, UndirectedGraphNode> visited = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();\n        UndirectedGraphNode rootCopy = new UndirectedGraphNode(root.label);\n        visited.put(root, rootCopy);\n\n        // BFS\n        while (!que.isEmpty()) {\n            root = que.removeFirst();\n            UndirectedGraphNode node = visited.get(root);\n            for (UndirectedGraphNode nb : root.neighbors) {\n                if (visited.containsKey(nb)) {\n                    node.neighbors.add(visited.get(nb));\n                } else {\n                    UndirectedGraphNode n = new UndirectedGraphNode(nb.label);\n                    node.neighbors.add(n);\n                    visited.put(nb, n);\n                    que.addLast(nb);\n                }\n            }\n        }\n\n        return rootCopy;\n    }\n\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        return cloneBFS(node);\n    }\n}",
        "tags": "14, 19, 23",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 193,
        "number": 134,
        "title": "Gas Station",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    There are <i>N</i> gas stations along a circular route, where the amount of gas at station <i>i</i> is <code>gas[i]</code>.\n</p>\n\n    <p>\n        You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <i>i</i> to its next station (<i>i</i>+1). You begin the journey with an empty tank at one of the gas stations.\n    </p>\n\n    <p>\n        Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        The solution is guaranteed to be unique.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int[] diff = new int[gas.length];\n        for (int i = 0; i < gas.length; ++i) {\n            diff[i] = gas[i] - cost[i];\n        }\n\n        int leftGas = 0, sum = 0, startnode = 0;\n        for (int i = 0; i < gas.length; ++i) {\n            leftGas += diff[i];\n            sum += diff[i];\n            if (sum < 0) {\n                startnode = i + 1;\n                sum = 0;\n            }\n        }\n        if (leftGas < 0)\n            return -1;\n        else\n            return startnode;\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 194,
        "number": 137,
        "title": "Single Number II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array of integers, every element appears <i>three</i> times except for one, which appears exactly once. Find that single one.\n</p>\n\n    <p>\n        <b>Note:</b><br>\n        Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int singleNumber(int[] A) {\n        if (A.length <= 3) return A[0];\n\n        int bitSum = 0, res = 0;\n        for (int i = 0; i < 32; i++) {\n            bitSum = 0;\n            for (int a : A) {\n                if ((a & (1 << i)) != 0) bitSum++;\n            }\n            if (bitSum % 3 != 0) res |= (1 << i);\n        }\n        return res;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 195,
        "number": 138,
        "title": "Copy List with Random Pointer",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\n</p>\n\n    <p>\n        Return a deep copy of the list.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list with a random pointer.\n * class RandomListNode {\n * int label;\n * RandomListNode next, random;\n * RandomListNode(int x) { this.label = x; }\n * };\n */\npublic class Solution {\n    // Solution without map, 3 rounds of scan\n    public RandomListNode copyRandomList(RandomListNode head) {\n        RandomListNode iter = head, next;\n\n        // First round: make copy of each node,\n        // and link them together side-by-side in a single list.\n        while (iter != null) {\n            next = iter.next;\n            RandomListNode copy = new RandomListNode(iter.label);\n            iter.next = copy;\n            copy.next = next;\n            iter = next;\n        }\n\n        // Second round: assign random pointers for the copy nodes.\n        iter = head;\n        while (iter != null) {\n            if (iter.random != null) {\n                iter.next.random = iter.random.next;\n            }\n            iter = iter.next.next;\n        }\n\n        // Third round: restore the original list, and extract the copy list.\n        iter = head;\n        RandomListNode pseudoHead = new RandomListNode(0);\n        RandomListNode copy, copyIter = pseudoHead;\n\n        while (iter != null) {\n            next = iter.next.next;\n            // extract the copy\n            copy = iter.next;\n            copyIter.next = copy;\n            copyIter = copy;\n            // restore the original list\n            iter.next = next;\n            iter = next;\n        }\n        return pseudoHead.next;\n    }\n\n    // Solution with Map\n    public RandomListNode copyRandomList(RandomListNode head) {\n        // No node\n        if (head == null) return null;\n\n        HashMap<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\n        RandomListNode resHead = new RandomListNode(head.label);\n\n        // Copy list with next pointers\n        RandomListNode cur = head;\n        RandomListNode resCur = resHead;\n        map.put(cur, resCur);\n\n        cur = cur.next;\n        while (cur != null) {\n            resCur.next = new RandomListNode(cur.label);\n            map.put(cur, resCur.next);\n            cur = cur.next;\n            resCur = resCur.next;\n        }\n\n        cur = head;\n        resCur = resHead;\n        while (cur != null) {\n            if (cur.random != null) {\n                resCur.random = map.get(cur.random);\n            } else {\n                resCur.random = null;\n            }\n\n            cur = cur.next;\n            resCur = resCur.next;\n        }\n\n        return resHead;\n    }\n}",
        "tags": "1, 2",
        "companies": "0",
        "specialtags": "0"
    },
    {
        "id": 196,
        "number": 139,
        "title": "Word Break",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a <b>non-empty</b> string <i>s</i> and a dictionary <i>wordDict</i> containing a list of <b>non-empty</b> words, determine if <i>s</i> can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.\n</p>\n\n    <p>For example, given<br>\n        <i>s</i> = <code>\"leetcode\"</code>,<br>\n        <i>dict</i> = <code>[\"leet\", \"code\"]</code>.\n    </p>\n\n    <p>\n        Return true because <code>\"leetcode\"</code> can be segmented as <code>\"leet code\"</code>.\n    </p>\n\n    <p>\n        <b><font color=\"red\">UPDATE (2017/1/4):</font></b><br>\n        The <i>wordDict</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean wordBreak(String s, Set<String> dict) {\n        boolean[] t = new boolean[s.length() + 1];\n        t[0] = true; //set first to be true, why?\n        //Because we need initial state\n\n        for (int i = 0; i < s.length(); i++) {\n            //should continue from match position\n            if (!t[i])\n                continue;\n\n            for (String a : dict) {\n                int len = a.length();\n                int end = i + len;\n                if (end > s.length())\n                    continue;\n                if (s.substring(i, end).equals(a)) {\n                    t[end] = true;\n                }\n            }\n        }\n\n        return t[s.length()];\n    }\n}",
        "tags": "9",
        "companies": "0",
        "specialtags": "0"
    },
    {
        "id": 197,
        "number": 142,
        "title": "Linked List Cycle II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.\n</p>\n\n    <p>\n        <b>Note:</b> Do not modify the linked list.</p>\n\n    <p>\n        <b>Follow up</b>:<br>\n        Can you solve it without using extra space?\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode first = head;\n        ListNode second = head;\n\n        while (first != null && second != null) {\n            first = first.next;\n            second = second.next;\n            if (second != null)\n                second = second = second.next;\n            if (first == second)\n                break;\n        }\n\n        if (second == null)\n            return null;\n\n        first = head;\n        while (first != second) {\n            first = first.next;\n            second = second.next;\n        }\n\n        return second;\n    }\n}",
        "tags": "2, 4",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 198,
        "number": 143,
        "title": "Reorder List",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a singly linked list <i>L</i>: <i>L</i><sub>0</sub>?<i>L</i><sub>1</sub>?…?<i>L</i><sub><i>n</i>-1</sub>?<i>L</i><sub>n</sub>,<br>\n    reorder it to: <i>L</i><sub>0</sub>?<i>L</i><sub><i>n</i></sub>?<i>L</i><sub>1</sub>?<i>L</i><sub><i>n</i>-1</sub>?<i>L</i><sub>2</sub>?<i>L</i><sub><i>n</i>-2</sub>?…\n</p>\n\n    <p>You must do this in-place without altering the nodes' values.</p>\n\n    <p>\n        For example,<br>\n        Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) return;\n\n        // step 1. cut the list to two halves\n        // prev will be the tail of 1st half\n        // slow will be the head of 2nd half\n        ListNode prev = null, slow = head, fast = head, l1 = head;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = null;\n\n        // step 2. reverse the 2nd half\n        ListNode l2 = reverse(slow);\n\n        // step 3. merge the two halves\n        merge(l1, l2);\n    }\n\n    private ListNode reverse(ListNode head) {\n        ListNode prev = null, curr = head, next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    private void merge(ListNode l1, ListNode l2) {\n        while (l1 != null) {\n            ListNode n1 = l1.next, n2 = l2.next;\n            l1.next = l2;\n            if (n1 == null) break;\n\n            l2.next = n1;\n            l1 = n1;\n            l2 = n2;\n        }\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 199,
        "number": 144,
        "title": "Binary Tree Preorder Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a binary tree, return the <i>preorder</i> traversal of its nodes' values.</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>{1,#,2,3}</code>,<br>\n    </p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n    <p></p>\n    <p>\n        return <code>[1,2,3]</code>.\n    </p>\n\n    <p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution\n\n        // Recursive Solution\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> re = new ArrayList<Integer>();\n            if (root == null) return re;\n            re.add(root.val);\n            re.addAll(preorderTraversal(root.left));\n            re.addAll(preorderTraversal(root.right));\n            return re;\n        }\n\n        // Iterative Solution\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> res = new ArrayList<>();\n            if (root == null) return res;\n            Stack<TreeNode> stack = new Stack<>();\n            stack.push(root);\n            while (!stack.isEmpty()) {\n                root = stack.pop();\n                res.add(root.val);\n                if (root.right != null)\n                    stack.push(root.right);\n                if (root.left != null)\n                    stack.push(root.left);\n            }\n            return res;\n        }\n\n        // Morris Travasal\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> res = new ArrayList<Integer>();\n            TreeNode cur = root, prev;\n            while (cur != null) {\n                if (cur.left == null) {\n                    res.add(cur.val);\n                    cur = cur.right;\n                } else {\n                    prev = cur.left;\n                    while (prev.right != null && prev.right != cur)\n                        prev = prev.right;\n\n                    if (prev.right == null) {\n                        // the only difference with inorder-traversal\n                        res.add(cur.val);\n                        prev.right = cur;\n                        cur = cur.left;\n                    } else {\n                        prev.right = null;\n                        cur = cur.right;\n                    }\n                }\n            }\n            return res;\n        }\n}",
        "tags": "12, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 200,
        "number": 147,
        "title": "Insertion Sort List",
        "difficulty": "Medium",
        "description": "Sort a linked list using insertion sort.",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n\n        ListNode newHead = new ListNode(head.val);\n        ListNode pointer = head.next;\n        // loop through each element in the list\n        while (pointer != null) {\n            // insert this element to the new list\n\n            ListNode innerPointer = newHead;\n            ListNode next = pointer.next;\n\n            if (pointer.val <= newHead.val) {\n                ListNode oldHead = newHead;\n                newHead = pointer;\n                newHead.next = oldHead;\n            } else {\n                while (innerPointer.next != null) {\n                    if (pointer.val > innerPointer.val && pointer.val <= innerPointer.next.val) {\n                        ListNode oldNext = innerPointer.next;\n                        innerPointer.next = pointer;\n                        pointer.next = oldNext;\n                    }\n                    innerPointer = innerPointer.next;\n                }\n\n                if (innerPointer.next == null && pointer.val > innerPointer.val) {\n                    innerPointer.next = pointer;\n                    pointer.next = null;\n                }\n            }\n            // finally\n            pointer = next;\n        }\n        return newHead;\n    }\n}",
        "tags": "2, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 201,
        "number": 148,
        "title": "Sort List",
        "difficulty": "Medium",
        "description": "Sort a linked list in O(n log n) time using constant space complexity.",
        "solution": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n\n        // count total number of elements\n        int count = 0;\n        ListNode p = head;\n        while (p != null) {\n            count++;\n            p = p.next;\n        }\n\n        // break up to two list\n        int middle = count / 2;\n        ListNode l = head, r = null;\n        ListNode p2 = head;\n        int countHalf = 0;\n        while (p2 != null) {\n            countHalf++;\n            ListNode next = p2.next;\n            if (countHalf == middle) {\n                p2.next = null;\n                r = next;\n            }\n            p2 = next;\n        }\n\n        // now we have two parts l and r, recursively sort them\n        ListNode h1 = sortList(l);\n        ListNode h2 = sortList(r);\n\n        // merge together\n        ListNode merged = merge(h1, h2);\n        return merged;\n    }\n\n    public static ListNode merge(ListNode l, ListNode r) {\n        ListNode p1 = l;\n        ListNode p2 = r;\n\n        ListNode fakeHead = new ListNode(100);\n        ListNode pNew = fakeHead;\n\n        while (p1 != null || p2 != null) {\n            if (p1 == null) {\n                pNew.next = new ListNode(p2.val);\n                p2 = p2.next;\n                pNew = pNew.next;\n            } else if (p2 == null) {\n                pNew.next = new ListNode(p1.val);\n                p1 = p1.next;\n                pNew = pNew.next;\n            } else {\n                if (p1.val < p2.val) {\n                    // if(fakeHead)\n                    pNew.next = new ListNode(p1.val);\n                    p1 = p1.next;\n                    pNew = pNew.next;\n                } else if (p1.val == p2.val) {\n                    pNew.next = new ListNode(p1.val);\n                    pNew.next.next = new ListNode(p1.val);\n                    pNew = pNew.next.next;\n                    p1 = p1.next;\n                    p2 = p2.next;\n                } else {\n                    pNew.next = new ListNode(p2.val);\n                    p2 = p2.next;\n                    pNew = pNew.next;\n                }\n            }\n        }\n        // printList(fakeHead.next);\n        return fakeHead.next;\n    }\n}",
        "tags": "2, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 202,
        "number": 150,
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Evaluate the value of an arithmetic expression in <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\">Reverse Polish Notation</a>.\n</p>\n\n    <p>\n        Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.\n    </p>\n\n    <p>\n        Some examples:<br>\n    </p><pre>  [\"2\", \"1\", \"+\", \"3\", \"*\"] -&gt; ((2 + 1) * 3) -&gt; 9\n  [\"4\", \"13\", \"5\", \"/\", \"+\"] -&gt; (4 + (13 / 5)) -&gt; 6\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int evalRPN(String[] tokens) {\n        //Start 10:10\n        // 1, Push all tokens into stack.\n        // 2, Pop one entry each time,\n        // 2.1 If it is an operand then push into second stack\n        // 2.2 If it is an operator, then pop out two entries from second stack.\n        // Evaluate the result and push the result back into the second stack.\n        // 3, Stop when the stack is empty.\n        // 4, Return the value in the second stack as result.\n\n        Stack<Integer> valueStack = new Stack<Integer>();\n\n        for (String s : tokens) {\n            if (s.equals(\"+\") || s.equals(\"-\") || s.equals(\"*\") || s.equals(\"/\")) {\n                int firstValue = valueStack.pop();\n                int secondValue = valueStack.pop();\n                switch (s) {\n                    case \"+\":\n                        valueStack.push(firstValue + secondValue);\n                        break;\n                    case \"-\":\n                        valueStack.push(secondValue - firstValue);\n                        break;\n                    case \"*\":\n                        valueStack.push(firstValue * secondValue);\n                        break;\n                    case \"/\":\n                        valueStack.push(secondValue / firstValue);\n                        break;\n                }\n            } else {\n                valueStack.push(Integer.parseInt(s));\n            }\n        }\n\n        return valueStack.pop();\n    }\n}",
        "tags": "15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 203,
        "number": 151,
        "title": "Reverse Words in a String",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an input string, reverse the string word by word.\n</p>\n\n    <p>\n        For example,<br>\n        Given s = \"<code>the sky is blue</code>\",<br>\n        return \"<code>blue is sky the</code>\".\n    </p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Clarification:</b>\n\n        <p>\n        </p><ul>\n            <li>What constitutes a word?<br>\n                A sequence of non-space characters constitutes a word.</li>\n            <li>Could the input string contain leading or trailing spaces?<br>\n                Yes. However, your reversed string should not contain leading or trailing spaces.</li>\n            <li>How about multiple spaces between two words?<br>\n                Reduce them to a single space in the reversed string.</li>\n        </ul>\n        <p></p>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n\n    // Algorithm:\n    // 1. put words into a stack\n    // 2. pop out words\n    public String reverseWords(String s) {\n        if(s == null) return s;\n        s = s.trim();\n        int len = s.length();\n        if(len == 0) return \"\";\n\n        int startIndex = 0;\n        int endIndex = len-1;\n\n        String[] strs = s.split(\"\\\\s+\");\n        int strCount = strs.length;\n        StringBuilder res = new StringBuilder();\n        for(int i = strCount - 1; i >=0; i--){\n            res.append(strs[i]);\n            if(i > 0)\n                res.append(\" \");\n        }\n        return res.toString();\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 204,
        "number": 152,
        "title": "Maximum Product Subarray",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n</p>\n\n    <p>\n        For example, given the array <code>[2,3,-2,4]</code>,<br>\n        the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int maxProduct(int[] A) {\n        if (A == null || A.length == 0) return 0;\n        if (A.length == 1) return A[0];\n        int max_local = A[0];\n        int min_local = A[0];\n        int global = A[0];\n        for (int i = 1; i < A.length; i++) {\n            int max_copy = max_local;\n            max_local = Math.max(Math.max(A[i] * max_local, A[i]), A[i] * min_local);\n            min_local = Math.min(Math.min(A[i] * max_copy, A[i]), A[i] * min_local);\n            global = Math.max(global, max_local);\n        }\n        return global;\n    }\n}",
        "tags": "0, 9",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 205,
        "number": 153,
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n    <p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n    <p>Find the minimum element.</p>\n\n    <p>You may assume no duplicate exists in the array.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findMin(int[] nums) {\n        if (nums.length == 0) return 0;\n        return getMinFrom(nums, 0, nums.length - 1);\n    }\n\n    int getMinFrom(int[] nums, int start, int end) {\n        if (nums[start] <= nums[end]) return nums[start];\n        if (start == end - 1)\n            return (nums[start] < nums[end]) ? nums[start] : nums[end];\n\n        int mid = start + (end - start) / 2;\n        if (nums[mid] > nums[start])\n            return getMinFrom(nums, mid + 1, end);\n        else\n            return getMinFrom(nums, start, mid);\n    }\n}",
        "tags": "0, 11",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 206,
        "number": 162,
        "title": "Find Peak Element",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>A peak element is an element that is greater than its neighbors.</p>\n\n    <p>Given an input array where <code>num[i] != num[i+1]</code>, find a peak element and return its index.</p>\n\n    <p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>\n\n    <p>You may imagine that <code>num[-1] = num[n] = -infinite</code>.</p>\n\n    <p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show spoilers.</a></p>\n\n    <div class=\"spoilers\" style=\"display: none;\"><b>Note:</b>\n        <p>Your solution should be in logarithmic complexity.</p>\n    </div>\n\n</div>",
        "solution": "public class Solution {\n    public int findPeakElement(int[] nums) {\n        if (nums == null) return -1;\n        if (nums.length == 1) return 0;\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (mid == 0) {\n                if (nums[mid] > nums[mid + 1]) return mid;\n                else l = mid + 1;\n            } else if (mid == nums.length - 1) {\n                if (nums[mid] > nums[mid - 1]) return mid;\n                else r = mid - 1;\n            } else if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {\n                return mid;\n            } else if (nums[mid] <= nums[mid - 1]) {\n                r = mid - 1;\n            } else { // nums[mid]<=nums[mid+1]\n                l = mid + 1;\n            }\n        }\n        return -1;\n    }\n}",
        "tags": "0, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 207,
        "number": 165,
        "title": "Compare Version Numbers",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Compare two version numbers <i>version1</i> and <i>version2</i>.<br>\n    If <i>version1</i> &gt; <i>version2</i> return 1, if <i>version1</i> &lt; <i>version2</i> return -1, otherwise return 0.</p>\n\n    <p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br>\n        The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br>\n        For instance, <code>2.5</code> is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision.</p>\n\n    <p>Here is an example of version numbers ordering:</p>\n    <pre>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</pre>\n</div>",
        "solution": "public class Solution {\n    public int compareVersion(String version1, String version2) {\n        // recursively compare substrings before '.'\n        int ver1, ver2;\n        ver1 = version1.contains(\".\") ?\n                Integer.parseInt(version1.substring(0, version1.indexOf('.'))) :\n                Integer.parseInt(version1);\n        ver2 = version2.contains(\".\") ?\n                Integer.parseInt(version2.substring(0, version2.indexOf('.'))) :\n                Integer.parseInt(version2);\n\n        if (ver1 > ver2) return 1;\n        else if (ver1 < ver2) return -1;\n\n        if (version1.contains(\".\") && version2.contains(\".\"))\n            return compareVersion(version1.substring(version1.indexOf('.') + 1),\n                    version2.substring(version2.indexOf('.') + 1));\n        else if (version1.contains(\".\"))\n            return compareVersion(version1.substring(version1.indexOf('.') + 1), \"0\");\n        else if (version2.contains(\".\"))\n            return compareVersion(\"0\", version2.substring(version2.indexOf('.') + 1));\n        else return 0;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 208,
        "number": 166,
        "title": "Fraction to Recurring Decimal",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>\n\n    <p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n    <p>\n        For example,\n    </p><ul>\n    <li>Given numerator = 1, denominator = 2, return \"0.5\".</li>\n    <li>Given numerator = 2, denominator = 1, return \"2\".</li>\n    <li>Given numerator = 2, denominator = 3, return \"0.(6)\".</li>\n</ul>\n\n</div>",
        "solution": "public class Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        StringBuilder res = new StringBuilder();\n        long numeratorL = Math.abs((long) numerator);\n        long denominatorL = Math.abs((long) denominator);\n        // Negative result\n        if (numerator > 0 && denominator < 0 || numerator < 0 && denominator > 0)\n            res.append(\"-\");\n        // Integer part\n        long num = numeratorL / denominatorL;\n        res.append(num);\n        numeratorL = (numeratorL % denominatorL) * 10;\n        if (numeratorL > 0) res.append(\".\");\n        Map<Long, Integer> map = new HashMap<Long, Integer>();\n        // Decimal part\n        while (numeratorL > 0) {\n            num = numeratorL / denominatorL;\n            if (map.containsKey(numeratorL)) {\n                res.insert(map.get(numeratorL).intValue(), \"(\");\n                res.append(\")\");\n                break;\n            }\n            map.put(numeratorL, res.length());\n            numeratorL = (numeratorL % denominatorL) * 10;\n            res.append(num);\n        }\n        return res.toString();\n    }\n}",
        "tags": "1, 3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 209,
        "number": 173,
        "title": "Binary Search Tree Iterator",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>\n\n    <p>Calling <code>next()</code> will return the next smallest number in the BST.</p>\n\n    <p><b>Note: </b><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<i>h</i>) memory, where <i>h</i> is the height of the tree. </p>\n\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\n\npublic class BSTIterator {\n    Stack<TreeNode> stack;\n\n    public BSTIterator(TreeNode root) {\n        stack = new Stack<TreeNode>();\n        while (root != null) {\n            stack.push(root);\n            root = root.left;\n        }\n    }\n\n    /**\n     * @return whether we have a next smallest number\n     */\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n\n    /**\n     * @return the next smallest number\n     */\n    public int next() {\n        TreeNode node = stack.pop();\n        int result = node.val;\n        if (node.right != null) {\n            node = node.right;\n            while (node != null) {\n                stack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    }\n}\n\n/**\n * Your BSTIterator will be called like this:\n * BSTIterator i = new BSTIterator(root);\n * while (i.hasNext()) v[f()] = i.next();\n */",
        "tags": "10, 12, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 210,
        "number": 179,
        "title": "Largest Number",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a list of non negative integers, arrange them such that they form the largest number.</p>\n\n    <p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p>\n\n    <p>Note: The result may be very large, so you need to return a string instead of an integer.</p>\n\n</div>",
        "solution": "public class Solution {\n    public String largestNumber(int[] nums) {\n        String[] numNew = new String[nums.length];\n        for (int i = 0; i < nums.length; i++){\n            numNew[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(numNew, NumberComparator);\n        StringBuffer strBuf = new StringBuffer();\n        // Use larger number first\n        for (int i = nums.length-1; i >= 0; i--) {\n            strBuf.append(numNew[i]);\n        }\n        // Check if it is 0\n        return strBuf.charAt(0) == '0' ? \"0\" : strBuf.toString();\n    }\n    // Comparator to sort number in ascending order\n    static final Comparator<String> NumberComparator = new Comparator<String>(){\n        public int compare(String i1, String i2) {\n            int i = 0;\n            while (i < i1.length() && i < i2.length()) {\n                if (i1.charAt(i) != i2.charAt(i))\n                    return i1.charAt(i) - i2.charAt(i);\n                i++;\n            }\n            if (i < i1.length())\n                return compare(i1.substring(i), i2);\n            if (i < i2.length())\n                return compare(i1, i2.substring(i));\n            return 0;\n        }\n    };\n}",
        "tags": "13",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 211,
        "number": 187,
        "title": "Repeated DNA Sequences",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \"ACGAATTCCG\". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>\n\n    <p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>\n\n    <p>\n        For example,</p>\n    <pre>Given s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\n\nReturn:\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        Set seen = new HashSet(), repeated = new HashSet();\n        for (int i = 0; i + 9 < s.length(); i++) {\n            String ten = s.substring(i, i + 10);\n            if (!seen.add(ten))\n                repeated.add(ten);\n        }\n        return new ArrayList(repeated);\n    }\n}",
        "tags": "1, 22",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 212,
        "number": 199,
        "title": "Binary Tree Right Side View",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary tree, imagine yourself standing on the <i>right</i> side of it, return the values of the nodes you can see ordered from top to bottom.</p>\n\n    <p>\n        For example:<br>\n        Given the following binary tree,<br>\n    </p><pre>   1            &lt;---\n /   \\\n2     3         &lt;---\n \\     \\\n  5     4       &lt;---\n</pre>\n    <p></p>\n    <p>\n        You should return <code>[1, 3, 4]</code>.\n    </p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        if(root == null) return res;\n        Deque<TreeNode> cur = new ArrayDeque<TreeNode>();\n\n        cur.add(root);\n        while(!cur.isEmpty()){\n        \tres.add(cur.getLast().val);\n        \tDeque<TreeNode> next = new ArrayDeque<TreeNode>();\n        \twhile(!cur.isEmpty()){\n        \t\tTreeNode temp = cur.pop();\n        \t\tif(temp.left != null)\n        \t\t\tnext.add(temp.left);\n        \t\tif(temp.right != null)\n        \t\t\tnext.add(temp.right);\n        \t}\n        \tcur = next;\n        }\n\n        return res;\n    }\n}",
        "tags": "12, 14, 19",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 213,
        "number": 200,
        "title": "Number of Islands",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a 2d grid map of <code>'1'</code>s (land) and <code>'0'</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n    <p><i><b>Example 1:</b></i></p>\n    <pre>11110<br>11010<br>11000<br>00000</pre>\n    <p>Answer: 1</p>\n    <p><i><b>Example 2:</b></i></p>\n    <pre>11000<br>11000<br>00100<br>00011</pre>\n    <p>Answer: 3</p>\n\n</div>",
        "solution": "public class Solution {\n    class Point{\n        int row;\n        int col;\n        public Point(int x, int y){\n            this.row = x;\n            this.col = y;\n        }\n    }\n\n    public int numIslands(char[][] grid) {\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n        int rowNum = grid.length;\n        int colNum = grid[0].length;\n\n        int res = 0;\n        for(int row = 0; row < rowNum; row++){\n            for(int col = 0; col < colNum; col++){\n                if(grid[row][col] != '1')\n                    continue;\n                res++;\n                Deque<Point> queue = new ArrayDeque<Point>();\n                grid[row][col] = 'x';\n                queue.offerFirst(new Point(row, col));\n                while(!queue.isEmpty()){\n                    Point top = queue.pollLast();\n                    // go top, down, left, right\n                    if(top.row - 1 >= 0 && grid[top.row - 1][top.col] == '1'){\n                        grid[top.row - 1][top.col] = 'x';\n                        queue.offerFirst(new Point(top.row - 1, top.col));\n                    }\n                    if(top.row + 1 < rowNum && grid[top.row + 1][top.col] == '1'){\n                        grid[top.row + 1][top.col] = 'x';\n                        queue.offerFirst(new Point(top.row + 1, top.col));\n                    }\n                    if(top.col - 1 >= 0 && grid[top.row][top.col - 1] == '1'){\n                        grid[top.row][top.col - 1] = 'x';\n                        queue.offerFirst(new Point(top.row, top.col - 1));\n                    }\n                    if(top.col + 1 < colNum && grid[top.row][top.col + 1] == '1'){\n                        grid[top.row][top.col + 1] = 'x';\n                        queue.offerFirst(new Point(top.row, top.col + 1));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}",
        "tags": "14, 16, 19",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 214,
        "number": 201,
        "title": "Bitwise AND of Numbers Range",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>\n\n    <p>\n        For example, given the range [5, 7], you should return 4.\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    // The idea is to use a mask to find the leftmost common digits of m and n.\n    // Example: m=1110001, n=1110111, and you just need to find 1110000 and it will be the answer.\n    public int rangeBitwiseAnd(int m, int n) {\n        int r = Integer.MAX_VALUE;\n        while((m & r) != (n & r))\n            r = r << 1;\n        return n & r;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 215,
        "number": 207,
        "title": "Course Schedule",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    There are a total of <i>n</i> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>\n\n    <p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n\n    <p>\n        Given the total number of courses and a list of prerequisite <b>pairs</b>, is it possible for you to finish all courses?\n    </p>\n\n    <p>For example:</p>\n    <pre>2, [[1,0]]</pre>\n    <p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>\n\n    <pre>2, [[1,0],[0,1]]</pre>\n    <p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The input prerequisites is a graph represented by <b>a list of edges</b>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\">how a graph is represented</a>.</li>\n    <li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n    <p></p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show more hints.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Hints:</b>\n        <ol>\n            <li>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>\n            <li><a href=\"https://class.coursera.org/algo-003/lecture/52\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>\n            <li>Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>.</li>\n        </ol>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        ArrayList[] graph = new ArrayList[numCourses];\n        int[] indegree = new int[numCourses];\n        // 先初始化图，每个赋一个空列表\n        for(int i = 0; i < numCourses; i++){\n            graph[i] = new ArrayList<Integer>();\n        }\n        // 根据边建立图，并计算入度\n        for(int i = 0; i < prerequisites.length; i++){\n            graph[prerequisites[i][1]].add(prerequisites[i][0]);\n            indegree[prerequisites[i][0]]++;\n        }\n        // 找到有向图的入口\n        Queue<Integer> queue = new LinkedList<Integer>();\n        for(int i = 0; i < indegree.length; i++){\n            if(indegree[i] == 0){\n                queue.add(i);\n            }\n        }\n        // 按照拓扑排序的顺序，进行广度优先搜索\n        int cnt = 0;\n        while(!queue.isEmpty()){\n            Integer curr = queue.poll();\n            cnt++;\n            ArrayList<Integer> nexts = graph[curr];\n            for(int i = 0; i < nexts.size(); i++){\n                int next = nexts.get(i);\n                indegree[next]--;\n                if(indegree[next] == 0){\n                    queue.offer(next);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n}",
        "tags": "14, 19, 23, 24",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 216,
        "number": 208,
        "title": "Implement Trie (Prefix Tree)",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.\n</p>\n\n    <p>\n        <b>Note:</b><br>\n        You may assume that all inputs are consist of lowercase letters <code>a-z</code>.\n    </p><p></p>\n\n</div>",
        "solution": "public class Trie {\n\n    class TrieNode {\n        String word = \"\";\n        Map<Character, TrieNode> children = null;\n        public TrieNode(){\n            this.children = new HashMap<>();\n        }\n    }\n\n    TrieNode root;\n\n    /** Initialize your data structure here. */\n    public Trie() {\n        this.root = new TrieNode();\n    }\n\n    /** Inserts a word into the trie. */\n    public void insert(String word) {\n        TrieNode cur = root;\n        for(int i = 0; i < word.length(); i++){\n            char c = word.charAt(i);\n            if(!cur.children.containsKey(c)){\n                cur.children.put(c, new TrieNode());\n            }\n            cur = cur.children.get(c);\n        }\n        cur.word = word;\n    }\n\n    /** Returns if the word is in the trie. */\n    public boolean search(String word) {\n        TrieNode cur = root;\n        for(int i = 0; i < word.length(); i++){\n            char c = word.charAt(i);\n            if(cur.children.containsKey(c)){\n                cur = cur.children.get(c);\n            } else {\n                return false;\n            }\n        }\n        return cur.word.equals(word);\n    }\n\n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    public boolean startsWith(String prefix) {\n        TrieNode cur = root;\n        for(int i = 0; i < prefix.length(); i++){\n            char c = prefix.charAt(i);\n            if(cur.children.containsKey(c)){\n                cur = cur.children.get(c);\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */",
        "tags": "10, 11",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 217,
        "number": 209,
        "title": "Minimum Size Subarray Sum",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <b>contiguous</b> subarray of which the sum >= <strong>s</strong>. If there isn't one, return 0 instead.\n</p>\n    <p>\n        For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>\n        the subarray <code>[4,3]</code> has the minimal length under the problem constraint.\n    </p>\n\n    <div class=\"spoilers\"><b>More practice:</b>\n\n        <p>If you have figured out the <i>O</i>(<i>n</i>) solution, try coding another solution of which the time complexity is <i>O</i>(<i>n</i> log <i>n</i>).</p>\n    </div>\n\n</div>",
        "solution": "public class Solution {\n    public int minSubArrayLen(int s, int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums[0] >= s) return 1;\n\n        int index = 1, curSum = nums[0], startIndex = 0, minLen = 0;\n        while(index < nums.length){\n            if(nums[index] >= s) return 1;\n            curSum += nums[index];\n            if(curSum >= s){\n                while(startIndex < index && curSum - nums[startIndex] >= s){\n                    curSum -= nums[startIndex++];\n                }\n                if(minLen == 0 || index-startIndex < minLen)\n                    minLen = index-startIndex+1;\n            }\n            index++;\n        }\n        return minLen;\n    }\n}",
        "tags": "0, 4, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 218,
        "number": 210,
        "title": "Course Schedule II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    There are a total of <i>n</i> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>\n\n    <p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n\n    <p>\n        Given the total number of courses and a list of prerequisite <b>pairs</b>, return the ordering of courses you should take to finish all courses.</p>\n\n    <p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\n    </p>\n\n    <p>For example:</p>\n    <pre>2, [[1,0]]</pre>\n    <p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is <code>[0,1]</code></p>\n\n    <pre>4, [[1,0],[2,0],[3,1],[3,2]]</pre>\n    <p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is<code>[0,2,1,3]</code>.</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The input prerequisites is a graph represented by <b>a list of edges</b>, not adjacency matrices. Read more about <a href=\"https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs\" target=\"_blank\">how a graph is represented</a>.</li>\n    <li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n    <p></p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show more hints.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Hints:</b>\n        <ol>\n            <li>This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>\n            <li><a href=\"https://class.coursera.org/algo-003/lecture/52\" target=\"_blank\">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>\n            <li>Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>.</li>\n        </ol>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] res = new int[numCourses];\n        ArrayList<Integer>[] graph = new ArrayList[numCourses];\n        int[] indegree = new int[numCourses];\n        for(int i = 0; i < prerequisites.length; i++){\n            if(graph[prerequisites[i][1]] == null){\n                graph[prerequisites[i][1]] = new ArrayList<Integer>();\n            }\n            graph[prerequisites[i][1]].add(prerequisites[i][0]);\n            indegree[prerequisites[i][0]]++;\n        }\n        Queue<Integer> queue = new LinkedList<Integer>();\n        for(int i = 0; i < indegree.length; i++){\n            if(indegree[i] == 0){\n                queue.add(i);\n            }\n        }\n        // 用idx记录输出数组的下标\n        int idx = 0;\n        while(!queue.isEmpty()){\n            Integer curr = queue.poll();\n            res[idx++] = curr;\n            if(graph[curr] == null) continue;\n            for(Integer next : graph[curr]){\n                if(--indegree[next] == 0){\n                    queue.offer(next);\n                }\n            }\n        }\n        // 如果有环则返回空数组\n        return idx != numCourses ? new int[0] : res;\n    }\n}",
        "tags": "14, 19, 23, 24",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 219,
        "number": 211,
        "title": "Add and Search Word - Data structure design",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Design a data structure that supports the following two operations:\n</p>\n    <pre>void addWord(word)\nbool search(word)\n</pre>\n\n    <p>\n        search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p>\n\n    <p>\n        For example:</p>\n    <pre>addWord(\"bad\")\naddWord(\"dad\")\naddWord(\"mad\")\nsearch(\"pad\") -&gt; false\nsearch(\"bad\") -&gt; true\nsearch(\".ad\") -&gt; true\nsearch(\"b..\") -&gt; true\n</pre>\n\n    <p>\n        <b>Note:</b><br>\n        You may assume that all words are consist of lowercase letters <code>a-z</code>.\n    </p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show hint.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\">You should be familiar with how a Trie works. If not, please work on this problem: <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">Implement Trie (Prefix Tree)</a> first.\n    </div><p></p>\n\n\n</div>",
        "solution": "public class WordDictionary {\n    public class TrieNode {\n        public TrieNode[] children = new TrieNode[26];\n        public String item = \"\";\n    }\n\n    private TrieNode root = new TrieNode();\n\n    public void addWord(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            if (node.children[c - 'a'] == null) {\n                node.children[c - 'a'] = new TrieNode();\n            }\n            node = node.children[c - 'a'];\n        }\n        node.item = word;\n    }\n\n    public boolean search(String word) {\n        return match(word.toCharArray(), 0, root);\n    }\n\n    private boolean match(char[] chs, int k, TrieNode node) {\n        if (k == chs.length)\n            return !node.item.equals(\"\");\n\n        if (chs[k] != '.') {\n            return node.children[chs[k] - 'a'] != null &&\n                    match(chs, k + 1, node.children[chs[k] - 'a']);\n        }\n\n        for (int i = 0; i < node.children.length; i++) {\n            if (node.children[i] == null) continue;\n            if (match(chs, k + 1, node.children[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "tags": "8, 11, 12",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 220,
        "number": 213,
        "title": "House Robber II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p><b>Note:</b> This is an extension of <a href=\"https://leetcode.com/problems/house-robber/\">House Robber</a>.</p>\n\n    <p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. </p>\n\n    <p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>\n\n</div>",
        "solution": "public class Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0)\n\t\t\treturn 0;\n\t\tint n = nums.length;\n\t\tif (n == 1)\n\t\t\treturn nums[0];\n\t\tif (n == 2)\n\t\t\treturn Math.max(nums[1], nums[0]);\n\n\t\t// include 1st element, and not last element\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 0;\n\t\tdp[1] = nums[0];\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tdp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n\t\t}\n\n\t\t// not include frist element, and include last element\n\t\tint[] dr = new int[n + 1];\n\t\tdr[0] = 0;\n\t\tdr[1] = nums[1];\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tdr[i] = Math.max(dr[i - 1], dr[i - 2] + nums[i]);\n\t\t}\n\t\treturn Math.max(dp[n - 1], dr[n - 1]);\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 221,
        "number": 215,
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p>Find the <b>k</b>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\n    </p><p>For example,<br>\n    Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.\n</p>\n\n    <p><b>Note: </b><br>\n        You may assume k is always valid, 1 <= k <= array's length.</p>\n</div>",
        "solution": "public class Solution {\n    // Time complexity = O(n)\n    // Discard half each time: n+(n/2)+(n/4)..1 = n + (n-1) = O(2n-1) = O(n),\n    // because n/2+n/4+n/8+..1=n-1.\n    public int findKthLargest(int[] nums, int k) {\n\t\tif (nums == null || nums.length == 0)\n\t\t\treturn Integer.MAX_VALUE;\n\t\treturn findKthLargest(nums, 0, nums.length - 1, nums.length - k);\n\t}\n\n\t// quick select: kth smallest\n\tprivate int findKthLargest(int[] nums, int start, int end, int k) {\n\t\tif (start > end)\n\t\t\treturn Integer.MAX_VALUE;\n\n\t\tint pivot = nums[end];// Take A[end] as the pivot,\n\t\tint left = start;\n\t\tfor (int i = start; i < end; i++) {\n\t\t\tif (nums[i] <= pivot) // Put numbers < pivot to pivot's left\n\t\t\t\tswap(nums, left++, i);\n\t\t}\n\t\tswap(nums, left, end);// Finally, swap A[end] with A[left]\n\n\t\tif (left == k)// Found kth smallest number\n\t\t\treturn nums[left];\n\t\telse if (left < k)// Check right part\n\t\t\treturn findKthLargest(nums, left + 1, end, k);\n\t\telse // Check left part\n\t\t\treturn findKthLargest(nums, start, left - 1, k);\n\t}\n\n\tprivate void swap(int[] A, int i, int j) {\n\t\tint tmp = A[i];\n\t\tA[i] = A[j];\n\t\tA[j] = tmp;\n\t}\n}",
        "tags": "7, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 222,
        "number": 216,
        "title": "Combination Sum III",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><div>\n    <p>Find all possible combinations of <i><b>k</b></i> numbers that add up to a number <i><b>n</b></i>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>\n</div>\n    <div>\n        <br>\n        <p> <i><b>Example 1:</b></i></p>\n        <p>Input:  <i><b>k</b></i> = 3,  <i><b>n</b></i> = 7</p>\n        <p>Output: </p>\n        <p></p><pre>[[1,2,4]]\n</pre><p></p>\n        <br>\n        <p> <i><b>Example 2:</b></i></p>\n        <p>Input:  <i><b>k</b></i> = 3,  <i><b>n</b></i> = 9</p>\n        <p>Output: </p>\n        <p></p><pre>[[1,2,6], [1,3,5], [2,3,4]]\n</pre><p></p>\n\n\n</div>",
        "solution": "public class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> subComb = new ArrayList<>();\n        findComb(1, k, n, subComb, res);\n\n        return res;\n    }\n\n    private void findComb(int start, int k, int curSum,\n                          List<Integer> subComb, List<List<Integer>> res){\n        if(subComb.size() == k && curSum == 0){\n            List<Integer> temp = new ArrayList<>(subComb);\n            res.add(temp);\n        }\n\n        for(int i=start; i<=9; i++){\n            if(curSum - i < 0) return;\n            subComb.add(i);\n            findComb(i+1, k, curSum-i, subComb, res);\n            subComb.remove(subComb.size()-1);\n        }\n    }\n}",
        "tags": "0, 8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 223,
        "number": 217,
        "title": "Contains Duplicate",
        "difficulty": "Medium",
        "description": "Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.",
        "solution": "public class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        if(nums.length <= 1) return false;\n\n        Set<Integer> numSet = new HashSet<Integer>();\n        for(int i=0; i<nums.length; i++){\n            if(numSet.contains(nums[i])) return true;\n            numSet.add(nums[i]);\n        }\n        return false;\n    }\n}",
        "tags": "0, 1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 224,
        "number": 220,
        "title": "Contains Duplicate III",
        "difficulty": "Medium",
        "description": "Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.",
        "solution": "public class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (k < 1 || t < 0)  return false;\n\t    TreeSet<Integer> set = new TreeSet<Integer>();\n\n\t    for (int i = 0; i < nums.length; i++) {\n\t\t    int c = nums[i];\n\t\t    if ((set.floor(c) != null && c <= set.floor(c) + t)\n\t\t        || (set.ceiling(c) != null && c >= set.ceiling(c) -t))\n\t\t        return true;\n\t\t    set.add(c);\n\t\t    if (i >= k)\n\t\t\t    set.remove(nums[i - k]);\n\t    }\n\t    return false;\n    }\n}",
        "tags": "28",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 225,
        "number": 221,
        "title": "Maximal Square",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n</p>\n\n    <p>For example, given the following matrix:\n    </p><pre>1 0 1 0 0\n1 0 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\n1 1 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\n1 0 0 1 0\n</pre>\n    Return 4.\n\n</div>",
        "solution": "public class Solution {\n    public int maximalSquare(char[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\n\t\t    return 0;\n\n\t    int m = matrix.length;\n\t    int n = matrix[0].length;\n\t    int[][] t = new int[m][n];\n\n    \t//top row\n\t    for (int i = 0; i < m; i++) {\n\t\t    t[i][0] = Character.getNumericValue(matrix[i][0]);\n\t    }\n\t    //left column\n\t    for (int j = 0; j < n; j++) {\n\t\t    t[0][j] = Character.getNumericValue(matrix[0][j]);\n\t    }\n    \t//cells inside\n\t    for (int i = 1; i < m; i++) {\n\t\t    for (int j = 1; j < n; j++) {\n\t\t\t    if (matrix[i][j] == '1') {\n\t\t\t\t    int min = Math.min(t[i - 1][j], t[i - 1][j - 1]);\n\t\t\t\t    min = Math.min(min,t[i][j - 1]);\n\t\t\t\t    t[i][j] = min + 1;\n\t\t\t    } else {\n\t\t\t\t    t[i][j] = 0;\n\t\t\t    }\n\t\t    }\n\t    }\n\n\t    int max = 0;\n\t    //get maximal length\n\t    for (int i = 0; i < m; i++) {\n\t\t    for (int j = 0; j < n; j++) {\n\t\t\t    if (t[i][j] > max) {\n\t\t\t\t    max = t[i][j];\n\t\t\t    }\n\t\t    }\n\t    }\n\t    return max * max;\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 226,
        "number": 222,
        "title": "Count Complete Tree Nodes",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <b>complete</b> binary tree, count the number of nodes.</p>\n\n    <p><b><u>Definition of a complete binary tree from <a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a>:</u></b><br>\n        In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2<sup>h</sup> nodes inclusive at the last level h.</p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null)\n            return 0;\n\n        int left = getLeftHeight(root) + 1;\n        int right = getRightHeight(root) + 1;\n\n        if(left == right){\n            return (2 << (left-1)) - 1;\n        }\n        return countNodes(root.left) + countNodes(root.right) + 1;\n    }\n\n    private int getLeftHeight(TreeNode n){\n        if(n == null) return 0;\n        int height=0;\n        while(n.left!=null){\n            height++;\n            n = n.left;\n        }\n        return height;\n    }\n\n    private int getRightHeight(TreeNode n){\n        if(n == null) return 0;\n        int height=0;\n        while(n.right!=null){\n            height++;\n            n = n.right;\n        }\n        return height;\n    }\n\n    // Better Solution\n    public int countNodes(TreeNode root) {\n        if (root==null) return 0;\n        if (root.left==null) return 1;\n        int height = 0;\n        int nodesSum = 0;\n        TreeNode curr = root;\n        while(curr.left!=null) {\n            nodesSum += (1<<height);\n            height++;\n            curr = curr.left;\n        }\n        return nodesSum + countLastLevel(root, height);\n    }\n\n    private int countLastLevel(TreeNode root, int height) {\n        if(height == 1){\n            if (root.right!=null) return 2;\n            if (root.left!=null) return 1;\n            return 0;\n        }\n        TreeNode midNode = root.left;\n        int currHeight = 1;\n        while(currHeight<height) {\n            currHeight++;\n            midNode = midNode.right;\n        }\n        if (midNode==null)\n            return countLastLevel(root.left, height-1);\n        return (1<<(height-1)) + countLastLevel(root.right, height-1);\n    }\n}",
        "tags": "6, 12",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 227,
        "number": 223,
        "title": "Rectangle Area",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Find the total area covered by two <b>rectilinear</b> rectangles in a <b>2D</b> plane.</p>\n    <p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p>\n    <div style=\"width:529px; height:300px; background-color:rgb(235, 235, 235);\">\n        <img src=\"/static/images/problemset/rectangle_area.png\" border=\"0\" alt=\"Rectangle Area\">\n    </div>\n    <div style=\"padding-top:23px;\">\n        <p>Assume that the total area is never beyond the maximum possible value of <b>int</b>.</p>\n    </div>\n</div>",
        "solution": "public class Solution {\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n        if(C < E || G < A )\n            return (G-E)*(H-F) + (C-A)*(D-B);\n         if(D < F || H < B)\n            return (G-E)*(H-F) + (C-A)*(D-B);\n\n        int right = Math.min(C,G);\n        int left = Math.max(A,E);\n        int top = Math.min(H,D);\n        int bottom = Math.max(F,B);\n\n        return (G-E)*(H-F) + (C-A)*(D-B) - (right-left)*(top-bottom);\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 228,
        "number": 227,
        "title": "Basic Calculator II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement a basic calculator to evaluate a simple expression string.</p>\n\n    <p>The expression string contains only <b>non-negative</b> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces <code> </code>. The integer division should truncate toward zero.</p>\n\n    <p>You may assume that the given expression is always valid.</p>\n\n    <p>Some examples:<br>\n    </p><pre>\"3+2*2\" = 7\n\" 3/2 \" = 1\n\" 3+5 / 2 \" = 5\n</pre>\n    <p></p>\n\n    <p>\n        <b>Note:</b> <b>Do not</b> use the <code>eval</code> built-in library function.\n    </p>\n</div>",
        "solution": "public class Solution {\n    public int calculate(String s) {\n        s = s.trim();\n\t\tif (s.length() == 0) return 0;\n\t\tint curIndex = 0, total = 0, curNum = 0, sign = 1;\n\t\tif (s.charAt(0) == '+' || s.charAt(0) == '-')\n\t\t\tsign = s.charAt(0) == '+' ? 1 : -1;\n\n\t\twhile(curIndex < s.length()){\n\t\t\t// 1. if ' '\n\t\t\tif(s.charAt(curIndex) == ' '){\n\t\t\t\tcurIndex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 2. if current char is digit\n\t\t\tif(s.charAt(curIndex) - '0' >= 0 && s.charAt(curIndex) - '0' <= 9){\n\t\t\t\tcurNum = curNum*10 + s.charAt(curIndex) - '0';\n\t\t\t}\n\t\t\t// 3. if +/-\n\t\t\tif(s.charAt(curIndex) == '+' || s.charAt(curIndex) == '-'){\n\t\t\t\ttotal += sign*curNum;\n\t\t\t\tcurNum = 0;\n\t\t\t\tsign = s.charAt(curIndex) == '+' ? 1 : -1;\n\t\t\t}\n\t\t\t// 4. if * or /\n\t\t\tif(s.charAt(curIndex) == '*' || s.charAt(curIndex) == '/'){\n\t\t\t\t// Find next number\n\t\t\t\tint nextNum = 0, multipler = s.charAt(curIndex++);\n\t\t\t\twhile(curIndex < s.length() && (s.charAt(curIndex) == ' ' ||\n\t\t\t\t\t\t(s.charAt(curIndex) - '0' >= 0 && s.charAt(curIndex) - '0' <= 9))){\n\t\t\t\t\tif (s.charAt(curIndex) == ' '){\n\t\t\t\t\t\tcurIndex++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnextNum = nextNum*10 + s.charAt(curIndex++) - '0';\n\t\t\t\t}\n\t\t\t\tcurNum = (multipler == '*') ? curNum*nextNum : curNum/nextNum;\n\t\t\t\tcurIndex--;\n\t\t\t}\n\t\t\tcurIndex++;\n\t\t}\n\t\treturn total += sign*curNum;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 229,
        "number": 228,
        "title": "Summary Ranges",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a sorted integer array without duplicates, return the summary of its ranges.</p>\n\n    <p>\n        For example, given <code>[0,1,2,4,5,7]</code>, return <code>[\"0-&gt;2\",\"4-&gt;5\",\"7\"].</code>\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> res = new ArrayList<String>();\n        if(nums.length == 0) return res;\n        if(nums.length == 1){\n        \tres.add(String.valueOf(nums[0]));\n        \treturn res;\n        }\n\n        List<Integer> continueNums = new ArrayList<Integer>();\n        continueNums.add(nums[0]);\n        for(int i=1; i<nums.length; i++){\n            if(nums[i-1]+1 == nums[i])\n            \tcontinueNums.add(nums[i]);\n            else{\n            \tif(continueNums.size()==1)\n            \t\tres.add(continueNums.get(0).toString());\n            \telse{\n            \t\tres.add(continueNums.get(0) + \"->\" +\n            \t\t    continueNums.get(continueNums.size()-1));\n            \t}\n            \tcontinueNums = new ArrayList<Integer>();\n        \t\tcontinueNums.add(nums[i]);\n            }\n        }\n\n        if(continueNums.size()==1)\n    \t\tres.add(continueNums.get(0).toString());\n    \telse{\n    \t\tres.add(continueNums.get(0) + \"->\" +\n    \t\t    continueNums.get(continueNums.size()-1));\n    \t}\n        return res;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 230,
        "number": 229,
        "title": "Majority Element II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer array of size <i>n</i>, find all elements that appear more than <code>|_n/3_|</code> times. The algorithm should run in linear time and in O(1) space.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        if (nums == null || nums.length == 0)\n\t\treturn new ArrayList<Integer>();\n\t    List<Integer> result = new ArrayList<Integer>();\n\t    int number1 = nums[0], number2 = nums[0];\n\t    int count1 = 0, count2 = 0, len = nums.length;\n\t    for (int i = 0; i < len; i++) {\n\t\t    if (nums[i] == number1)\n\t\t\t    count1++;\n\t\t    else if (nums[i] == number2)\n\t\t\t    count2++;\n\t\t    else if (count1 == 0) {\n\t\t\t    number1 = nums[i];\n\t\t\t    count1 = 1;\n\t\t    } else if (count2 == 0) {\n\t\t\t    number2 = nums[i];\n\t\t\t    count2 = 1;\n\t\t    } else {\n\t\t\t    count1--;\n\t\t\t    count2--;\n\t\t    }\n\t    }\n\t    count1 = 0;\n\t    count2 = 0;\n\t    for (int i = 0; i < len; i++) {\n\t\t    if (nums[i] == number1)\n\t\t\t    count1++;\n\t\t    else if (nums[i] == number2)\n\t\t\t    count2++;\n\t    }\n\t    if (count1 > len / 3)\n\t\t    result.add(number1);\n\t    if (count2 > len / 3)\n\t\t    result.add(number2);\n\t    return result;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 231,
        "number": 230,
        "title": "Kth Smallest Element in a BST",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <b>k</b>th smallest element in it.</p>\n\n    <p><b>Note: </b><br>\n        You may assume k is always valid, 1 ? k ? BST's total elements.</p>\n\n    <p><b>Follow up:</b><br>\n        What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        // if(root == null || k < 1) return -1;\n        int count = countNodes(root.left);\n        if (k <= count) {\n            return kthSmallest(root.left, k);\n        } else if (k > count + 1) { // 1 is counted as current node\n            return kthSmallest(root.right, k-1-count);\n        }\n        return root.val;\n    }\n\n    public int countNodes(TreeNode root){\n        if(root == null) return 0;\n        return 1 + countNodes(root.left) + countNodes(root.right);\n    }\n}",
        "tags": "6, 12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 232,
        "number": 236,
        "title": "Lowest Common Ancestor of a Binary Tree",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n</p>\n\n    <pre>        _______3______\n       /              \\\n    ___5__          ___1__\n   /      \\        /      \\\n   6      _2       0       8\n         /  \\\n         7   4\n</pre>\n\n    <p>\n        For example, the lowest common ancestor (LCA) of nodes <code>5</code> and <code>1</code> is <code>3</code>. Another example is LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.</p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    //To calculate time complexity,\n    //  f(n)=2*f(n-1)=2*2*f(n-2)=2^(logn), so time=O(n).\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n        if(left == null)\n            return right;\n        if(right == null)\n            return left;\n        return root;\n    }\n}",
        "tags": "12",
        "companies": "",
        "specialtags": "2"
    },
    {
        "id": 233,
        "number": 238,
        "title": "Product of Array Except Self",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>\n        Given an array of <i>n</i> integers where <i>n</i> &gt; 1, <code>nums</code>, return an array <code>output</code>        such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>\n\n    <p>Solve it <b>without division</b> and in O(<i>n</i>).</p>\n\n    <p>For example, given <code>[1,2,3,4]</code>, return <code>[24,12,8,6]</code>.\n\n    </p>\n    <p><b>Follow up:</b><br> Could you solve it with constant space complexity? (Note: The output array <b>does not</b> count\n        as extra space for the purpose of space complexity analysis.)</p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] result = new int[nums.length];\n        \n        result[0] = nums[0];\n        for(int i=1; i<nums.length; i++)\n            result[i] = result[i-1]*nums[i];\n        \n        for(int i=nums.length-2; i>-1; i--)\n            nums[i] = nums[i+1]*nums[i];\n        \n        result[nums.length-1] = result[nums.length-2];\n        for(int i=nums.length-2; i>0; i--){\n            result[i] = result[i-1]*nums[i+1];\n        }\n        result[0] = nums[1];\n        return result;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 234,
        "number": 240,
        "title": "Search a 2D Matrix II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>Write an efficient algorithm that searches for a value in an <i>m</i> x <i>n</i> matrix. This matrix has the following\n        properties:</p>\n\n    <p>\n    </p>\n    <ul>\n        <li>Integers in each row are sorted in ascending from left to right.</li>\n        <li>Integers in each column are sorted in ascending from top to bottom.</li>\n    </ul>\n    <p></p>\n\n    <p>\n        For example,</p>\n    <p>\n        Consider the following matrix:\n    </p>\n    <pre>[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n</pre>\n\n    <p>Given <b>target</b> = <code>5</code>, return <code>true</code>.</p>\n    <p>Given <b>target</b> = <code>20</code>, return <code>false</code>.</p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    /*\n     * We start search the matrix from top right corner, \n     * initialize the current position to top right corner, \n     * if the target is greater than the value in current position, \n     * then the target can not be in entire row of current position because \n     * the row is sorted, if the target is less than the value in current position, \n     * then the target can not in the entire column because the column is sorted too. \n     * We can rule out one row or one column each time, \n     * so the time complexity is O(m+n).\n     *\n    */\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if(matrix == null || matrix.length < 1 || matrix[0].length <1) {\n            return false;\n        }\n        int col = matrix[0].length-1;\n        int row = 0;\n        while(col >= 0 && row <= matrix.length-1) {\n            if(target == matrix[row][col]) {\n                return true;\n            } else if(target < matrix[row][col]) {\n                col--;\n            } else if(target > matrix[row][col]) {\n                row++;\n            }\n        }\n        return false;\n    }\n}",
        "tags": "6, 7",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 235,
        "number": 241,
        "title": "Different Ways to Add Parentheses",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to\n        group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>\n    <br>\n    <b>Example 1</b>\n    <p>Input: <code>\"2-1-1\"</code>.</p>\n    <pre>((2-1)-1) = 0\n(2-(1-1)) = 2</pre>\n    <p>Output: <code>[0, 2]</code></p>\n    <br>\n    <b>Example 2</b>\n    <p>Input: <code>\"2*3-4*5\"</code></p>\n    <pre>(2*(3-(4*5))) = -34\n((2*3)-(4*5)) = -14\n((2*(3-4))*5) = -10\n(2*((3-4)*5)) = -10\n(((2*3)-4)*5) = 10</pre>\n    <p>Output: <code>[-34, -14, -10, -10, 10]</code></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> diffWaysToCompute(String input) {\n        List<Integer> res = new ArrayList<Integer>();\n        for(int i=0; i<input.length(); i++){\n            if(!Character.isDigit(input.charAt(i))){\n                String part1 = input.substring(0, i);\n                String part2 = input.substring(i+1);\n                List<Integer> part1Vals = diffWaysToCompute(part1);\n                List<Integer> part2Vals = diffWaysToCompute(part2);\n                for(int j = 0; j < part1Vals.size(); j++){\n                    for(int k = 0; k < part2Vals.size(); k++){\n                        switch(input.charAt(i)){\n                            case '-':\n                                res.add(part1Vals.get(j) - part2Vals.get(k));\n                                break;\n                            case '+':\n                                res.add(part1Vals.get(j) + part2Vals.get(k));\n                                break;\n                            case '*':\n                                res.add(part1Vals.get(j) * part2Vals.get(k));\n                                break;\n                        }\n                    }\n                }\n            } \n        }\n        if(res.size() == 0){\n            res.add(Integer.parseInt(input));\n        }\n        return res;\n    }\n}",
        "tags": "7",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 236,
        "number": 247,
        "title": "Strobogrammatic Number II",
        "difficulty": "Medium",
        "description": "<blockquote>\n    <p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>\n    <p>Find all strobogrammatic numbers that are of length = n.</p>\n    <p>For example, Given n = 2, return <code>[\"11\",\"69\",\"88\",\"96\"]</code>.</p>\n</blockquote>",
        "solution": "public class Solution {\n    public List<String> findStrobogrammatic(int n) {\n        List<String> res = new ArrayList<>();\n        if(n == 0) return res;\n        if(n % 2 == 1){\n            res.add(\"0\");\n            res.add(\"1\");\n            res.add(\"8\");\n        }\n        for(int i = (n % 2) + 2; i <= n; i++){\n            List<String> temp = new ArrayList<>();\n            for(String s : res){\n                temp.add(\"1\" + s + \"1\");\n                temp.add(\"6\" + s + \"9\");\n                temp.add(\"9\" + s + \"6\");\n                temp.add(\"8\" + s + \"8\");\n            }\n            res = temp;\n        }\n        return res;\n    }\n}",
        "tags": "5",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 237,
        "number": 253,
        "title": "Meeting Rooms II",
        "difficulty": "Medium",
        "description": "<p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...]\n    find the minimum number of conference rooms required.</p>",
        "solution": "public class Solution {\n    public int minMeetingRooms(Interval[] intervals) {\n        if (intervals == null || intervals.length == 0)\n            return 0;\n\n        Arrays.sort(intervals, new Comparator<Interval>() {\n            public int compare(Interval i1, Interval i2) {\n                return i1.start - i2.start;\n            }\n        });\n\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        int count = 1;\n        queue.offer(intervals[0].end);\n\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i].start < queue.peek()) {\n                count++;\n            } else {\n                queue.poll();\n            }\n            queue.offer(intervals[i].end);\n        }\n        return count;\n    }\n}",
        "tags": "5",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 238,
        "number": 260,
        "title": "Single Number III",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p>\n        <p>\n                Given an array of numbers <code>nums</code>, in which exactly two elements appear only once and all the other\n                elements appear exactly twice. Find the two elements that appear only once.\n        </p>\n        <p>\n                For example:\n        </p>\n        <p>\n                Given <code>nums = [1, 2, 1, 3, 2, 5]</code>, return <code>[3, 5]</code>.\n        </p>\n        <p>\n                <b>Note</b>:<br>\n        </p>\n        <ol>\n                <li>The order of the result is not important. So in the above example, <code>[5, 3]</code> is also correct.</li>\n                <li>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space\n                        complexity?</li>\n        </ol>\n        <p></p>\n</div>\n        ",
        "solution": "public class Solution {\n    public int[] singleNumber(int[] nums) {\n        int A = 0;\n        int B = 0;\n        int AXORB = 0;\n        for(int i = 0; i<nums.length; i++){\n            AXORB ^= nums[i];\n        }\n        \n        // AXORB = (AXORB & (AXORB - 1)) ^ AXORB; //find the different bit\n        int lowBit = AXORB & -AXORB;\n        for(int i = 0; i<nums.length; i++){\n            if((lowBit & nums[i]) == 0)\n                A ^= nums[i];\n            else\n                B ^= nums[i];\n        }\n        return new int[]{A, B};\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 239,
        "number": 264,
        "title": "Ugly Number II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n      <p></p>\n      <p>\n            Write a program to find the <code>n</code>-th ugly number.\n      </p>\n\n      <p>\n            Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code>            is the sequence of the first <code>10</code> ugly numbers.\n      </p>\n\n      <p>\n            Note that <code>1</code> is typically treated as an ugly number, and <i>n</i> <b>does not exceed 1690</b>.\n      </p>\n</div>",
        "solution": "public class Solution {\n    public int nthUglyNumber(int n) {\n        if(n == 0 || n == 1) return n;\n        \n        int h = 1;\n        Deque<Integer> d2 = new ArrayDeque<Integer>();\n        Deque<Integer> d3 = new ArrayDeque<Integer>();\n        Deque<Integer> d5 = new ArrayDeque<Integer>();\n        \n        for(int i=0; i<n-1; i++){\n            d2.offer(2 * h);\n            d3.offer(3 * h);\n            d5.offer(5 * h);\n            h = Math.min(Math.min(d2.peek(), d3.peek()), d5.peek());\n            if(h == d2.peek())\n                d2.poll();\n            if(h == d3.peek())\n                d3.poll();\n            if(h == d5.peek())\n                d5.poll();\n        }\n        return h;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 240,
        "number": 274,
        "title": "H-Index",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>\n        Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's\n        h-index.\n    </p>\n\n    <p>\n        According to the definition of h-index on Wikipedia:\n        \"A scientist has index <i>h</i> if <i>h</i> of his/her <i>N</i> papers have <b>at least</b> <i>h</i> citations each,\n        and the other <i>N − h</i> papers have <b>no more than</b> <i>h</i> citations each.\"\n    </p>\n\n    <p>\n        For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers\n        in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has\n        <code>3</code> papers with <b>at least</b> <code>3</code> citations each and the remaining two with <b>no more than</b>        <code>3</code> citations each, his h-index is <code>3</code>.\n    </p>\n\n    <p>\n        <b>Note</b>: If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    public int hIndex(int[] citations) {\n        if (citations.length == 0)\n\t\t\treturn 0;\n\t\tif (citations.length == 1)\n\t\t\treturn citations[0] > 0 ? 1 : 0;\n\n\t\t// Map for citations numbers with paper count\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint currentHIdex = 0, resHIndex;\n\t\tfor (int c : citations) {\n\t\t\tif (c == 0)\n\t\t\t\tcontinue;\n\t\t\tif (map.containsKey(c))\n\t\t\t\tmap.put(c, map.get(c) + 1);\n\t\t\telse\n\t\t\t\tmap.put(c, 1);\n\t\t}\n\n\t\tif (map.size() == 0)\n\t\t\treturn 0;\n\t\tint[] uniqueCitations = new int[map.size()];\n\t\tint index = 0;\n\t\tfor (int i : map.keySet()) {\n\t\t\tuniqueCitations[index++] = i;\n\t\t}\n\t\tArrays.sort(uniqueCitations);\n\n\t\tif (uniqueCitations[uniqueCitations.length - 1] <= \n\t\t    map.get(uniqueCitations[uniqueCitations.length - 1]))\n\t\t\treturn uniqueCitations[uniqueCitations.length - 1];\n\t\tresHIndex = currentHIdex = map.get(uniqueCitations[uniqueCitations.length - 1]);\n\t\tfor (int i = uniqueCitations.length - 2; i >= 0; i--) {\n\t\t\tmap.put(uniqueCitations[i], \n\t\t\t    map.get(uniqueCitations[i]) + map.get(uniqueCitations[i + 1]));\n\t\t\tcurrentHIdex = uniqueCitations[i] <= map.get(uniqueCitations[i]) ? \n\t\t\t    uniqueCitations[i] : map.get(uniqueCitations[i]);\n\t\t\tresHIndex = currentHIdex > resHIndex ? currentHIdex : resHIndex;\n\t\t}\n\t\treturn resHIndex;\n    }\n}",
        "tags": "1, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 241,
        "number": 275,
        "title": "H-Index II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n<b>Follow up</b> for <a href=\"/problems/h-index/\" target=\"_blank\">H-Index</a>: What if the <code>citations</code> array is sorted in ascending order? Could you optimize your algorithm?\n</p><p></p>\n      </div>",
        "solution": "public class Solution {\n    public int hIndex(int[] citations) {\n        int res = 0, len = citations.length;\n\t\tif(len == 0 || citations[len-1] == 0) return res;\n\t\tif(len == 1) return 1;\n\t\t\n\t\tint start = 0, end = len-1, mid = (end-start)/2 + start;\t\t\t\t\n\t\twhile(start <= end){\n\t\t\tif(citations[mid] == len - mid)\treturn citations[mid];\n\t\t\t\n\t\t\tif(citations[mid] < len - mid)\n\t\t\t\tstart = mid+1;\n\t\t\telse\n\t\t\t\tend = mid-1;\n\t\t\tmid = (end-start)/2 + start;\n\t\t}\t\t\t\t\n\t\treturn len - end -1;\n    }\n}",
        "tags": "6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 242,
        "number": 279,
        "title": "Perfect Squares",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven a positive integer <i>n</i>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <i>n</i>.\n</p>\n\n<p>\nFor example, given <i>n</i> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <i>n</i> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public int numSquares(int n) {\n        if(n <= 1) return 1;\n        int[] dpArray = new int[n+1];\n        dpArray[1] = 1;\n        for(int i=2; i<n+1; i++){\n            int sqareRoot = (int)Math.sqrt(i);\n            if(sqareRoot*sqareRoot == i){\n                dpArray[i] = 1;\n                continue;\n            }\n                \n            int minNumSquares = Integer.MAX_VALUE;\n            int scanTo = (i % 2) == 0 ? i/2 : i/2 +1;\n            for(int j=1; j<scanTo+1; j++){\n                minNumSquares = (dpArray[i-j] + dpArray[j]) < minNumSquares ? \n                    (dpArray[i-j] + dpArray[j]) : minNumSquares;\n            }\n            dpArray[i] = minNumSquares;\n        }\n        return dpArray[n];\n    }\n}",
        "tags": "3, 9, 19",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 243,
        "number": 280,
        "title": "Wiggle Sort",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given an unsorted array <code>nums</code>, reorder it such that\n    <code>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]...</code>.\n</p>\n\n<p>\n    <b>Example:</b><br>\n    (1) Given <code>nums = [3, 5, 2, 1, 6, 4]</code>, one possible answer is <code>[1, 6, 2, 5, 3, 4]</code>.\n</p>\n\n<p>\n    <b>Note:</b><br>\n    You may assume all input has valid answer.\n</p>\n\n<p>\n    <b>Follow Up:</b><br>\n    Can you do it in O(n) time and/or in-place with O(1) extra space?\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    // Solution 1: sort first \n    // Time Complexity: O(NlogN)\n    // Space Complexity: O(1)\n    public void wiggleSort(int[] nums) {\n        // Sort first\n        Arrays.sort(nums);\n        // Swap in pair\n        for(int i = 2; i < nums.length; i+=2){\n            int tmp = nums[i-1];\n            nums[i-1] = nums[i];\n            nums[i] = tmp;\n        }\n    }\n\n    // Solution 2: Swap if any of following conditions are true:\n    // 1. Odd index and nums[i] < nums[i - 1]\n    // 2. Even index and nums[i] > nums[i - 1]\n    // Time: O(N); Space: O(1)\n    public void wiggleSort(int[] nums) {\n        for(int i = 1; i < nums.length; i++){\n            if((i % 2 == 1 && nums[i] < nums[i-1]) || \n                (i % 2 == 0 && nums[i] > nums[i-1])){\n                int tmp = nums[i-1];\n                nums[i-1] = nums[i];\n                nums[i] = tmp;\n            }\n        }\n    }\n}\n",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 244,
        "number": 284,
        "title": "Peeking Iterator",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given an Iterator class interface with methods: <code>next()</code> and <code>hasNext()</code>, design and implement a PeekingIterator that support the <code>peek()</code> operation -- it essentially peek() at the element that will be returned by the next call to next().</p>\n\n<hr>\n<p>Here is an example. Assume that the iterator is initialized to the beginning of the list: <code>[1, 2, 3]</code>.</p>\n\n<p>Call <code>next()</code> gets you 1, the first element in the list.</p>\n\n<p>Now you call <code>peek()</code> and it returns 2, the next element. Calling <code>next()</code> after that <i><b>still</b></i> return 2.</p>\n\n<p>You call <code>next()</code> the final time and it returns 3, the last element. Calling <code>hasNext()</code> after that should return false.</p>\n\n<p>\n<b>Follow up</b>: How would you extend your design to be generic and work with all types, not just integer?</p>\n\n      </div>",
        "solution": "// Java Iterator interface reference:\n// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\nclass PeekingIterator implements Iterator<Integer> {\n\n    private final Iterator<Integer> iterator;\n    private boolean hasPeeked;\n    private Integer peekedElement;\n    \n\tpublic PeekingIterator(Iterator<Integer> iterator) {\n\t    // initialize any member here.\n\t    this.iterator = iterator;\n\t}\n\n    // Returns the next element in the iteration without advancing the iterator.\n\tpublic Integer peek() {\n        if (!hasPeeked) {\n            peekedElement = iterator.next();\n            hasPeeked = true;\n        }\n        return peekedElement;\n\t}\n\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\t@Override\n\tpublic Integer next() {\n\t    if (!hasPeeked) {\n            return iterator.next();\n        }\n        Integer result = peekedElement;\n        hasPeeked = false;\n        peekedElement = null;\n        return result;\n\t}\n\n\t@Override\n\tpublic boolean hasNext() {\n\t    return hasPeeked || iterator.hasNext();\n\t}\n}",
        "tags": "10",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 245,
        "number": 285,
        "title": "Inorder Successor in BST",
        "difficulty": "Medium",
        "description": "<p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>>",
        "solution": "public class Solution {\n    class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n    }\n\n    /**\n     * Time is O(log(n)) and space is O(1).\n     * @param root\n     * @param p\n     * @return\n     */\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        if (root == null)\n            return null;\n\n        // Try to find the node p and track node larger than it\n        TreeNode next = null;\n        TreeNode c = root;\n        while (c != null && c.val != p.val) {\n            if (c.val > p.val) {\n                next = c;\n                c = c.left;\n            } else {\n                c = c.right;\n            }\n        }\n\n        // Node not found\n        if (c == null)\n            return null;\n        // Node don't has right child\n        if (c.right == null)\n            return next;\n        // Return left most node of right child\n        c = c.right;\n        while (c.left != null)\n            c = c.left;\n\n        return c;\n    }\n}",
        "tags": "12",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 246,
        "number": 287,
        "title": "Find the Duplicate Number",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven an array <i>nums</i> containing <i>n</i> + 1 integers where each integer is between 1 and <i>n</i> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n</p>\n\n<p>\n<b>Note:</b><br>\n</p><ol>\n<li>You <b>must not</b> modify the array (assume the array is read only).</li>\n<li>You must use only constant, <i>O</i>(1) extra space.</li>\n<li>Your runtime complexity should be less than <code>O(n<sup>2</sup>)</code>.</li>\n<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\n</ol>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    // https://segmentfault.com/a/1190000003817671\n    public int findDuplicate(int[] nums) {\n        int slow = 0;\n        int fast = 0;\n        // Find where the slow pointer meet fast pointer\n        do{\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while(slow != fast);\n        \n        // Use a new pointer to start from begining until\n        // it meet with the slow pointer\n        int find = 0;\n        while(find != slow){\n            slow = nums[slow];\n            find = nums[find];\n        }\n        return find;\n    }\n}",
        "tags": "0, 4, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 247,
        "number": 289,
        "title": "Game of Life",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nAccording to the <a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\" target=\"_blank\">Wikipedia's article</a>: \"The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n</p>\n\n<p>\nGiven a <i>board</i> with <i>m</i> by <i>n</i> cells, each cell has an initial state <i>live</i> (1) or <i>dead</i> (0). Each cell interacts with its <a href=\"https://en.wikipedia.org/wiki/Moore_neighborhood\" target=\"_blank\">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n</p>\n\n<p>\n</p><ol>\n<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>\n<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\n<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>\n<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\n</ol>\n<p></p>\n\n<p>\nWrite a function to compute the next state (after one update) of the board given its current state.</p>\n\n<p>\n<b>Follow up</b>: <br>\n</p><ol>\n<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>\n<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>\n</ol>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    public void gameOfLife(int[][] board) {\n\t\tif (board == null || board.length == 0)\n\t\t\treturn;\n\t\tint m = board.length, n = board[0].length;\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint lives = liveNeighbors(board, m, n, i, j);\n\n\t\t\t\t// In the beginning, every 2nd bit is 0;\n\t\t\t\t// So we only need to care about when the 2nd bit will become 1.\n\t\t\t\tif (board[i][j] == 1 && lives >= 2 && lives <= 3) {\n\t\t\t\t\tboard[i][j] = 3; // Make the 2nd bit 1: 01 ---> 11\n\t\t\t\t}\n\t\t\t\tif (board[i][j] == 0 && lives == 3) {\n\t\t\t\t\tboard[i][j] = 2; // Make the 2nd bit 1: 00 ---> 10\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tboard[i][j] >>= 1; // Get the 2nd state.\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int liveNeighbors(int[][] board, int m, int n, int i, int j) {\n\t\tint lives = 0;\n\t\tfor (int x = Math.max(i - 1, 0); x <= Math.min(i + 1, m - 1); x++) {\n\t\t\tfor (int y = Math.max(j - 1, 0); y <= Math.min(j + 1, n - 1); y++) {\n\t\t\t\tlives += board[x][y] & 1;\n\t\t\t}\n\t\t}\n\t\tlives -= board[i][j] & 1;\n\t\treturn lives;\n\t}\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 248,
        "number": 299,
        "title": "Bulls and Cows",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>You are playing the following <a href=\"https://en.wikipedia.org/wiki/Bulls_and_Cows\" target=\"_blank\">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.</p>\n\n<p>\nFor example:\n</p><pre>Secret number:  \"1807\"\nFriend's guess: \"7810\"\n</pre>\nHint: <code>1</code> bull and <code>3</code> cows. (The bull is <code>8</code>, the cows are <code>0</code>, <code>1</code> and <code>7</code>.)\n<p></p>\n\n<p>Write a function to return a hint according to the secret number and friend's guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows. In the above example, your function should return <code>\"1A3B\"</code>. </p>\n\n<p>Please note that both secret number and friend's guess may contain duplicate digits, for example:\n</p><pre>Secret number:  \"1123\"\nFriend's guess: \"0111\"\n</pre>\nIn this case, the 1st <code>1</code> in friend's guess is a bull, the 2nd or 3rd <code>1</code> is a cow, and your function should return <code>\"1A1B\"</code>.\n<p></p>\n\n<p>You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.</p>\n\n      </div>",
        "solution": "public class Solution {\n    public String getHint(String secret, String guess) {\n        int bull, cow;\n        bull = cow = 0;\n\n        //store the digits of secrete\n        int[] counter_secret = new int[10]; \n        //store the digits of guess\n        int[] counter_guess = new int[10]; \n\n        int L = secret.length();\n        for(int i=0; i<L; i++) {\n            counter_secret[secret.charAt(i)-'0']++;\n            // if meets a bull, secrete counter should not change\n            if(secret.charAt(i)==guess.charAt(i)) {\n                bull++;\n                counter_secret[secret.charAt(i)-'0']--;\n            } else {\n                counter_guess[guess.charAt(i)-'0']++;\n            }\n        }\n\n        // check the two arrays item by item and sum up the cows\n        for(int i = 0; i <= 9; i++) {\n            cow += counter_secret[i] >= counter_guess[i] ? \n            counter_guess[i]:counter_secret[i];\n        } \n        return bull + \"A\" + cow + \"B\";\n    }\n}",
        "tags": "1",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 249,
        "number": 300,
        "title": "Longest Increasing Subsequence",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\n</p>\n<p>\nFor example,<br>\nGiven <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>\nThe longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n</p>\n<p>\nYour algorithm should run in O(<i>n<sup>2</sup></i>) complexity.\n</p>\n\n<p><b>Follow up:</b> Could you improve it to O(<i>n</i> log <i>n</i>) time complexity? </p>\n\n      </div>",
        "solution": "public class Solution {\n    public int lengthOfLIS(int[] nums) {\n        if(nums==null || nums.length==0) return 0;\n        List<Integer> list = new ArrayList<>();\n\n        for(int num : nums){\n            // if(list.size() == 0 or num > last element in list)\n            if(list.size() == 0 || num > list.get(list.size()-1)){\n                list.add(num);\n                continue;\n            }\n            // replace element which is the smallest but bigger than num\n            int i = 0, j = list.size() - 1;\n            while(i < j){\n                int mid = i + (j - i)/2;\n                if(list.get(mid) < num){\n                    i = mid + 1;\n                } else {\n                    j = mid;\n                }\n            }\n            list.set(j, num);\n        }\n        return list.size();\n    }\n}",
        "tags": "6, 9",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 250,
        "number": 304,
        "title": "Range Sum Query 2D - Immutable",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a 2D matrix <i>matrix</i>, find the sum of the elements inside the rectangle defined by its upper left corner (<i>row</i>1, <i>col</i>1) and lower right corner (<i>row</i>2, <i>col</i>2).</p>\n\n<p>\n<img src=\"/static/images/courses/range_sum_query_2d.png\" border=\"0\" alt=\"Range Sum Query 2D\"><br>\n<small>The above rectangle (with the red border) is defined by (row1, col1) = <b>(2, 1)</b> and (row2, col2) = <b>(4, 3)</b>, which contains sum = <b>8</b>.</small>\n</p>\n\n<p><b>Example:</b><br>\n</p><pre>Given matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n  [4, 1, 0, 1, 7],\n  [1, 0, 3, 0, 5]\n]\n\nsumRegion(2, 1, 4, 3) -&gt; 8\nsumRegion(1, 1, 2, 2) -&gt; 11\nsumRegion(1, 2, 2, 4) -&gt; 12\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume that the matrix does not change.</li>\n<li>There are many calls to <i>sumRegion</i> function.</li>\n<li>You may assume that <i>row</i>1 ≤ <i>row</i>2 and <i>col</i>1 ≤ <i>col</i>2.</li>\n</ol>\n<p></p><p></p>\n      </div>",
        "solution": "public class NumMatrix {\n    private int[][] matrix;\n    private int[][] sum;\n\n    public NumMatrix(int[][] matrix) {\n        this.matrix = matrix;\n         \n        if (matrix == null || matrix.length == 0) {\n            return;\n        }\n         \n        int m = matrix.length;\n        int n = matrix[0].length;\n         \n        sum = new int[m + 1][n + 1];\n         \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - \n                            sum[i - 1][j - 1] + matrix[i - 1][j - 1];\n            }\n        }\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return sum[row2 + 1][col2 + 1] - sum[row2 + 1][col1] - \n               sum[row1][col2 + 1] + sum[row1][col1];\n    }\n}\n\n\n// Your NumMatrix object will be instantiated and called as such:\n// NumMatrix numMatrix = new NumMatrix(matrix);\n// numMatrix.sumRegion(0, 1, 2, 3);\n// numMatrix.sumRegion(1, 2, 3, 4);",
        "tags": "9",
        "companies": "",
        "specialtags": "2"
    },
    {
        "id": 251,
        "number": 306,
        "title": "Additive Number",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Additive number is a string whose digits can form additive sequence.</p>\n\n<p>A valid additive sequence should contain <b>at least</b> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>\n\n<p>\nFor example:<br>\n<code>\"112358\"</code> is an additive number because the digits can form an additive sequence: <code>1, 1, 2, 3, 5, 8</code>.\n</p><pre>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</pre>\n<code>\"199100199\"</code> is also an additive number, the additive sequence is: <code>1, 99, 100, 199</code>.\n<pre>1 + 99 = 100, 99 + 100 = 199</pre>\n<p></p>\n\n<p>\n<b>Note:</b> Numbers in the additive sequence <b>cannot</b> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.\n</p>\n\n<p>Given a string containing only digits <code>'0'-'9'</code>, write a function to determine if it's an additive number.</p>\n\n<p>\n<b>Follow up:</b><br>\nHow would you handle overflow for very large input integers?\n</p>\n\n      </div>",
        "solution": "import java.math.BigInteger;\n\npublic class Solution {\n    public boolean isAdditiveNumber(String num) {\n        int n = num.length();\n        for (int i = 1; i <= n / 2; ++i)\n            for (int j = 1; Math.max(j, i) <= n - i - j; ++j)\n                if (isValid(i, j, num)) return true;\n        return false;\n    }\n    private boolean isValid(int i, int j, String num) {\n        if (num.charAt(0) == '0' && i > 1) return false;\n        if (num.charAt(i) == '0' && j > 1) return false;\n        String sum;\n        Long x1 = Long.parseLong(num.substring(0, i));\n        Long x2 = Long.parseLong(num.substring(i, i + j));\n        for (int start = i + j; start != num.length(); start += sum.length()) {\n            x2 = x2 + x1;\n            x1 = x2 - x1;\n            sum = x2.toString();\n            if (!num.startsWith(sum, start)) return false;\n        }\n        return true;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 252,
        "number": 307,
        "title": "Range Sum Query - Mutable",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given an integer array <i>nums</i>, find the sum of the elements between indices <i>i</i> and <i>j</i> (<i>i</i> ≤ <i>j</i>), inclusive.</p>\n\nThe <i>update(i, val)</i> function modifies <i>nums</i> by updating the element at index <i>i</i> to <i>val</i>.\n\n<p><b>Example:</b><br>\n</p><pre>Given nums = [1, 3, 5]\n\nsumRange(0, 2) -&gt; 9\nupdate(1, 2)\nsumRange(0, 2) -&gt; 8\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The array is only modifiable by the <i>update</i> function.</li>\n<li>You may assume the number of calls to <i>update</i> and <i>sumRange</i> function is distributed evenly.</li>\n</ol>\n<p></p><p></p>\n      </div>",
        "solution": "public class NumArray {\n    \n    // http://www.cnblogs.com/grandyang/p/4985506.html\n    int[] num;\n    int[] bit;\n\n    public NumArray(int[] nums) {\n        num = new int[nums.length + 1];\n        bit = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; ++i) {\n            update(i, nums[i]);\n        }\n    }\n\n    void update(int i, int val) {\n        int diff = val - num[i + 1];\n        for (int j = i + 1; j < num.length; j += (j&-j)) {\n            bit[j] += diff;\n        }\n        num[i + 1] = val;\n    }\n\n    public int sumRange(int i, int j) {\n        return getSum(j + 1) - getSum(i);\n    }\n    \n    int getSum(int i) {\n        int res = 0;\n        for (int j = i; j > 0; j -= (j&-j)) {\n            res += bit[j];\n        }\n        return res;\n    }\n}\n\n\n// Your NumArray object will be instantiated and called as such:\n// NumArray numArray = new NumArray(nums);\n// numArray.sumRange(0, 1);\n// numArray.update(1, 10);\n// numArray.sumRange(1, 2);",
        "tags": "26, 17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 253,
        "number": 309,
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like\n(ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n\n<ul>\n    <li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>\n    <li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>\n</ul>\n\n<p><b>Example:</b><br></p>\n<pre>prices = [1, 2, 3, 0, 2]\nmaxProfit = 3\ntransactions = [buy, sell, cooldown, buy, sell]\n</pre>\n\n      </div>",
        "solution": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length <= 1) return 0;\n\t\tint[] buy = new int[prices.length];\n\t\tint[] sell = new int[prices.length];\n\t\t\n\t\tbuy[0] = -prices[0];\n\t\tbuy[1] = prices[1] > prices[0] ? - prices[0] : - prices[1];\n\t\tsell[0] = 0;\n\t\tsell[1] = prices[1] > prices[0] ? (prices[1] - prices[0]) : 0;\n\t\tfor(int i = 2; i < prices.length; i++){\n\t\t\tbuy[i] = Math.max(sell[i-2]-prices[i], buy[i-1]);\n\t\t\tsell[i] = Math.max(buy[i-1]+prices[i], sell[i-1]);\n\t\t}\n\t\treturn sell[prices.length - 1];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 254,
        "number": 310,
        "title": "Minimum Height Trees",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs).\n    Given such a graph, write a function to find all the MHTs and return a list of their root labels.\n</p>\n\n<p>\n    <b>Format</b><br>\n    The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>.\n    You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).\n</p>\n<p> \nYou can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are\n    undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in\n    <code>edges</code>.\n</p>\n<p>\n    <b>Example 1:</b>\n</p>\n<p>\n    Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code>\n</p>\n\n<pre>        0\n        |\n        1\n       / \\\n      2   3\n</pre>\n<p>\n    return <code> [1]</code>\n</p>\n\n<p>\n    <b>Example 2:</b>\n</p>\n<p>\n    Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code>\n</p>\n<pre>     0  1  2\n      \\ | /\n        3\n        |\n        4\n        |\n        5\n</pre>\n<p>\n    return <code> [3, 4]</code>\n</p>\n\n<p>\n    <b>Note</b>:\n</p>\n<p>\n    (1) According to the definition of tree on Wikipedia: \"a tree is an undirected graph in which any two vertices are connected by\n    <i>exactly</i> one path. In other words, any connected graph without simple cycles is a tree.\"\n</p>\n<p>\n    (2) The height of a rooted tree is the number of edges on the longest downward path between the root and a\n    leaf.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        List<Integer> result = new ArrayList<>();\n        if (n <= 0) {\n            return result;\n        }\n         \n        // Corner case: there is a single node and no edge at all\n        if (n == 1 && edges.length == 0) {\n            result.add(0);\n            return result;\n        }\n         \n        // Step 1: construct the graph\n        List<Set<Integer>> adjList = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            adjList.add(new HashSet<>());\n        }\n         \n        for (int[] edge : edges) {\n            int from = edge[0];\n            int to = edge[1];\n            adjList.get(from).add(to);\n            adjList.get(to).add(from);\n        }\n         \n        // Remove leaf nodes\n        List<Integer> leaves = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (adjList.get(i).size() == 1) {\n                leaves.add(i);\n            }\n        }\n         \n        while (n > 2) {\n            // identify and remove all leaf nodes\n            n -= leaves.size();\n            List<Integer> newLeaves = new ArrayList<>();\n            for (int leaf : leaves) {\n                int neighbor = adjList.get(leaf).iterator().next();\n                adjList.get(neighbor).remove(leaf);\n                 \n                if (adjList.get(neighbor).size() == 1) {\n                    newLeaves.add(neighbor);\n                }\n            }\n             \n            leaves = newLeaves;\n        }\n         \n        return leaves;\n    }\n}",
        "tags": "19, 23",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 255,
        "number": 311,
        "title": "Sparse Matrix Multiplication",
        "difficulty": "Medium",
        "description": "Given two sparse matrices A and B, return the result of AB. <br>\nYou may assume that A's column number is equal to B's row number. <br>\nExample: <br>\n\n<pre style=\"background-color: whitesmoke; border-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; line-height: 1.42857143; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: break-all; word-wrap: break-word;\"><span style=\"box-sizing: border-box; font-weight: 700;\">A</span> = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\n\n<span style=\"box-sizing: border-box; font-weight: 700;\">B</span> = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n\n\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\n<span style=\"box-sizing: border-box; font-weight: 700;\">AB</span> = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |</pre>",
        "solution": "public class Solution {\n    /***\n     * A sparse matrix can be represented as a sequence of rows,\n     * each of which is a sequence of (column-number, value)\n     * pairs of the nonzero values in the row.\n     */\n    public int[][] multiply(int[][] A, int[][] B) {\n        int m = A.length, n = A[0].length, nB = B[0].length;\n        int[][] result = new int[m][nB];\n\n        List[] indexA = new List[m];\n        for (int i = 0; i < m; i++) {\n            List<Integer> numsA = new ArrayList<>();\n            for (int j = 0; j < n; j++) {\n                if (A[i][j] != 0) {\n                    numsA.add(j);\n                    numsA.add(A[i][j]);\n                }\n            }\n            indexA[i] = numsA;\n        }\n\n        for (int i = 0; i < m; i++) {\n            List<Integer> numsA = indexA[i];\n            for (int p = 0; p < numsA.size() - 1; p += 2) {\n                int colA = numsA.get(p);\n                int valA = numsA.get(p + 1);\n                for (int j = 0; j < nB; j++) {\n                    int valB = B[colA][j];\n                    result[i][j] += valA * valB;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    // Solution 2 using map\n    public int[][] multiply(int[][] A, int[][] B) {\n        if (A == null || A.length == 0 ||\n                B == null || B.length == 0) {\n            return new int[0][0];\n        }\n\n        int m = A.length;\n        int n = A[0].length;\n        int l = B[0].length;\n\n        int[][] C = new int[m][l];\n\n        // Step 1: convert the sparse A to dense format\n        Map<Integer, Map<Integer, Integer>> denseA = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (A[i][j] != 0) {\n                    if (!denseA.containsKey(i)) {\n                        denseA.put(i, new HashMap<>());\n                    }\n                    denseA.get(i).put(j, A[i][j]);\n                }\n            }\n        }\n\n        // Step 2: convert the sparse B to dense format\n        Map<Integer, Map<Integer, Integer>> denseB = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < l; j++) {\n                if (B[i][j] != 0) {\n                    if (!denseB.containsKey(i)) {\n                        denseB.put(i, new HashMap<>());\n                    }\n                    denseB.get(i).put(j, B[i][j]);\n                }\n            }\n        }\n\n        // Step3: calculate the denseA * denseB\n        for (int i : denseA.keySet()) {\n            for (int j : denseA.get(i).keySet()) {\n                if (!denseB.containsKey(j)) {\n                    continue;\n                }\n\n                for (int k : denseB.get(j).keySet()) {\n                    C[i][k] += denseA.get(i).get(j) * denseB.get(j).get(k);\n                }\n            }\n        }\n\n        return C;\n    }\n}",
        "tags": "21",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 256,
        "number": 313,
        "title": "Super Ugly Number",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Write a program to find the n<sup>th</sup> super ugly number.\n</p>\n\n<p>\n    Super ugly numbers are positive numbers whose all prime factors are in the given prime list\n    <code>primes</code> of size <code>k</code>. For example, <code>[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]\n</code> is the sequence of the first 12 super ugly numbers given <code>primes</code>\n    = <code>[2, 7, 13, 19]</code> of size 4.\n</p>\n\n<p>\n    <b>Note:</b><br>\n    (1) <code>1</code> is a super ugly number for any given <code>primes</code>.<br>\n    (2) The given numbers in <code>primes</code> are in ascending order.<br>\n    (3) 0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 10<sup>6</sup>, 0 &lt; <code>primes[i]</code> &lt; 1000.<br>\n    (4) The n<sup>th</sup> super ugly number is guaranteed to fit in a 32-bit signed integer.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    class Node implements Comparable<Node> {\n        int index;\n        int val;\n        int prime;\n \n        Node(int index, int val, int prime) {\n            this.val = val;\n            this.index = index;\n            this.prime = prime;\n        }\n \n        public int compareTo(Node x) {\n            return this.val - x.val ;\n        }\n    }\n    \n    public int nthSuperUglyNumber(int n, int[] primes) {\n        int[] ugly_number = new int[n];\n        ugly_number[0] = 1;\n        PriorityQueue<Node> q = new PriorityQueue<Node>();\n        for (int i = 0; i < primes.length; i++)\n            q.add(new Node(0, primes[i], primes[i]));\n        for (int i = 1; i < n; i++) {\n            Node cur = q.peek();\n            ugly_number[i] = cur.val;\n            do {\n                cur = q.poll();\n                cur.val = ugly_number[++cur.index] * cur.prime;\n                q.add(cur);\n            } while (!q.isEmpty() && q.peek().val == ugly_number[i]);\n        }\n        return ugly_number[n - 1];\n    }\n}\n \n",
        "tags": "3, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 257,
        "number": 318,
        "title": "Maximum Product of Word Lengths",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given a string array <code>words</code>, find the maximum value of <code>length(word[i]) * length(word[j])</code> where the two words do not share common letters.\n    You may assume that each word will contain only lower case letters.\n    If no such two words exist, return 0.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n</p>\n<p>\n    Given <code>[\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]</code><br>\n    Return <code>16</code><br>\n    The two words can be <code>\"abcw\", \"xtfn\"</code>.\n</p>\n<p>\n    <b>Example 2:</b><br>\n</p>\n<p>\n    Given <code>[\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]</code><br>\n    Return <code>4</code><br>\n    The two words can be <code>\"ab\", \"cd\"</code>.\n</p>\n<p>\n    <b>Example 3:</b><br>\n</p>\n<p>\n    Given <code>[\"a\", \"aa\", \"aaa\", \"aaaa\"]</code><br>\n    Return <code>0</code><br>\n    No such pair of words.    \n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public int maxProduct(String[] words) {\n        int n = words.length;\n        int[] elements = new int[n];\n        for (int i=0;i<n;i++){\n            for(int j=0;j<words[i].length();j++){\n                elements[i] |= 1 << (words[i].charAt(j) - 'a');\n            }\n        }\n \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((elements[i] & elements[j]) == 0)\n                    ans = Math.max(ans,words[i].length() * words[j].length());\n            }\n        }\n        return ans;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 258,
        "number": 319,
        "title": "Bulb Switcher",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nThere are <i>n</i> bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the <i>i</i>th round, you toggle every <i>i</i> bulb. For the <i>n</i>th round, you only toggle the last bulb.\n\nFind how many bulbs are on after <i>n</i> rounds.\n</p>\n\n<p>\n<b>Example:</b><br></p>\n<pre>Given <i>n</i> = 3. <br>\nAt first, the three bulbs are <b>[off, off, off]</b>.\nAfter first round, the three bulbs are <b>[on, on, on]</b>.\nAfter second round, the three bulbs are <b>[on, off, on]</b>.\nAfter third round, the three bulbs are <b>[on, off, off]</b>. <br>\nSo you should return 1, because there is only one bulb is on.\n</pre><p></p>\n      </div>",
        "solution": "public class Solution {\n    /**\n     *  A bulb ends up on iff it is switched an odd number of times.\n     *   Call them bulb 1 to bulb n. \n     *   Bulb i is switched in round d if and only if d divides i. \n     *   So bulb i ends up on if and only if it has an odd number of divisors.\n     *   Divisors come in pairs, like i=12 has divisors 1 and 12, 2 and 6, and 3 and 4. \n     *   Except when i is a square, like 36 has divisors 1 and 36, 2 and 18, \n     *   3 and 12, 4 and 9, and double divisor 6. \n     *   So bulb i ends up on if and only if i is a square.\n     *   So just count the square numbers. \n     * \n    */\n    public int bulbSwitch(int n) {\n        return (int)Math.sqrt(n);\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 259,
        "number": 322,
        "title": "Coin Change",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nYou are given coins of different denominations and a total amount of money <i>amount</i>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.\n</p>\n\n<p>\n<b>Example 1:</b><br>\ncoins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>\nreturn <code>3</code> (11 = 5 + 5 + 1)\n</p>\n\n<p>\n<b>Example 2:</b><br>\ncoins = <code>[2]</code>, amount = <code>3</code><br>\nreturn <code>-1</code>.\n</p>\n\n<p>\n<b>Note</b>:<br>\nYou may assume that you have an infinite number of each kind of coin.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    /****************\n     * \n     * Let dp[v] to be the minimum number of coins required to get the amount v. \n     * dp[i+a_coin] = min(dp[i+a_coin], dp[i]+1) if dp[i] is reachable. \n     * dp[i+a_coin] = dp[i+a_coin] is dp[i] is not reachable. \n     * We initially set dp[i] to be MAX_VALUE.\n     * \n     *************/\n     \n     public int coinChange(int[] coins, int amount) {\n         if(amount==0) return 0;\n \n        int[] dp = new int [amount+1];\n        dp[0]=0; // do not need any coin to get 0 amount\n        for(int i=1;i<=amount; i++)\n            dp[i]= Integer.MAX_VALUE;\n \n        for(int i=0; i<=amount; i++){\n            for(int coin: coins){\n            if(i+coin >= 0 && i+coin <=amount && dp[i]!=Integer.MAX_VALUE){\n                    dp[i+coin] = Math.min(dp[i+coin], dp[i]+1);\n                }\n            }\n        }\n        if(dp[amount] == Integer.MAX_VALUE)\n            return -1;\n        return dp[amount];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 260,
        "number": 324,
        "title": "Wiggle Sort II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given an unsorted array <code>nums</code>, reorder it such that\n    <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.\n</p>\n\n<p>\n    <b>Example:</b><br>\n    (1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>. <br>\n    (2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.\n</p>\n\n<p>\n    <b>Note:</b><br>\n    You may assume all input has valid answer.\n</p>\n\n<p>\n    <b>Follow Up:</b><br>\n    Can you do it in O(n) time and/or in-place with O(1) extra space?\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    /**\n     * 1. Find the median of the input array\n     * 2. 3-way partition the array around median so that left contains greater than median, \n     *      middle contains equal to median, and right contains less than median.\n     * 3. Take one from each partition in the order of middle --> left --> right \n     *      (as middle < left > right is wiggle order).  \n    **/\n    public void wiggleSort(int[] nums) {\n        if (nums == null || nums.length <= 1) {\n            return;\n        }\n         \n        // Step 1: Find median of the array, return the index of the median\n        // Step 2: 3-way sort, put median in the middle, \n        // numbers less than median on the left, \n        // numbers greater than median on the right\n        int n = nums.length;\n        int median = findKthLargest(nums, (n + 1) / 2);\n        int i = 0;\n        int left = 0;\n        int right = n - 1;\n        \n        /**\n           DNF order: [9,8,7,6  5,  4,3,2,1]\n           DNF Index: [0,1,2,3, 4,  5,6,7,8]\n           Wiggle order: [5, 9, 4, 8, 3, 7, 2, 6, 1]\n           Wiggle Index: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n            Index Mapping: \n            ---------------\n            DNF --> Wiggle (value)\n            -----------------------\n            0 --> 1 (9)\n            1 --> 3 (8)\n            2 --> 5 (7)\n            3 --> 7 (6)\n            4 --> 0 (5)\n            5 --> 2 (4)\n            6 --> 4 (3)\n            7 --> 6 (2)\n            8 --> 8 (1) \n\n            that is DNF(i) = WIGGLE((1+2*i)%n)\n        **/\n        while (i <= right) {\n            if (nums[newIndex(i,n)] > median) {\n                swap(nums, newIndex(left++,n), newIndex(i++,n));\n            } else if (nums[newIndex(i,n)] < median) {\n                swap(nums, newIndex(right--,n), newIndex(i,n));\n            } else {\n                i++;\n            }\n        }\n    }\n    \n    private int newIndex(int index, int n) {\n        return (1 + 2*index) % (n | 1);\n    }\n     \n    private int findKthLargest(int[] nums, int k) {\n\t\tif (nums == null || nums.length == 0)\n\t\t\treturn Integer.MAX_VALUE;\n\t\treturn findKthLargest(nums, 0, nums.length - 1, nums.length - k);\n\t}\n\n\t// quick select: kth smallest\n\tprivate int findKthLargest(int[] nums, int start, int end, int k) {\n\t\tif (start > end)\n\t\t\treturn Integer.MAX_VALUE;\n\n\t\tint pivot = nums[end];// Take A[end] as the pivot,\n\t\tint left = start;\n\t\tfor (int i = start; i < end; i++) {\n\t\t\tif (nums[i] <= pivot) // Put numbers < pivot to pivot's left\n\t\t\t\tswap(nums, left++, i);\n\t\t}\n\t\tswap(nums, left, end);// Finally, swap A[end] with A[left]\n\n\t\tif (left == k)// Found kth smallest number\n\t\t\treturn nums[left];\n\t\telse if (left < k)// Check right part\n\t\t\treturn findKthLargest(nums, left + 1, end, k);\n\t\telse // Check left part\n\t\t\treturn findKthLargest(nums, start, left - 1, k);\n\t}\n\n\tprivate void swap(int[] A, int i, int j) {\n\t\tint tmp = A[i];\n\t\tA[i] = A[j];\n\t\tA[j] = tmp;\n\t}\n}",
        "tags": "13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 261,
        "number": 325,
        "title": "Maximum Size Subarray Sum Equals k",
        "difficulty": "Medium",
        "description": "<p>Given an array nums and a target value k, find the maximum length of a subarray that sums to k.\n    If there isn't one, return 0 instead.</p>\n\n<p>Note:<br>\n    The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.</p>\n\n<p>Example 1:<br>\n    Given nums = [1, -1, 5, -2, 3], k = 3,<br>\n    return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)</p>",
        "solution": "class Solution {\n    public int maxSubArrayLen(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int max = 0;\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (sum == k) {\n                max = Math.max(max, i + 1);\n            }\n            int diff = sum - k;\n            if (map.containsKey(diff)) {\n                max = Math.max(max, i - map.get(diff));\n            }\n            if (!map.containsKey(sum)) {\n                map.put(sum, i);\n            }\n        }\n        return max;\n    }\n}",
        "tags": "1",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 262,
        "number": 328,
        "title": "Odd Even Linked List",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>\n\n<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p>\n\n</p><p>\n<b>Example:</b><br>\nGiven <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,<br>\nreturn <code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.\n</p>\n<p>\n<b>Note:</b><br>\nThe relative order inside both the even and odd groups should remain as it was in the input. <br>\nThe first node is considered odd, the second node even and so on ...\n</p>\n\n      </div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if(head == null || head.next == null || head.next.next == null) return head;\n        ListNode cur = head, tail = head;\n        int len = 1;\n        while(tail.next != null){\n        \ttail = tail.next;\n        \tlen++;\n        }\n            \n        int count = 1;\n        while(count <= len/2){\n            ListNode even = cur.next;\n            cur.next = cur.next.next;\n            tail.next = even;\n            tail = tail.next;\n            tail.next = null;\n            cur = cur.next;\n            count++;\n        }\n        return head;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 263,
        "number": 331,
        "title": "Verify Preorder Serialization of a Binary Tree",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p>\n\n<pre>     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n</pre>\n\n<p>For example, the above binary tree can be serialized to the string <code>\"9,3,4,#,#,1,#,#,2,#,6,#,#\"</code>, where <code>#</code> represents a null node.\n</p>\n\n<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>\n\n<p>Each comma separated value in the string must be either an integer or a character <code>'#'</code> representing <code>null</code> pointer.</p>\n\n<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>\"1,,3\"</code>.</p>\n\n<p><strong>Example 1:</strong><br>\n<code>\"9,3,4,#,#,1,#,#,2,#,6,#,#\"</code><br>\nReturn <code>true</code></p>\n<p><strong>Example 2:</strong><br>\n<code>\"1,#\"</code><br>\nReturn <code>false</code></p>\n<p><strong>Example 3:</strong><br>\n<code>\"9,#,#,1\"</code><br>\nReturn <code>false</code></p>\n\n      </div>",
        "solution": "public class Solution {\n    public boolean isValidSerialization(String preorder) {\n        List<String> list = new ArrayList<String>();\n\t\tfor(String x : preorder.split(\",\")){\n\t\t\tlist.add(x);\n\t\t\twhile(list.size() >= 3 && list.get(list.size()-1).equals(\"#\") && \n\t\t\t\t\tlist.get(list.size()-2).equals(\"#\") && \n\t\t\t\t\t!list.get(list.size()-3).equals(\"#\")){\n\t\t\t\tlist.remove(list.size()-1);\n\t\t\t\tlist.remove(list.size()-1);\n\t\t\t\tlist.remove(list.size()-1);\n\t\t\t\tlist.add(\"#\");\n\t\t\t}\n\t\t}\t\t        \n        return (list.size() == 1) && (list.get(list.size()-1).equals(\"#\"));\n    }\n}",
        "tags": "15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 264,
        "number": 332,
        "title": "Reconstruct Itinerary",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.\n</p>\n<p>\n<b>Note:</b><br>\n</p><ol>\n<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[\"JFK\", \"LGA\"]</code> has a smaller lexical order than <code>[\"JFK\", \"LGB\"]</code>.</li>\n<li>All airports are represented by three capital letters (IATA code).</li>\n<li>You may assume all tickets form at least one valid itinerary.</li>\n</ol>\n<p></p>\n\n<p>\n    <b>Example 1:</b><br>\n    <code>tickets</code> = <code>[[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]</code><br>\n    Return <code>[\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]</code>.<br>\n</p>\n<p>\n    <b>Example 2:</b><br>\n    <code>tickets</code> = <code>[[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]</code><br>\n    Return <code>[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]</code>.<br>\n    Another possible reconstruction is <code>[\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]</code>. But it is larger in lexical order.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    HashMap<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();\n\tLinkedList<String> result = new LinkedList<String>();\n \n\tpublic List<String> findItinerary(String[][] tickets) {\n\t\tfor (String[] ticket : tickets) {\n\t\t\tif (!map.containsKey(ticket[0])) {\n\t\t\t\tPriorityQueue<String> q = new PriorityQueue<String>();\n\t\t\t\tmap.put(ticket[0], q);\n\t\t\t}\n\t\t\tmap.get(ticket[0]).offer(ticket[1]);\n\t\t}\n \n\t\tdfs(\"JFK\");\n\t\treturn result;\n\t}\n \n\tpublic void dfs(String s) {\n\t\tPriorityQueue<String> q = map.get(s);\n\t\twhile (q != null && !q.isEmpty()) {\n\t\t\tdfs(q.poll());\n\t\t}\n\t\tresult.addFirst(s);\n\t}\n}",
        "tags": "14, 23",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 265,
        "number": 334,
        "title": "Increasing Triplet Subsequence",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\n</p>\n<p>\nFormally the function should:<br>\n</p><blockquote>Return true if there exists <i>i, j, k </i> <br>\nsuch that <i>arr[i]</i> &lt; <i>arr[j]</i> &lt; <i>arr[k]</i> given 0 ≤ <i>i</i> &lt; <i>j</i> &lt; <i>k</i> ≤ <i>n</i>-1 \nelse return false.\n</blockquote>\n<p></p>\n<p>\nYour algorithm should run in O(<i>n</i>) time complexity and O(<i>1</i>) space complexity.\n</p>\n<p>\n<b>Examples:</b><br>\nGiven <code>[1, 2, 3, 4, 5]</code>,<br>\nreturn <code>true</code>.\n</p>\n<p>\nGiven <code>[5, 4, 3, 2, 1]</code>,<br>\nreturn <code>false</code>.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int smallest = Integer.MAX_VALUE, mid = Integer.MAX_VALUE;\n\t    for (int i = 0; i < nums.length; i++) {\n\t\t    if (nums[i] <= smallest) {\n\t\t\t    smallest = nums[i];// update x to be a smaller value\n\t\t    } else if (nums[i] <= mid) {\n\t\t\t    mid = nums[i]; // update so that mid > smallest  \n\t\t    } else {\n\t\t\t    return true;\n\t\t    }\n\t    }\n    \treturn false;\n    }\n}",
        "tags": "",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 266,
        "number": 337,
        "title": "House Robber III",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n</p>\n\n<p>\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>     <font color=\"red\">3</font>\n    / \\\n   2   3\n    \\   \\ \n     <font color=\"red\">3   1</font>\n</pre>\nMaximum amount of money the thief can rob = <font color=\"red\">3</font> + <font color=\"red\">3</font> + <font color=\"red\">1</font> = <b>7</b>.\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>     3\n    / \\\n   <font color=\"red\">4</font>   <font color=\"red\">5</font>\n  / \\   \\ \n 1   3   1\n</pre>\nMaximum amount of money the thief can rob = <font color=\"red\">4</font> + <font color=\"red\">5</font> = <b>9</b>.\n<p></p>\n\n      </div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int rob(TreeNode root) {\n        if(root == null) return 0;\n        int[] result = helper(root);\n        return Math.max(result[0], result[1]);\n    }\n \n    public int[] helper(TreeNode root){\n        if(root == null){\n            int[] result = {0, 0};\n            return result;\n        }\n \n        int[] result = new int[2];\n        int[] left = helper(root.left);\n        int[] right = helper(root.right);\n \n        // result[0] is when root is selected, result[1] is when not. \n        result[0] = root.val + left[1] + right[1];\n        result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n        return result;\n    }\n}",
        "tags": "12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 267,
        "number": 338,
        "title": "Counting Bits",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a non negative integer number <b>num</b>. For every numbers <b>i</b> in the range <b>0 ≤ i ≤ num</b> calculate the number of 1's in their binary representation and return them as an array.\n</p>\n<p>\n<b>Example:</b><br>\nFor <code>num = 5</code> you should return <code>[0,1,1,2,1,2]</code>.\n</p>\n<p>\n<b>Follow up:</b>\n</p><ul>\n<li>It is very easy to come up with a solution with run time <b>O(n*sizeof(integer))</b>. But can you do it in linear time <b>O(n)</b> /possibly in a single pass?</li>\n<li>Space complexity should be <b>O(n)</b>.</li>\n<li>Can you do it like a boss? Do it without using any builtin function like <b>__builtin_popcount</b>  in c++ or in any other language.</li>\n</ul>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    public int[] countBits(int num) {\n        int[] result = new int[num+1];\n        //p tracks the index for number x\n        int p = 1; \n        int pow = 1;\n        for(int i = 1; i <= num; i++){\n            if(i == pow){\n                result[i] = 1;\n                pow <<= 1;\n                p = 1;\n            }else{\n                result[i] = result[p]+1;\n                p++;\n            }\n        }\n        return result;\n    }\n}",
        "tags": "9, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 268,
        "number": 341,
        "title": "Flatten Nested List Iterator",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a nested list of integers, implement an iterator to flatten it.</p>\n\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\n\n<p><b>Example 1:</b><br>\nGiven the list <code>[[1,1],2,[1,1]]</code>,\n</p><p>\nBy calling <i>next</i> repeatedly until <i>hasNext</i> returns false, the order of elements returned by <i>next</i> should be: <code>[1,1,2,1,1]</code>.\n</p>\n<p></p>\n\n<p><b>Example 2:</b><br>\nGiven the list <code>[1,[4,[6]]]</code>,\n</p><p>\nBy calling <i>next</i> repeatedly until <i>hasNext</i> returns false, the order of elements returned by <i>next</i> should be: <code>[1,4,6]</code>.\n</p>\n<p></p><p></p>\n      </div>",
        "solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\npublic class NestedIterator implements Iterator<Integer> {\n    List<Integer> curItems;\n    Iterator<Integer> curItor;\n    int curIndex;\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        curItems = new ArrayList<Integer>();\n        for(NestedInteger ni : nestedList){\n            if(ni.isInteger())\n                curItems.add(ni.getInteger());\n            else{\n                addNestedInteger(ni.getList());\n            }\n        }\n        curItor = curItems.iterator();\n    }\n    \n    void addNestedInteger(List<NestedInteger> nestedList){\n        for(NestedInteger ni : nestedList){\n            if(ni.isInteger())\n                curItems.add(ni.getInteger());\n            else{\n                addNestedInteger(ni.getList());\n            }\n        }\n    }\n\n    @Override\n    public Integer next() {\n        return curItor.next();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return curItor.hasNext();\n    }\n}\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i = new NestedIterator(nestedList);\n * while (i.hasNext()) v[f()] = i.next();\n */",
        "tags": "10, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 269,
        "number": 343,
        "title": "Integer Break",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven a positive integer <i>n</i>, break it into the sum of <b>at least</b> two positive integers and maximize the product of those integers. Return the maximum product you can get.\n</p>\n\n<p>\nFor example, given <i>n</i> = 2, return 1 (2 = 1 + 1); given <i>n</i> = 10, return 36 (10 = 3 + 3 + 4).\n</p>\n\n<p>\n<b>Note</b>: You may assume that <i>n</i> is not less than 2 and not larger than 58.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    // Let dp[i] to be the max production value for breaking the number i.\n    // Since dp[i+j] can be i*j, \n    //  dp[i+j] = max(max(dp[i], i) * max(dp[j], j)), dp[i+j]).\n    public int integerBreak(int n) {\n        int[] dp = new int[n+1];\n        for(int i = 1; i < n; i++){\n            for(int j = 1; j < i+1; j++){\n                if(i + j > n)\n                    continue;\n                dp[i+j] = Math.max(Math.max(dp[i],i) * \n                                Math.max(dp[j],j), dp[i+j]);\n            }\n        }\n        return dp[n];\n    }\n}",
        "tags": "3, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 270,
        "number": 347,
        "title": "Top K Frequent Elements",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a non-empty array of integers, return the <b><i>k</i></b> most frequent elements.</p>\n\n    <p>For example,<br>\n        Given <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.\n    </p>\n\n    <p><b>Note: </b><br>\n    </p><ul>\n    <li>You may assume <i>k</i> is always valid, 1 ≤ <i>k</i> ≤ number of unique elements.</li>\n    <li>Your algorithm's time complexity <b>must be</b> better than O(<i>n</i> log <i>n</i>), where <i>n</i> is the array's size.</li>\n</ul><p></p><p></p>\n\n</div>",
        "solution": "public class Solution {\n\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        // map to store element and its freqency\n        Map<Integer, Integer> elemMap = new HashMap<>();\n        for(int num : nums){\n            elemMap.put(num, elemMap.getOrDefault(num, 0) + 1);\n        }\n\n        // MaxHeap to get most frequent element\n        PriorityQueue<Map.Entry<Integer, Integer>> pq =\n                new PriorityQueue<Map.Entry<Integer, Integer>>(elemMap.size(), new Comparator<Map.Entry<Integer, Integer>>(){\n\n                    @Override\n                    public int compare(Map.Entry<Integer, Integer> elem1,\n                                       Map.Entry<Integer, Integer> elem2) {\n                        return elem2.getValue() - elem1.getValue();\n                    }\n\n                });\n\n        pq.addAll(elemMap.entrySet());\n        List<Integer> res = new ArrayList<Integer>();\n        // Get elements\n        while(!pq.isEmpty() && k > 0){\n            res.add(pq.poll().getKey());\n            k--;\n        }\n\n        return res;\n    }\n}",
        "tags": "1, 20",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 271,
        "number": 355,
        "title": "Design Twitter",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:</p>\n\n<p>\n</p><ol>\n<li><b>postTweet(userId, tweetId)</b>: Compose a new tweet.</li>\n<li><b>getNewsFeed(userId)</b>: Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>\n<li><b>follow(followerId, followeeId)</b>: Follower follows a followee.</li>\n<li><b>unfollow(followerId, followeeId)</b>: Follower unfollows a followee.</li>\n</ol>\n<p></p>\n\n<p><b>Example:</b>\n</p><pre>Twitter twitter = new Twitter();\n\n// User 1 posts a new tweet (id = 5).\ntwitter.postTweet(1, 5);\n\n// User 1's news feed should return a list with 1 tweet id -&gt; [5].\ntwitter.getNewsFeed(1);\n\n// User 1 follows user 2.\ntwitter.follow(1, 2);\n\n// User 2 posts a new tweet (id = 6).\ntwitter.postTweet(2, 6);\n\n// User 1's news feed should return a list with 2 tweet ids -&gt; [6, 5].\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.getNewsFeed(1);\n\n// User 1 unfollows user 2.\ntwitter.unfollow(1, 2);\n\n// User 1's news feed should return a list with 1 tweet id -&gt; [5],\n// since user 1 is no longer following user 2.\ntwitter.getNewsFeed(1);\n</pre>\n<p></p><p></p>\n      </div>",
        "solution": "public class Twitter {\n    class Tweet {\n        public int time;\n        public int tweetId;\n        public Tweet(int tweetId,int time){\n            this.time = time;\n            this.tweetId = tweetId;\n        }\n\n    }\n    int timeStamp ;\n    // Each person's tweets\n    Map<Integer,List<Tweet>> timelines;\n    // People's relationship\n    Map<Integer,HashSet<Integer>> relations;\n    /** Initialize your data structure here. */\n    public Twitter() {\n        this.timelines = new HashMap<>();\n        this.relations = new HashMap<>();\n    }\n\n    /** Compose a new tweet. */\n    public void postTweet(int userId, int tweetId) {\n        if(timelines.containsKey(userId) == false){\n            timelines.put(userId, new ArrayList<Tweet>());\n        }\n        timelines.get(userId).add(new Tweet(tweetId,timeStamp++));\n\n    }\n\n    /** Retrieve the 10 most recent tweet ids in the user's news feed. \n        Each item in the news feed must be posted by users who the user followed or \n        by the user herself. Tweets must be ordered from most recent to least recent. \n    ***/\n    public List<Integer> getNewsFeed(int userId) {\n        HashSet<Integer> followees = relations.get(userId);\n        List<Tweet> candidates = new ArrayList<Tweet>();\n        // Choose each person's top 10 tweets\n         List<Tweet> timeline = timelines.get(userId);\n         if(timeline!=null){\n             for(int i=timeline.size()-1;i>=Math.max(0,timeline.size()-10);i--){\n                    candidates.add(timeline.get(i));\n                }\n         }\n        if(followees != null){ \n            for(Integer followee:followees){\n                 timeline = timelines.get(followee);\n                 if(timeline == null)\n                    continue;\n                 for(int i=timeline.size()-1;i>=Math.max(0,timeline.size()-10);i--){\n                    candidates.add(timeline.get(i));\n                }\n            }\n        }\n        Collections.sort(candidates,new Comparator<Tweet> (){\n             public int compare(Tweet o1, Tweet o2) {\n                 return o2.time - o1.time;\n                }\n            });\n        List<Integer> list = new ArrayList<Integer>();\n        for(int i=0;i<Math.min(10,candidates.size());i++){\n            list.add(candidates.get(i).tweetId);\n        }\n        return list;\n    }\n\n    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */\n    public void follow(int followerId, int followeeId) {\n        if(followerId == followeeId) return;\n        if(relations.containsKey(followerId)==false){\n            relations.put(followerId,new HashSet<Integer>());\n        }\n        relations.get(followerId).add(followeeId);\n\n    }\n\n    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */\n    public void unfollow(int followerId, int followeeId) {\n        HashSet<Integer> list = relations.get(followerId);\n        if(list == null) return ;\n        list.remove(followeeId);\n    }\n}\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter obj = new Twitter();\n * obj.postTweet(userId,tweetId);\n * List<Integer> param_2 = obj.getNewsFeed(userId);\n * obj.follow(followerId,followeeId);\n * obj.unfollow(followerId,followeeId);\n */",
        "tags": "1, 10, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 272,
        "number": 357,
        "title": "Count Numbers with Unique Digits",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a <b>non-negative</b> integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10<sup>n</sup>.</p>\n\n<p>\n    <b>Example:</b><br>\nGiven n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding <code>[11,22,33,44,55,66,77,88,99]</code>)\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n        n = Math.min(n,10);\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        for(int i = 1;i<=n;i++){\n            dp[i] = 9;\n            for(int x = 9; x >= 9 - i + 2;x--){\n                dp[i] *= x;\n            }\n        }\n        int ans = 0;\n        for(int i= 0;i<dp.length;i++) ans += dp[i];\n        return ans;\n    }\n}",
        "tags": "3, 8, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 273,
        "number": 365,
        "title": "Water and Jug Problem",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>You are given two jugs with capacities <i>x</i> and <i>y</i> litres. There is an infinite amount of water supply available.\nYou need to determine whether it is possible to measure exactly <i>z</i> litres using these two jugs.</p>\n\n<p>If <i>z</i> liters of water is measurable, you must have <i>z</i> liters of water contained within <b>one or both buckets</b> by the end.</p>\n\n<p>\nOperations allowed:\n</p><ul>\n<li>Fill any of the jugs completely with water.</li>\n<li>Empty any of the jugs.</li>\n<li>Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.</li>\n</ul>\n<p></p>\n\n<p><b>Example 1:</b> (From the famous <a href=\"https://www.youtube.com/watch?v=BVtQNK_ZUJg\" target=\"_blank\"><i>\"Die Hard\"</i> example</a>)\n</p><pre>Input: x = 3, y = 5, z = 4\nOutput: True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input: x = 2, y = 6, z = 5\nOutput: False\n</pre>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    // We can always find a and b to satisfy ax + bx = d where d = gcd(x, y)\n    // So, everything is clear, if z % d == 0, \n    // then we have (a*z/d)*x + (b*z/d)*y = z, which means m and n exist.\n    public boolean canMeasureWater(int x, int y, int z) {\n        return z == 0 || (long)x + y >= z && z % gcd(x, y) == 0;\n    }\n    \n    private int gcd(int x, int y) {\n        return y == 0 ? x : gcd(y, x % y);\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 274,
        "number": 368,
        "title": "Largest Divisible Subset",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven a set of <b>distinct</b> positive integers, find the largest subset such that every pair (S<sub>i</sub>, S<sub>j</sub>) of elements in this subset satisfies: S<sub>i</sub> % S<sub>j</sub> = 0 or S<sub>j</sub> % S<sub>i</sub> = 0.\n</p>\n\n<p>If there are multiple solutions, return any subset is fine.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre>nums: [1,2,3]\n\nResult: [1,2] (of course, [1,3] will also be ok)\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>nums: [1,2,4,8]\n\nResult: [1,2,4,8]\n</pre>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        List<Integer> result = new ArrayList<Integer>();\n        if(nums==null||nums.length==0)\n            return result;\n \n        Arrays.sort(nums);\n        int[] t = new int[nums.length];\n        int[] index = new int[nums.length];\n        Arrays.fill(t, 1);\n        Arrays.fill(index, -1);\n \n        // Record the largest element of it.\n        int max = 0;\n        // index of the largest element in dp.\n        int maxIndex = -1;\n        for(int i = 0; i < t.length; i++){\n            for(int j = i-1; j >= 0; j--){\n                if(nums[i] % nums[j] == 0 && t[j] + 1 > t[i]){\n                    t[i] = t[j] + 1;\n                    index[i] = j;\n                }\n            }\n            if(max < t[i]){\n                max = t[i];\n                maxIndex = i;\n            }\n        }\n        // Do a loop from the largest element to nums[0], \n        // add every element belongs to the longest subset.\n        int i = maxIndex;\n        while(i >= 0){\n            result.add(nums[i]);\n            i = index[i];\n        }\n        return result;\n    }\n}",
        "tags": "3, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 275,
        "number": 372,
        "title": "Super Pow",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nYour task is to calculate <i>a</i><sup><i>b</i></sup> mod 1337 where <i>a</i> is a positive integer and <i>b</i> is an extremely large positive integer given in the form of an array.\n</p>\n\n<p><b>Example1:</b>\n</p><pre>a = 2\nb = [3]\n\nResult: 8\n</pre>\n<p></p>\n\n<p><b>Example2:</b>\n</p><pre>a = 2\nb = [1,0]\n\nResult: 1024\n</pre>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    /**\n     * The main idea is cashed on the repeated pattern of the remainder of a^b.\n        As long as we know the length of the pattern m, \n        we just have to find an index point of this pattern based on b mod m.\n        In addition, if a > 1337, we can let a = a mod 1337.\n        Because if we let a = (1337x + c) where c = a mod 1337,\n        (1337x + c)(1337x + c)(1337x + c)...(1337x + c) mod 1337 == ccc...c mod 1337.\n    **/\n    int DIV = 1337;\n    public int superPow(int a, int[] b) {\n        if (a==0 || a==DIV || b==null || b.length == 0) return 0;\n        if (a==1) return 1;\n        if (a > DIV) return superPow( a % DIV, b);\n        List<Integer> index = findLoop(a);\n        int loopsize = index.size();\n        int rem = modBy(b, loopsize);\n        rem = rem == 0 ? loopsize: rem;\n        return index.get(rem-1);\n    }\n    \n    private List<Integer> findLoop(int a){\n        List<Integer> index = new ArrayList<>();\n        boolean[] set = new boolean[DIV];\n        int rem = a % DIV;\n        while (!set[rem] ) {\n            set[rem] = true;\n            index.add(rem);\n            rem = (rem*a) % DIV;\n        }\n        return index;\n    }\n    \n    private int modBy(int[] b, int m){\n        int rem = 0;\n        for (int i=0; i < b.length; i++) {\n            rem = (rem*10+b[i]) % m;\n        }\n        return rem;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 276,
        "number": 373,
        "title": "Find K Pairs with Smallest Sums",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nYou are given two integer arrays <b>nums1</b> and <b>nums2</b> sorted in ascending order and an integer <b>k</b>. \n</p>\n\n<p>Define a pair <b>(u,v)</b> which consists of one element from the first array and one element from the second array.</p>\n\n<p>Find the k pairs <b>(u<sub>1</sub>,v<sub>1</sub>),(u<sub>2</sub>,v<sub>2</sub>) ...(u<sub>k</sub>,v<sub>k</sub>)</b> with the smallest sums.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Given nums1 = [1,7,11], nums2 = [2,4,6],  k = 3\n\nReturn: [1,2],[1,4],[1,6]\n\nThe first 3 pairs are returned from the sequence:\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>Given nums1 = [1,1,2], nums2 = [1,2,3],  k = 2\n\nReturn: [1,1],[1,1]\n\nThe first 2 pairs are returned from the sequence:\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre>Given nums1 = [1,2], nums2 = [3],  k = 3 \n\nReturn: [1,3],[2,3]\n\nAll possible pairs are returned from the sequence:\n[1,3],[2,3]\n</pre>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    public List<int[]> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        Queue<int[]> minHeap = new PriorityQueue<int[]>(k, pairComparator);\n        \n        for(int i = 0; i < nums1.length; i++){\n            for(int j = 0; j < nums2.length; j++){\n                minHeap.add(new int[]{nums1[i], nums2[j]});\n            }\n        }\n        \n        List<int[]> res = new ArrayList<int[]>();\n        while(!minHeap.isEmpty() && res.size() < k){\n            res.add(minHeap.poll());\n        }\n        return res;\n    }\n    \n    Comparator<int[]> pairComparator = new Comparator<int[]>(){\n        public int compare(int[] pair1, int[] pair2){\n            return pair1[0] + pair1[1] - pair2[0] - pair2[1];\n        }\n    };\n}\n\n",
        "tags": "20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 277,
        "number": 375,
        "title": "Guess Number Higher or Lower II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n        <p></p><p>We are playing the Guess Game. The game is as follows:</p><p> \n\n</p><p>I pick a number from <strong>1</strong> to <strong>n</strong>. You have to guess which number I picked.</p>\n\n<p>Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. </p>\n\n<p>However, when you guess a particular number x,  and you guess wrong, you pay <b>$x</b>. You win the game when you guess the number I picked.</p>\n\n<p>\n<b>Example:</b>\n</p><pre>n = 10, I pick 8.\n\nFirst round:  You guess 5, I tell you that it's higher. You pay $5.\nSecond round: You guess 7, I tell you that it's higher. You pay $7.\nThird round:  You guess 9, I tell you that it's lower. You pay $9.\n\nGame over. 8 is the number I picked.\n\nYou end up paying $5 + $7 + $9 = $21.\n</pre>\n<p></p>\n\n<p>Given a particular <strong>n ≥ 1</strong>, find out how much money you need to have to guarantee a <b>win</b>.</p>\n\n      </div>",
        "solution": "public class Solution {\n    /**\n     * Definition of dp[i][j]: minimum number of money to guarantee win for subproblem [i, j].\n        Target: dp[1][n]\n        Corner case: dp[i][i] = 0 (because the only element must be correct)\n        Equation: we can choose k (i<=k<=j) as our guess, and pay price k. \n        After our guess, the problem is divided into two subproblems. \n        Notice we do not need to pay the money for both subproblems. \n        We only need to pay the worst case \n        (because the system will tell us which side we should go) to guarantee win. \n        So dp[i][j] = min (i<=k<=j) { k + max(dp[i][k-1], dp[k+1][j]) }\n    **/\n    public int getMoneyAmount(int n) {\n        if (n == 1) {\n            return 0;\n        }\n        int[][] dp = new int[n + 1][n + 1];\n        for (int jminusi = 1; jminusi < n; jminusi++) {\n            for (int i = 0; i + jminusi <= n; i++) {\n                int j = i + jminusi;\n                dp[i][j] = Integer.MAX_VALUE;\n                for (int k = i; k <= j; k++) {\n                    dp[i][j] = Math.min(dp[i][j],\n                                        k + Math.max(k - 1 >= i ? dp[i][k - 1] : 0,\n                                                     j >= k + 1 ? dp[k + 1][j] : 0));\n                }\n            }\n        }\n        return dp[1][n];\n    }\n}",
        "tags": "9, 31",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 278,
        "number": 376,
        "title": "Wiggle Subsequence",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>A sequence of numbers is called a <strong>wiggle sequence</strong> if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. </p>\n\n    <p>For example, <code>[1,7,4,9,2,5]</code> is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, <code>[1,4,7,2,5]</code> and <code>[1,7,4,5,5]</code> are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>\n\n    <p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>\n\n    <p><b>Examples:</b><br>\n    </p><pre><b>Input:</b> [1,7,4,9,2,5]\n<b>Output:</b> 6\nThe entire sequence is a wiggle sequence.\n\n<b>Input:</b> [1,17,5,10,13,15,10,5,16,8]\n<b>Output:</b> 7\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\n\n<b>Input:</b> [1,2,3,4,5,6,7,8,9]\n<b>Output:</b> 2\n</pre>\n    <p></p>\n\n    <p><b>Follow up:</b><br>\n        Can you do it in O(<i>n</i>) time?\n    </p>\n\n    <p><b>Credits:</b><br>Special thanks to <a href=\"https://leetcode.com/agave/\">@agave</a> and <a href=\"https://leetcode.com/stefanpochmann/\">@StefanPochmann</a> for adding this problem and creating all test cases.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     * 1.   If nums[i] > nums[i-1], that means it wiggles up.\n     * The element before it must be a down position.\n     *  So up[i] = down[i-1] + 1 and down[i] = down[i-1].\n     * 2.   If nums[i] < nums[i-1], that means it wiggles down.\n     * The element before it must be a up position.\n     *  So down[i] = up[i-1] + 1, up[i] = up[i-1].\n     * 3.   If nums[i] == nums[i-1], that means it will not\n     *  change anything becaue it didn't wiggle at all.\n     *  So both down[i] = down[i-1] and up[i] = up[i−1].\n     *\n     * At the end, we can find the larger out of up[length-1]up[length−1] and down[length-1]down[length−1] to find the max. wiggle subsequence length, where lengthlength refers to the number of elements in the given array.\n     *\n    **/\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        int[] up = new int[nums.length];\n        int[] down = new int[nums.length];\n        up[0] = down[0] = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                up[i] = down[i - 1] + 1;\n                down[i] = down[i - 1];\n            } else if (nums[i] < nums[i - 1]) {\n                down[i] = up[i - 1] + 1;\n                up[i] = up[i - 1];\n            } else {\n                down[i] = down[i - 1];\n                up[i] = up[i - 1];\n            }\n        }\n        return Math.max(down[nums.length - 1], up[nums.length - 1]);\n    }\n}",
        "tags": "9, 17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 279,
        "number": 377,
        "title": "Combination Sum IV",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>\n\n    <p><b>Example:</b>\n    </p><pre><i><b>nums</b></i> = [1, 2, 3]\n<i><b>target</b></i> = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is <i><b>7</b></i>.\n</pre>\n    <p></p>\n\n    <p><b>Follow up:</b><br>\n        What if negative numbers are allowed in the given array?<br>\n        How does it change the problem?<br>\n        What limitation we need to add to the question to allow negative numbers? </p>\n\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Time Complexity: O(n*target)\n     * Space Complexity: O(n)\n     *\n     * Similar to Coin change\n     * dp[curNumber] = Sum(dp[reached target])\n     * if reached target + curNum < target\n     *\n     * @param nums\n     * @param target\n     * @return\n     */\n    public int combinationSum4(int[] nums, int target) {\n        if (nums == null || nums.length == 0)\n            return 0;\n\n        int[] dp = new int[target + 1];\n        dp[0] = 1;\n        for (int i = 0; i <= target; i++) {\n            for (int num : nums) {\n                if (i + num <= target) {\n                    dp[i + num] += dp[i];\n                }\n            }\n        }\n        return dp[target];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 280,
        "number": 378,
        "title": "Kth Smallest Element in a Sorted Matrix",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <i>n</i> x <i>n</i> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>\n\n    <p>\n        Note that it is the kth smallest element in the sorted order, not the kth distinct element.\n    </p>\n\n    <p><b>Example:</b>\n    </p><pre>matrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\nreturn 13.\n</pre>\n    <p></p>\n\n    <p><b>Note: </b><br>\n        You may assume k is always valid, 1 ≤ k ≤ n<sup>2</sup>.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    class Tuple implements Comparable<Tuple> {\n\t\tint x, y, val;\n\n\t\tpublic Tuple(int x, int y, int val) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.val = val;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Tuple that) {\n\t\t\treturn this.val - that.val;\n\t\t}\n\t}\n\n\tpublic int kthSmallest(int[][] matrix, int k) {\n\t    int rows = matrix.length;\n\t\tint cols = matrix[0].length;\n\t\tPriorityQueue<Tuple> pq = new PriorityQueue<>();\n\t\tfor (int j = 0; j < cols; j++)\n\t\t\tpq.offer(new Tuple(0, j, matrix[0][j]));\n\t\tfor (int i = 0; i < k - 1; i++) {\n\t\t\tTuple t = pq.poll();\n\t\t\tif (t.x == rows - 1)\n\t\t\t\tcontinue;\n\t\t\tpq.offer(new Tuple(t.x + 1, t.y, matrix[t.x + 1][t.y]));\n\t\t}\n\t\treturn pq.poll().val;\n\t}\n}",
        "tags": "6, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 281,
        "number": 380,
        "title": "Insert Delete GetRandom O(1)",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Design a data structure that supports all following operations in <i>average</i> <b>O(1)</b> time.</p>\n\n    <p>\n    </p><ol>\n    <li><code>insert(val)</code>: Inserts an item val to the set if not already present.</li>\n    <li><code>remove(val)</code>: Removes an item val from the set if present.</li>\n    <li><code>getRandom</code>: Returns a random element from current set of elements. Each element must have the <b>same probability</b> of being returned.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example:</b>\n    </p><pre>// Init an empty set.\nRandomizedSet randomSet = new RandomizedSet();\n\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomSet.insert(1);\n\n// Returns false as 2 does not exist in the set.\nrandomSet.remove(2);\n\n// Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomSet.insert(2);\n\n// getRandom should return either 1 or 2 randomly.\nrandomSet.getRandom();\n\n// Removes 1 from the set, returns true. Set now contains [2].\nrandomSet.remove(1);\n\n// 2 was already in the set, so return false.\nrandomSet.insert(2);\n\n// Since 2 is the only number in the set, getRandom always return 2.\nrandomSet.getRandom();\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class RandomizedSet {\n\n    ArrayList<Integer> nums;\n    HashMap<Integer, Integer> locs;\n    java.util.Random rand = new java.util.Random();\n    /** Initialize your data structure here. */\n    public RandomizedSet() {\n        nums = new ArrayList<Integer>();\n        locs = new HashMap<Integer, Integer>();\n    }\n\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        boolean contain = locs.containsKey(val);\n        if ( contain ) return false;\n        locs.put( val, nums.size());\n        nums.add(val);\n        return true;\n    }\n\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        boolean contain = locs.containsKey(val);\n        if ( ! contain ) return false;\n        int loc = locs.get(val);\n        if (loc < nums.size() - 1 ) { // not the last one than swap the last one with this val\n            int lastone = nums.get(nums.size() - 1 );\n            nums.set( loc , lastone );\n            locs.put(lastone, loc);\n        }\n        locs.remove(val);\n        nums.remove(nums.size() - 1);\n        return true;\n    }\n\n    /** Get a random element from the set. */\n    public int getRandom() {\n        return nums.get( rand.nextInt(nums.size()) );\n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */",
        "tags": "0, 1, 10",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 282,
        "number": 381,
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Design a data structure that supports all following operations in <i>average</i> <b>O(1)</b> time.</p>\n    <b>Note: Duplicate elements are allowed.</b>\n    <p>\n    </p><ol>\n    <li><code>insert(val)</code>: Inserts an item val to the collection.</li>\n    <li><code>remove(val)</code>: Removes an item val from the collection if present.</li>\n    <li><code>getRandom</code>: Returns a random element from current collection of elements. The probability of each element being returned is <b>linearly related</b> to the number of same value the collection contains.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example:</b>\n    </p><pre>// Init an empty collection.\nRandomizedCollection collection = new RandomizedCollection();\n\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\ncollection.insert(1);\n\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\ncollection.insert(1);\n\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\ncollection.insert(2);\n\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\ncollection.getRandom();\n\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\ncollection.remove(1);\n\n// getRandom should return 1 and 2 both equally likely.\ncollection.getRandom();\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class RandomizedCollection {\n\n    ArrayList<Integer> result;\n    HashMap<Integer, LinkedHashSet<Integer>> map;\n\n    public RandomizedCollection() {\n        result = new ArrayList<Integer>();\n        map = new HashMap<Integer, LinkedHashSet<Integer>>();\n    }\n\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    public boolean insert(int val) {\n        // Add item to map if it doesn't already exist.\n        boolean alreadyExists = map.containsKey(val);\n        if(!alreadyExists) {\n            map.put(val, new LinkedHashSet<Integer>());\n        }\n        map.get(val).add(result.size());\n        result.add(val);\n        return !alreadyExists;\n    }\n\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    public boolean remove(int val) {\n        if(!map.containsKey(val)) {\n            return false;\n        }\n        // Get arbitary index of the ArrayList that contains val\n        LinkedHashSet<Integer> valSet = map.get(val);\n        int indexToReplace = valSet.iterator().next();\n\n        // Obtain the set of the number in the last place of the ArrayList\n        int numAtLastPlace = result.get(result.size() - 1);\n        LinkedHashSet<Integer> replaceWith = map.get(numAtLastPlace);\n\n        // Replace val at arbitary index with very last number\n        result.set(indexToReplace, numAtLastPlace);\n\n        // Remove appropriate index\n        valSet.remove(indexToReplace);\n\n        // Don't change set if we were replacing the removed item with the same number\n        if(indexToReplace != result.size() - 1) {\n            replaceWith.remove(result.size() - 1);\n            replaceWith.add(indexToReplace);\n        }\n        result.remove(result.size() - 1);\n\n        // Remove map entry if set is now empty, then return\n        if(valSet.isEmpty()) {\n            map.remove(val);\n        }\n        return true;\n    }\n\n    /** Get a random element from the collection. */\n    public int getRandom() {\n        // Get linearly random item\n        return result.get((int)(Math.random() * result.size()));\n    }\n}\n\n/**\n * Your RandomizedCollection object will be instantiated and called as such:\n * RandomizedCollection obj = new RandomizedCollection();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */",
        "tags": "0, 1, 10",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 283,
        "number": 382,
        "title": "Linked List Random Node",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a singly linked list, return a random node's value from the linked list. Each node must have the <b>same probability</b> of being chosen.</p>\n\n    <p><b>Follow up:</b><br>\n        What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\n    </p>\n\n    <p><b>Example:</b>\n    </p><pre>// Init a singly linked list [1,2,3].\nListNode head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nSolution solution = new Solution(head);\n\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\nsolution.getRandom();\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n\n    ListNode head;\n    Random random;\n\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    public Solution(ListNode head) {\n        this.head = head;\n        this.random = new Random();\n    }\n\n    /** Returns a random node's value. */\n    public int getRandom() {\n        ListNode c = head;\n        int r = c.val;\n        for(int i=1; c.next != null; i++){\n            c = c.next;\n            // Reservoir Sampling\n            if(random.nextInt(i + 1) == i)\n                r = c.val;\n        }\n\n        return r;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(head);\n * int param_1 = obj.getRandom();\n */",
        "tags": "33",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 284,
        "number": 384,
        "title": "Shuffle an Array",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Shuffle a set of numbers without duplicates.\n</p>\n\n    <p><b>Example:</b>\n    </p><pre>// Init an array with set 1, 2, and 3.\nint[] nums = {1,2,3};\nSolution solution = new Solution(nums);\n\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\nsolution.shuffle();\n\n// Resets the array back to its original configuration [1,2,3].\nsolution.reset();\n\n// Returns the random shuffling of array [1,2,3].\nsolution.shuffle();\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    private int[] nums;\n    private Random random;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n        random = new Random();\n    }\n\n    /** Resets the array to its original configuration and return it. */\n    public int[] reset() {\n        return nums;\n    }\n\n    /** Returns a random shuffling of the array. */\n    public int[] shuffle() {\n        if(nums == null) return null;\n        int[] a = nums.clone();\n        for(int j = 1; j < a.length; j++) {\n            int i = random.nextInt(j + 1);\n            swap(a, i, j);\n        }\n        return a;\n    }\n\n    private void swap(int[] a, int i, int j) {\n        int t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int[] param_1 = obj.reset();\n * int[] param_2 = obj.shuffle();\n */",
        "tags": "0, 33",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 285,
        "number": 385,
        "title": "Mini Parser",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>\n\n    <p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\n\n    <p><b>Note:</b>\n        You may assume that the string is well-formed:\n    </p><ul>\n    <li>String is non-empty.</li>\n    <li>String does not contain white spaces.</li>\n    <li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li>\n</ul>\n    <p></p>\n\n    <p><b>Example 1:</b>\n    </p><pre>Given s = \"324\",\n\nYou should return a NestedInteger object which contains a single integer 324.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre>Given s = \"[123,[456,[789]]]\",\n\nReturn a NestedInteger object containing a nested list with 2 elements:\n\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     public NestedInteger();\n *\n *     // Constructor initializes a single integer.\n *     public NestedInteger(int value);\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public void setInteger(int value);\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public void add(NestedInteger ni);\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return null if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\npublic class Solution {\n    /***\n     1. If encounters '[', push current NestedInteger to stack and start a new one.\n     2. If encounters ']', end current NestedInteger and\n     pop a NestedInteger from stack to continue.\n     3. If encounters ',', append a new number to curr NestedInteger,\n     if this comma is not right after a brackets.\n     4. Update index l and r, where l shall point to the start of a integer substring,\n     while r shall points to the end+1 of substring.\n     ***/\n    public NestedInteger deserialize(String s) {\n        if (s.isEmpty())\n            return null;\n        if (s.charAt(0) != '[') // ERROR: special case\n            return new NestedInteger(Integer.valueOf(s));\n\n        Stack<NestedInteger> stack = new Stack<>();\n        NestedInteger curr = null;\n        int l = 0; // l shall point to the start of a number substring;\n        // r shall point to the end+1 of a number substring\n        for (int r = 0; r < s.length(); r++) {\n            char ch = s.charAt(r);\n            if (ch == '[') {\n                if (curr != null) {\n                    stack.push(curr);\n                }\n                curr = new NestedInteger();\n                l = r+1;\n            } else if (ch == ']') {\n                String num = s.substring(l, r);\n                if (!num.isEmpty())\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\n                if (!stack.isEmpty()) {\n                    NestedInteger pop = stack.pop();\n                    pop.add(curr);\n                    curr = pop;\n                }\n                l = r+1;\n            } else if (ch == ',') {\n                if (s.charAt(r-1) != ']') {\n                    String num = s.substring(l, r);\n                    curr.add(new NestedInteger(Integer.valueOf(num)));\n                }\n                l = r+1;\n            }\n        }\n        return curr;\n    }\n}",
        "tags": "5, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 286,
        "number": 386,
        "title": "Lexicographical Numbers",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an integer <i>n</i>, return 1 - <i>n</i> in lexicographical order.\n</p>\n\n    <p>\n        For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\n    </p>\n\n    <p>\n        Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     The basic idea is to find the next number to add.\n     Take 45 for example: if the current number is 45,\n     the next one will be 450 (450 == 45 * 10)(if 450 <= n),\n     or 46 (46 == 45 + 1) (if 46 <= n) or 5 (5 == 45 / 10 + 1)\n     (5 is less than 45 so it is for sure less than n).\n     We should also consider n = 600, and the current number = 499,\n     the next number is 5 because there are all \"9\"s after \"4\" in \"499\"\n     so we should divide 499 by 10 until the last digit is not \"9\".\n     **/\n    public List<Integer> lexicalOrder(int n) {\n        List<Integer> list = new ArrayList<>(n);\n        int curr = 1;\n        for (int i = 1; i <= n; i++) {\n            list.add(curr);\n            if (curr * 10 <= n) {\n                curr *= 10;\n            } else if (curr % 10 != 9 && curr + 1 <= n) {\n                curr++;\n            } else {\n                while ((curr / 10) % 10 == 9) {\n                    curr /= 10;\n                }\n                curr = curr / 10 + 1;\n            }\n        }\n        return list;\n    }\n}",
        "tags": "13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 287,
        "number": 388,
        "title": "Longest Absolute File Path",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Suppose we abstract our file system by a string in the following manner:</p>\n\n    <p>The string <code>\"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"</code> represents:</p>\n\n    <pre>dir\n    subdir1\n    subdir2\n        file.ext\n</pre>\n\n    <p>The directory <code>dir</code> contains an empty sub-directory <code>subdir1</code> and a sub-directory <code>subdir2</code> containing a file <code>file.ext</code>.</p>\n\n    <p>The string <code>\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"</code> represents:</p>\n\n    <pre>dir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\n</pre>\n\n    <p>The directory <code>dir</code> contains two sub-directories <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and an empty second-level sub-directory <code>subsubdir1</code>. <code>subdir2</code> contains a second-level sub-directory <code>subsubdir2</code> containing a file <code>file2.ext</code>.</p>\n\n    <p>We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is <code>\"dir/subdir2/subsubdir2/file2.ext\"</code>, and its length is <code>32</code> (not including the double quotes).</p>\n\n    <p>Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return <code>0</code>.</p>\n\n    <p><b>Note:</b><br>\n    </p><ul>\n    <li>The name of a file contains at least a <code>.</code> and an extension.</li>\n    <li>The name of a directory or sub-directory will not contain a <code>.</code>.</li>\n</ul>\n    <p></p>\n\n    <p>Time complexity required: <code>O(n)</code> where <code>n</code> is the size of the input string.</p>\n\n    <p>Notice that <code>a/aa/aaa/file1.txt</code> is not the longest file path, if there is another path <code>aaaaaaaaaaaaaaaaaaaaa/sth.png</code>.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int lengthLongestPath(String input) {\n        if(input.indexOf(\".\") == -1) return 0;\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(0); // \"dummy\" length\n        int maxLen = 0;\n        for(String s:input.split(\"\\n\")){\n            // number of \"\\t\"\n            int lev = s.lastIndexOf(\"\\t\")+1;\n            // find parent\n            while(lev+1<stack.size()) stack.pop();\n            // remove \"/t\", add\"/\"\n            int len = stack.peek()+s.length()-lev+1;\n            stack.push(len);\n            // check if it is file\n            if(s.contains(\".\"))\n                maxLen = Math.max(maxLen, len-1);\n        }\n        return maxLen;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 288,
        "number": 390,
        "title": "Elimination Game",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    There is a list of sorted integers from 1 to <i>n</i>. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.</p>\n\n    <p>Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.</p>\n\n    <p>We keep repeating the steps again, alternating left to right and right to left, until a single number remains.</p>\n\n    <p>Find the last number that remains starting with a list of length <i>n</i>.</p>\n\n    <p><b>Example:</b>\n    </p><pre>Input:\nn = 9,\n<u>1</u> 2 <u>3</u> 4 <u>5</u> 6 <u>7</u> 8 <u>9</u>\n2 <u>4</u> 6 <u>8</u>\n<u>2</u> 6\n6\n\nOutput:\n6\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int lastRemaining(int n) {\n        boolean left = true;\n        int remaining = n;\n        int step = 1;\n        int head = 1;\n        while (remaining > 1) {\n            if (left || remaining % 2 ==1) {\n                head = head + step;\n            }\n            remaining = remaining / 2;\n            step = step * 2;\n            left = !left;\n        }\n        return head;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 289,
        "number": 392,
        "title": "Is Subsequence",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string <b>s</b> and a string <b>t</b>, check if <b>s</b> is subsequence of <b>t</b>.\n</p>\n\n    <p>\n        You may assume that there is only lower case English letters in both <b>s</b> and <b>t</b>. <b>t</b> is potentially a very long (length ~= 500,000) string, and <b>s</b> is a short string (&lt;=100).\n    </p>\n\n    <p>\n        A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>\"ace\"</code> is a subsequence of <code>\"abcde\"</code> while <code>\"aec\"</code> is not).\n    </p>\n\n    <p><b>Example 1:</b><br>\n        <b>s</b> = <code>\"abc\"</code>, <b>t</b> = <code>\"ahbgdc\"</code>\n    </p>\n    <p>\n        Return <code>true</code>.\n    </p>\n\n    <p><b>Example 2:</b><br>\n        <b>s</b> = <code>\"axc\"</code>, <b>t</b> = <code>\"ahbgdc\"</code>\n    </p>\n    <p>\n        Return <code>false</code>.\n    </p>\n\n    <p><b>Follow up:</b><br>\n        If there are lots of incoming S, say S1, S2, ... , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>\n\n    <p><b>Credits:</b><br>Special thanks to <a href=\"https://leetcode.com/pbrother/\">@pbrother</a> for adding this problem and creating all test cases.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Same as fast and slow pointers.\n    public boolean isSubsequence(String s, String t) {\n        if (s.length() == 0) return true;\n        int indexS = 0, indexT = 0;\n        while (indexT < t.length()) {\n            if (t.charAt(indexT) == s.charAt(indexS)) {\n                indexS++;\n                if (indexS == s.length()) return true;\n            }\n            indexT++;\n        }\n        return false;\n    }\n}",
        "tags": "6, 9, 17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 290,
        "number": 393,
        "title": "UTF-8 Validation",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>A character in UTF8 can be from <b>1 to 4 bytes</b> long, subjected to the following rules:</p>\n    <ol>\n        <li>For 1-byte character, the first bit is a 0, followed by its unicode code.</li>\n        <li>For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.</li>\n    </ol>\n    <p>This is how the UTF-8 encoding would work:</p>\n\n    <pre><code class=\"hljs lsl\">   Char. number range  |        UTF<span class=\"hljs-number\">-8</span> octet sequence\n      (hexadecimal)    |              (binary)\n   --------------------+---------------------------------------------\n   <span class=\"hljs-number\">0000</span> <span class=\"hljs-number\">0000</span><span class=\"hljs-number\">-0000</span> <span class=\"hljs-number\">007</span>F | <span class=\"hljs-number\">0</span>xxxxxxx\n   <span class=\"hljs-number\">0000</span> <span class=\"hljs-number\">0080</span><span class=\"hljs-number\">-0000</span> <span class=\"hljs-number\">07</span>FF | <span class=\"hljs-number\">110</span>xxxxx <span class=\"hljs-number\">10</span>xxxxxx\n   <span class=\"hljs-number\">0000</span> <span class=\"hljs-number\">0800</span><span class=\"hljs-number\">-0000</span> FFFF | <span class=\"hljs-number\">1110</span>xxxx <span class=\"hljs-number\">10</span>xxxxxx <span class=\"hljs-number\">10</span>xxxxxx\n   <span class=\"hljs-number\">0001</span> <span class=\"hljs-number\">0000</span><span class=\"hljs-number\">-0010</span> FFFF | <span class=\"hljs-number\">11110</span>xxx <span class=\"hljs-number\">10</span>xxxxxx <span class=\"hljs-number\">10</span>xxxxxx <span class=\"hljs-number\">10</span>xxxxxx\n</code></pre>\n    <p>\n        Given an array of integers representing the data, return whether it is a valid utf-8 encoding.\n    </p>\n    <p>\n        <b>Note:</b><br>\n        The input is an array of integers. Only the <b>least significant 8 bits</b> of each integer is used to store the data. This means each integer represents only 1 byte of data.\n    </p>\n\n    <p>\n        <b>Example 1:</b>\n    </p><pre>data = [197, 130, 1], which represents the octet sequence: <b>11000101 10000010 00000001</b>.\n\nReturn <b>true</b>.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n</pre>\n    <p></p>\n\n    <p>\n        <b>Example 2:</b>\n    </p><pre>data = [235, 140, 4], which represented the octet sequence: <b>11101011 10001100 00000100</b>.\n\nReturn <b>false</b>.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean validUtf8(int[] data) {\n        if(data == null || data.length == 0)\n            return false;\n        boolean isValid = true;\n        for(int i = 0; i < data.length; i++) {\n            // 1 after 8th digit, 100000000\n            if(data[i] > 255)\n                return false;\n            int numberOfBytes = 0;\n            // 0xxxxxxx, 1 byte, 128(10000000)\n            if((data[i] & 128) == 0) {\n                numberOfBytes = 1;\n            } else if((data[i] & 224) == 192) {\n                // 110xxxxx, 2 bytes, 224(11100000), 192(11000000)\n                numberOfBytes = 2;\n            } else if((data[i] & 240) == 224) {\n                // 1110xxxx, 3 bytes, 240(11110000), 224(11100000)\n                numberOfBytes = 3;\n            } else if((data[i] & 248) == 240) {\n                // 11110xxx, 4 bytes, 248(11111000), 240(11110000)\n                numberOfBytes = 4;\n            } else {\n                return false;\n            }\n            // check that the next n bytes start with 10xxxxxx\n            for(int j = 1; j < numberOfBytes; j++) {\n                if(i + j >= data.length)\n                    return false;\n                if((data[i+j] & 192) != 128)\n                    return false; // 192(11000000), 128(10000000)\n            }\n            i += numberOfBytes-1;\n        }\n        return isValid;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 291,
        "number": 394,
        "title": "Decode String",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an encoded string, return it's decoded string.\n</p>\n    <p>\n        The encoding rule is: <code>k[encoded_string]</code>, where the <i>encoded_string</i> inside the square brackets is being repeated exactly <i>k</i> times. Note that <i>k</i> is guaranteed to be a positive integer.</p>\n\n    <p>\n        You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n\n    <p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <i>k</i>. For example, there won't be input like <code>3a</code> or <code>2[4]</code>.\n    </p>\n\n    <p><b>Examples:</b>\n    </p><pre>s = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String decodeString(String s) {\n        Stack<Integer> count = new Stack<>();\n        Stack<String> result = new Stack<>();\n        int i = 0;\n        result.push(\"\");\n        while (i < s.length()) {\n            char ch = s.charAt(i);\n            if (ch >= '0' && ch <= '9') {\n                int start = i;\n                while (s.charAt(i + 1) >= '0' && s.charAt(i + 1) <= '9') i++;\n                count.push(Integer.parseInt(s.substring(start, i + 1)));\n            } else if (ch == '[') {\n                result.push(\"\");\n            } else if (ch == ']') {\n                String str = result.pop();\n                StringBuilder sb = new StringBuilder();\n                int times = count.pop();\n                for (int j = 0; j < times; j += 1) {\n                    sb.append(str);\n                }\n                result.push(result.pop() + sb.toString());\n            } else {\n                result.push(result.pop() + ch);\n            }\n            i += 1;\n        }\n        return result.pop();\n    }\n}",
        "tags": "14, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 292,
        "number": 395,
        "title": "Longest Substring with At Least K Repeating Characters",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Find the length of the longest substring <b><i>T</i></b> of a given string (consists of lowercase letters only) such that every character in <b><i>T</i></b> appears no less than <i>k</i> times.\n</p>\n\n    <p><b>Example 1:</b>\n    </p><pre>Input:\ns = \"aaabb\", k = 3\n\nOutput:\n3\n\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre>Input:\ns = \"ababbc\", k = 2\n\nOutput:\n5\n\nThe longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int longestSubstring(String s, int k) {\n        char[] str = s.toCharArray();\n\n        int max = 0; // result\n        // Try substrings with 1 to 26 unique chars\n        for (int h = 1; h <= 26; h++) {\n            int[] counts = new int[26];\n            int i = 0; // slow pointer\n            int j = 0; // fast pointer\n            int unique = 0; // count of unique chars\n            int noLessThanK = 0; // count of char more than K\n            while (j < str.length) {\n                // When uniqu chars count less than h\n                // fast pointer advance\n                if (unique <= h) {\n                    int idx = str[j] - 'a';\n                    if (counts[idx] == 0)\n                        unique++;\n                    counts[idx]++;\n                    if (counts[idx] == k)\n                        noLessThanK++;\n                    j++;\n                } else {\n                    int idx = str[i] - 'a';\n                    if (counts[idx] == k)\n                        noLessThanK--;\n                    counts[idx]--;\n                    if (counts[idx] == 0)\n                        unique--;\n                    i++;\n                }\n                if (unique == h && unique == noLessThanK)\n                    max = Math.max(j - i, max);\n            }\n        }\n\n        return max;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 293,
        "number": 396,
        "title": "Rotate Function",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array of integers <code>A</code> and let <i>n</i> to be its length.\n</p>\n\n    <p>\n        Assume <code>B<sub>k</sub></code> to be an array obtained by rotating the array <code>A</code> <i>k</i> positions clock-wise, we define a \"rotation function\" <code>F</code> on <code>A</code> as follow:\n    </p>\n\n    <p>\n        <code>F(k) = 0 * B<sub>k</sub>[0] + 1 * B<sub>k</sub>[1] + ... + (n-1) * B<sub>k</sub>[n-1]</code>.</p>\n\n    <p>Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>.\n    </p>\n\n    <p><b>Note:</b><br>\n        <i>n</i> is guaranteed to be less than 10<sup>5</sup>.\n    </p>\n\n    <p><b>Example:</b>\n    </p><pre>A = [4, 3, 2, 6]\n\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int maxRotateFunction(int[] A) {\n        if(A.length == 0) return 0;\n        int n = A.length, res = Integer.MIN_VALUE;\n        for(int start = 0; start < n; start++){\n            int cur = 0, curStart = start, newStart = 0;\n            for(int i = 0; i < n; i++){\n                if(curStart < n){\n                    cur += curStart*A[i];\n                    curStart++;\n                } else {\n                    cur += newStart*A[i];\n                    newStart++;\n                }\n            }\n            res = Math.max(cur, res);\n        }\n        return res;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 294,
        "number": 397,
        "title": "Integer Replacement",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a positive integer <i>n</i> and you can do operations as follow:\n</p>\n\n    <p>\n    </p><ol>\n    <li>If <i>n</i> is even, replace <i>n</i> with <code><i>n</i>/2</code>.</li>\n    <li>If <i>n</i> is odd, you can replace <i>n</i> with either <code><i>n</i> + 1</code> or <code><i>n</i> - 1</code>.</li>\n</ol>\n    <p></p>\n\n    <p>\n        What is the minimum number of replacements needed for <i>n</i> to become 1?\n    </p>\n\n    <p></p>\n\n    <p><b>Example 1:</b>\n    </p><pre><b>Input:</b>\n8\n\n<b>Output:</b>\n3\n\n<b>Explanation:</b>\n8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre><b>Input:</b>\n7\n\n<b>Output:</b>\n4\n\n<b>Explanation:</b>\n7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\nor\n7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int integerReplacement(int n) {\n        int c = 0;\n        while (n != 1) {\n            if ((n & 1) == 0) {\n                n >>>= 1;\n            } else if (n == 3 || ((n >>> 1) & 1) == 0) {\n                // if a number ends with 01 or 3\n                --n;\n            } else {\n                ++n;\n            }\n            ++c;\n        }\n        return c;\n    }\n}",
        "tags": "3, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 295,
        "number": 398,
        "title": "Random Pick Index",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\n</p>\n\n    <p>\n        <b>Note:</b><br>\n        The array size can be very large. Solution that uses too much extra space will not pass the judge.\n    </p>\n\n    <p><b>Example:</b>\n    </p><pre>int[] nums = new int[] {1,2,3,3,3};\nSolution solution = new Solution(nums);\n\n// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(3);\n\n// pick(1) should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(1);\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n\n    int[] nums;\n    Random rnd;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n        this.rnd = new Random();\n    }\n\n    public int pick(int target) {\n        int result = -1;\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != target)\n                continue;\n            if (rnd.nextInt(++count) == 0)\n                result = i;\n        }\n        return result;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int param_1 = obj.pick(target);\n */",
        "tags": "33",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 296,
        "number": 399,
        "title": "Evaluate Division",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Equations are given in the format <code>A / B = k</code>, where  <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.\n</p>\n    <p><b>Example:</b><br>\n        Given <code> a / b = 2.0, b / c = 3.0.</code> <br>queries are: <code> a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? .</code> <br>return <code> [6.0, 0.5, -1.0, 1.0, -1.0 ].</code>\n    </p>\n    <p>\n        The input is: <code> vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries </code>, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code> vector&lt;double&gt;</code>.\n    </p>\n\n    <p>According to the example above:\n    </p><pre>equations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\nvalues = [2.0, 3.0],\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. </pre>\n    <p></p>\n\n    <p>\n        The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {\n        Map<String, Map<String, Double>> numMap = new HashMap<>();\n        int i = 0;\n        for(String[] str : equations) {\n            insertPairs(numMap, str[0], str[1], values[i]);\n            insertPairs(numMap, str[1], str[0], 1.0/values[i]);\n            i++;\n        }\n\n        double[] res = new double[queries.length];\n        i = 0;\n        for(String[] q : queries) {\n            Double resObj = handleQuery(q[0], q[1], numMap, new HashSet<>());\n            res[i++] = (resObj != null) ? resObj : -1.0;\n        }\n        return res;\n    }\n\n    public static void insertPairs(Map<String, Map<String, Double>> numMap, String num, String denom, Double value) {\n        Map<String, Double> denomMap = numMap.get(num);\n        if(denomMap == null) {\n            denomMap = new HashMap<>();\n            numMap.put(num, denomMap);\n        }\n        denomMap.put(denom, value);\n    }\n\n    public static Double handleQuery(String num, String denom, Map<String, Map<String, Double>> numMap, Set<String> visitedSet) {\n        String dupeKey = num+\":\"+denom;\n        if(visitedSet.contains(dupeKey)) return null;\n        if(!numMap.containsKey(num) || !numMap.containsKey(denom)) return null;\n        if(num.equals(denom)) return 1.0;\n\n        Map<String, Double> denomMap = numMap.get(num);\n        visitedSet.add(dupeKey);\n        for(String key : denomMap.keySet()) {\n            Double res = handleQuery(key, denom, numMap, visitedSet);\n            if(res != null) {\n                return denomMap.get(key) * res;\n            }\n        }\n        visitedSet.remove(dupeKey);\n        return null;\n    }\n}",
        "tags": "23",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 297,
        "number": 402,
        "title": "Remove K Digits",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a non-negative integer <i>num</i> represented as a string, remove <i>k</i> digits from the number so that the new number is the smallest possible.\n</p>\n\n    <p><b>Note:</b><br>\n    </p><ul>\n    <li>The length of <i>num</i> is less than 10002 and will be ≥ <i>k</i>.</li>\n    <li>The given <i>num</i> does not contain any leading zero.</li>\n</ul>\n\n    <p></p>\n\n    <p><b>Example 1:</b>\n    </p><pre>Input: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre>Input: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b>\n    </p><pre>Input: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String removeKdigits(String num, int k) {\n        int len = num.length();\n        //corner case\n        if(k==len)\n            return \"0\";\n\n        Stack<Character> stack = new Stack<>();\n        int i =0;\n        while(i<num.length()){\n            //whenever meet a digit which is less than the previous digit,\n            // discard the previous one\n            while(k>0 && !stack.isEmpty() && stack.peek()>num.charAt(i)){\n                stack.pop();\n                k--;\n            }\n            stack.push(num.charAt(i));\n            i++;\n        }\n\n        // corner case like \"1111\"\n        while(k>0){\n            stack.pop();\n            k--;\n        }\n\n        //construct the number from the stack\n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty())\n            sb.append(stack.pop());\n        sb.reverse();\n\n        //remove all the 0 at the head\n        while(sb.length()>1 && sb.charAt(0)=='0')\n            sb.deleteCharAt(0);\n        return sb.toString();\n    }\n}",
        "tags": "15, 17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 298,
        "number": 406,
        "title": "Queue Reconstruction by Height",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers <code>(h, k)</code>, where <code>h</code> is the height of the person and <code>k</code> is the number of people in front of this person who have a height greater than or equal to <code>h</code>. Write an algorithm to reconstruct the queue.\n</p>\n\n    <p><b>Note:</b><br>\n        The number of people is less than 1,100.\n    </p>\n\n    <p><b>Example</b>\n    </p><pre>Input:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\nOutput:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int[][] reconstructQueue(int[][] people) {\n        //pick up the tallest guy first\n        //when insert the next tall guy, just need to insert him into kth position\n        //repeat until all people are inserted into list\n        if (people == null || people.length == 0 || people[0].length == 0)\n            return new int[0][0];\n\n        Arrays.sort(people, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (b[0] == a[0]) return a[1] - b[1];\n                return b[0] - a[0];\n            }\n        });\n\n        int n = people.length;\n        ArrayList<int[]> tmp = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            tmp.add(people[i][1], new int[]{people[i][0], people[i][1]});\n\n        int[][] res = new int[people.length][2];\n        int i = 0;\n        for (int[] k : tmp) {\n            res[i][0] = k[0];\n            res[i++][1] = k[1];\n        }\n\n        return res;\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 299,
        "number": 413,
        "title": "Arithmetic Slices",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>\n\n    <p>For example, these are arithmetic sequence:</p>\n    <pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n    <p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre>\n    <br>\n\n    <p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>\n\n    <p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>\n        A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>\n\n    <p>The function should return the number of arithmetic slices in the array A. </p>\n    <br>\n\n    <p><b>Example:</b>\n    </p><pre>A = [1, 2, 3, 4]\n\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int curr = 0, sum = 0;\n        for (int i = 2; i < A.length; i++)\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\n                curr += 1;\n                sum += curr;\n            } else {\n                curr = 0;\n            }\n        return sum;\n    }\n}",
        "tags": "3, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 300,
        "number": 416,
        "title": "Partition Equal Subset Sum",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <b>non-empty</b> array containing <b>only positive integers</b>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>Each of the array element will not exceed 100.</li>\n    <li>The array size will not exceed 200.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b>\n    </p><pre>Input: [1, 5, 11, 5]\n\nOutput: true\n\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre>Input: [1, 2, 3, 5]\n\nOutput: false\n\nExplanation: The array cannot be partitioned into equal sum subsets.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Similar to backpack problem\n    public boolean canPartition(int[] nums) {\n        // check edge case\n        if (nums == null || nums.length == 0) {\n            return true;\n        }\n        // preprocess\n        int volumn = 0;\n        for (int num : nums) {\n            volumn += num;\n        }\n        if (volumn % 2 != 0) {\n            return false;\n        }\n        volumn /= 2;\n        // dp def\n        boolean[] dp = new boolean[volumn + 1];\n        // dp init\n        dp[0] = true;\n        // dp transition\n        for (int i = 1; i <= nums.length; i++) {\n            for (int j = volumn; j >= nums[i - 1]; j--) {\n                dp[j] = dp[j] || dp[j - nums[i - 1]];\n            }\n        }\n        return dp[volumn];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 301,
        "number": 417,
        "title": "Pacific Atlantic Water Flow",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the \"Pacific ocean\" touches the left and top edges of the matrix and the \"Atlantic ocean\" touches the right and bottom edges.</p>\n\n    <p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>\n\n    <p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The order of returned grid coordinates does not matter.</li>\n    <li>Both <i>m</i> and <i>n</i> are less than 150.</li>\n</ol>\n    <p></p>\n    <p><b>Example:</b>\n    </p><pre>Given the following 5x5 matrix:\n\n  Pacific ~   ~   ~   ~   ~\n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * Atlantic\n\nReturn:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<int[]> pacificAtlantic(int[][] matrix) {\n        List<int[]> result = new ArrayList<int[]>();\n        if (matrix.length == 0 || matrix[0].length == 0) return result;\n        // the pacific boolean table\n        boolean[][] pacific = new boolean[matrix.length][matrix[0].length];\n        // the atlantic booean table\n        boolean[][] atlantic = new boolean[matrix.length][matrix[0].length];\n        //initially, all the top and left cells are flooded with pacific water\n        //and all the right and bottom cells are flooded with atlantic water\n        for (int i = 0; i < matrix.length; i++) {\n            pacific[i][0] = true;\n            atlantic[i][matrix[0].length - 1] = true;\n        }\n        for (int i = 0; i < matrix[0].length; i++) {\n            pacific[0][i] = true;\n            atlantic[matrix.length - 1][i] = true;\n        }\n        //we go around the matrix and try to flood the matrix from 4 side.\n        for (int i = 0; i < matrix.length; i++) {\n            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];\n            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];\n            water(pacific, pacificVisited, matrix, i, 0);\n            water(atlantic, atlanticVisited, matrix, i, matrix[0].length - 1);\n        }\n        for (int i = 0; i < matrix[0].length; i++) {\n            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];\n            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];\n            water(pacific, pacificVisited, matrix, 0, i);\n            water(atlantic, atlanticVisited, matrix, matrix.length - 1, i);\n        }\n        //check the shared points among 2 tables\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    int[] element = {i, j};\n                    result.add(element);\n                }\n            }\n        }\n        return result;\n    }\n\n    //the flood function\n    private void water(boolean[][] wet, boolean[][] visited, int[][] matrix, int i, int j) {\n        wet[i][j] = true;\n        visited[i][j] = true;\n        int[] x = {0, 0, 1, -1};\n        int[] y = {1, -1, 0, 0};\n        for (int k = 0; k < 4; k++) {\n            if (i + y[k] >= 0 && i + y[k] < matrix.length && j + x[k] >= 0 && j + x[k] < matrix[0].length\n                    && !visited[i + y[k]][j + x[k]] && matrix[i + y[k]][j + x[k]] >= matrix[i][j]) {\n                water(wet, visited, matrix, i + y[k], j + x[k]);\n            }\n        }\n    }\n}",
        "tags": "14, 19",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 302,
        "number": 419,
        "title": "Battleships in a Board",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p>Given an 2D board, count how many battleships are in it. The battleships are represented with <code>'X'</code>s, empty slots are represented with <code>'.'</code>s. You may assume the following rules:\n\n    </p><ul>\n    <li>You receive a valid board, made of only battleships or empty slots.</li>\n    <li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li>\n    <li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n\n    <p><b>Example:</b><br>\n    </p><pre>X..X\n...X\n...X\n</pre>\n    In the above board there are 2 battleships.\n\n    <p><b>Invalid Example:</b><br>\n    </p><pre>...X\nXXXX\n...X\n</pre>\n    This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n    <p></p>\n    <p><b>Follow up:</b><br>Could you do it in <b>one-pass</b>, using only <b>O(1) extra memory</b> and <b>without modifying</b> the value of the board?</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int countBattleships(char[][] board) {\n        if(board.length == 0) return 0;\n        int totalCount = 0;\n        for(int row = 0; row < board.length; row++){\n            for(int col = 0; col < board[0].length; col++){\n                // Case 1: it is a .\n                if(board[row][col] == '.') continue;\n                // Case 2: it is invalid\n                if(row - 1 >= 0 && board[row-1][col] == 'X' &&\n                    col - 1 >= 0 && board[row][col-1] == 'X')\n                    return -1;\n                // Case 3: adjacent to X\n                if(row - 1 >= 0 && board[row-1][col] == 'X' ||\n                    col - 1 >= 0 && board[row][col-1] == 'X')\n                    continue;\n                // Case 4: a new ship\n                totalCount++;\n            }\n        }\n        return totalCount;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 303,
        "number": 421,
        "title": "Maximum XOR of Two Numbers in an Array",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <b>non-empty</b> array of numbers, a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, … , a<sub>n-1</sub>, where 0 ≤ a<sub>i</sub> &lt; 2<sup>31</sup>.</p>\n\n    <p>Find the maximum result of a<sub>i</sub> XOR a<sub>j</sub>, where 0 ≤ <i>i</i>, <i>j</i> &lt; <i>n</i>.</p>\n\n    <p>Could you do this in O(<i>n</i>) runtime?</p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b> [3, 10, 5, 25, 2, 8]\n\n<b>Output:</b> 28\n\n<b>Explanation:</b> The maximum result is <b>5</b> ^ <b>25</b> = 28.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n\n    class Trie {\n        Trie[] children;\n\n        public Trie() {\n            children = new Trie[2];\n        }\n    }\n\n    public int findMaximumXOR(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        // Init Trie.\n        Trie root = new Trie();\n        for (int num : nums) {\n            Trie curNode = root;\n            for (int i = 31; i >= 0; i--) {\n                int curBit = (num >>> i) & 1;\n                if (curNode.children[curBit] == null) {\n                    curNode.children[curBit] = new Trie();\n                }\n                curNode = curNode.children[curBit];\n            }\n        }\n        int max = Integer.MIN_VALUE;\n        for (int num : nums) {\n            Trie curNode = root;\n            int curSum = 0;\n            for (int i = 31; i >= 0; i--) {\n                int curBit = (num >>> i) & 1;\n                if (curNode.children[curBit ^ 1] != null) {\n                    curSum += (1 << i);\n                    curNode = curNode.children[curBit ^ 1];\n                } else {\n                    curNode = curNode.children[curBit];\n                }\n\n                // for this case: even if all left bits results are 1s,\n                // curSum still cannot catch up max value\n                if (curSum < max && max - curSum >= (1 << i) - 1) {\n                    break;\n                }\n            }\n            max = Math.max(curSum, max);\n        }\n        return max;\n    }\n}",
        "tags": "11, 22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 304,
        "number": 423,
        "title": "Reconstruct Original Digits from English",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a <b>non-empty</b> string containing an out-of-order English representation of digits <code>0-9</code>, output the digits in ascending order.</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>Input contains only lowercase English letters.</li>\n    <li>Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as \"abc\" or \"zerone\" are not permitted.</li>\n    <li>Input length is less than 50,000.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre>Input: \"owoztneoer\"\n\nOutput: \"012\"\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre>Input: \"fviefuro\"\n\nOutput: \"45\"\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String originalDigits(String s) {\n        int[] count = new int[10];\n        for (int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == 'z') count[0]++;\n            if (c == 'w') count[2]++;\n            if (c == 'x') count[6]++;\n            if (c == 's') count[7]++; //7-6\n            if (c == 'g') count[8]++;\n            if (c == 'u') count[4]++;\n            if (c == 'f') count[5]++; //5-4\n            if (c == 'h') count[3]++; //3-8\n            if (c == 'i') count[9]++; //9-8-5-6\n            if (c == 'o') count[1]++; //1-0-2-4\n        }\n        count[7] -= count[6];\n        count[5] -= count[4];\n        count[3] -= count[8];\n        count[9] = count[9] - count[8] - count[5] - count[6];\n        count[1] = count[1] - count[0] - count[2] - count[4];\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= 9; i++){\n            for (int j = 0; j < count[i]; j++){\n                sb.append(i);\n            }\n        }\n        return sb.toString();\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 305,
        "number": 424,
        "title": "Longest Repeating Character Replacement",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most <i>k</i> times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p>\n\n    <p><b>Note:</b><br>\n        Both the string's length and <i>k</i> will not exceed 10<sup>4</sup>.\n    </p>\n\n    <p>\n        <b>Example 1:</b>\n    </p><pre><b>Input:</b>\ns = \"ABAB\", k = 2\n\n<b>Output:</b>\n4\n\n<b>Explanation:</b>\nReplace the two 'A's with two 'B's or vice versa.\n</pre>\n    <p></p>\n\n    <p>\n        <b>Example 2:</b>\n    </p><pre><b>Input:</b>\ns = \"AABABBA\", k = 1\n\n<b>Output:</b>\n4\n\n<b>Explanation:</b>\nReplace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n\n     The problem says that we can make at most k changes to the string\n     (any character can be replaced with any other character).\n     So, let's say there were no constraints like the k.\n     Given a string convert it to a string with all same characters with\n     minimal changes. The answer to this is\n\n     length of the entire string - number of times of the maximum occurring character in the string\n     Given this, we can apply the at most k changes constraint and maintain a sliding window such that\n\n     (length of substring - number of times of the maximum occurring character in the substring) <= k\n\n     **/\n    public int characterReplacement(String s, int k) {\n        int len = s.length();\n        int[] count = new int[26];\n        int start = 0, maxCount = 0, maxLength = 0;\n        for (int end = 0; end < len; end++) {\n            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);\n            while (end - start + 1 - maxCount > k) {\n                count[s.charAt(start) - 'A']--;\n                start++;\n            }\n            maxLength = Math.max(maxLength, end - start + 1);\n        }\n        return maxLength;\n    }\n}",
        "tags": "4, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 306,
        "number": 433,
        "title": "Minimum Genetic Mutation",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>A gene string can be represented by an 8-character long string, with choices from <code>\"A\"</code>, <code>\"C\"</code>, <code>\"G\"</code>, <code>\"T\"</code>.</p>\n\n    <p>Suppose we need to investigate about a mutation (mutation from \"start\" to \"end\"), where ONE mutation is defined as ONE single character changed in the gene string.</p>\n\n    <p>For example, <code>\"AACCGGTT\"</code> -&gt; <code>\"AACCGGTA\"</code> is 1 mutation.</p>\n\n    <p>Also, there is a given gene \"bank\", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>\n\n    <p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from \"start\" to \"end\". If there is no such a mutation, return -1.</p>\n\n    <p><b>Note:</b>\n    </p><ol>\n    <li>Starting point is assumed to be valid, so it might not be included in the bank.</li>\n    <li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>\n    <li>You may assume start and end string is not the same.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b>\n    </p><pre>start: \"AACCGGTT\"\nend:   \"AACCGGTA\"\nbank: [\"AACCGGTA\"]\n\nreturn: 1\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre>start: \"AACCGGTT\"\nend:   \"AAACGGTA\"\nbank: [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\n\nreturn: 2\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b>\n    </p><pre>start: \"AAAAACCC\"\nend:   \"AACCCCCC\"\nbank: [\"AAAACCCC\", \"AAACCCCC\", \"AACCCCCC\"]\n\nreturn: 3\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "class Solution {\n    public int minMutation(String start, String end, String[] bank) {\n        List<Integer>[] graph = new List[bank.length];\n        for (int i = 0; i < bank.length; i++) {\n            graph[i] = new ArrayList<>();\n            for (int j = 0; j < bank.length; j++)\n                if (canMutate(bank[i], bank[j])) graph[i].add(j);\n        }\n\n        int targetIdx = -1;\n        for (int i = 0; i < bank.length; i++) {\n            if (bank[i].equals(end)) {\n                targetIdx = i;\n                break;\n            }\n        }\n        if (targetIdx == -1) return -1;\n\n        // endXXX means something calculated from end to start\n        int[] endDist = new int[bank.length];\n        Arrays.fill(endDist, -1);\n        endDist[targetIdx] = 0;\n        Queue<Integer> endQ = new ArrayDeque<>();\n        for (int idx : graph[targetIdx]) {\n            endQ.add(idx);\n            endDist[idx] = 1;\n        }\n\n        // startXXX means something calculated from start to end\n        int[] startDist = new int[bank.length];\n        Arrays.fill(startDist, -1);\n        Queue<Integer> startQ = new ArrayDeque<>();\n        for (int i = 0; i < bank.length; i++) {\n            if (canMutate(start, bank[i])) {\n                if (bank[i].equals(end)) return 1;\n                startQ.add(i);\n                startDist[i] = 1;\n            }\n        }\n\n        while (!startQ.isEmpty() && !endQ.isEmpty()) {\n            int startIdx = startQ.poll();\n            for (int nextIdx : graph[startIdx]) {\n                if (startDist[nextIdx] != -1) continue;\n                else if (endDist[nextIdx] >= 0) return startDist[startIdx] + endDist[nextIdx] + 1;\n                else {\n                    startDist[nextIdx] = startDist[startIdx] + 1;\n                    startQ.add(nextIdx);\n                }\n            }\n\n            int endIdx = endQ.poll();\n            for (int nextIdx : graph[endIdx]) {\n                if (endDist[nextIdx] != -1) continue;\n                else if (startDist[nextIdx] > 0) return startDist[nextIdx] + endDist[endIdx] + 1;\n                else {\n                    endDist[nextIdx] = endDist[endIdx] + 1;\n                    endQ.add(nextIdx);\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    private boolean canMutate(String gen1, String gen2) {\n        int diff = 0;\n        for (int i = 0; i < gen1.length(); i++)\n            diff += gen1.charAt(i) == gen2.charAt(i) ? 0 : 1;\n        return diff == 1;\n    }\n}",
        "tags": "19",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 307,
        "number": 435,
        "title": "Non-overlapping Intervals",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>You may assume the interval's end point is always bigger than its start point.</li>\n    <li>Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [ [1,2], [2,3], [3,4], [1,3] ]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> [1,3] can be removed and the rest of intervals are non-overlapping.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [ [1,2], [1,2], [1,2] ]\n\n<b>Output:</b> 2\n\n<b>Explanation:</b> You need to remove two [1,2] to make the rest of intervals non-overlapping.\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b> [ [1,2], [2,3] ]\n\n<b>Output:</b> 0\n\n<b>Explanation:</b> You don't need to remove any of the intervals since they're already non-overlapping.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for an interval.\n * public class Interval {\n * int start;\n * int end;\n * Interval() { start = 0; end = 0; }\n * Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        Arrays.sort(intervals, new Comparator<Interval>() {\n            @Override\n            public int compare(Interval o1, Interval o2) {\n                return o1.end - o2.end;  //first sort by end\n            }\n        });\n\n        int end = Integer.MIN_VALUE;\n        int count = 0;\n        for (Interval interval : intervals) {\n            if (interval.start >= end) end = interval.end;\n            else count++;\n        }\n\n        return count;\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 308,
        "number": 436,
        "title": "Find Right Interval",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.\n</p>\n\n    <p>\n        For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\n    </p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>You may assume the interval's end point is always bigger than its start point.</li>\n    <li>You may assume none of these intervals have the same start point.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [ [1,2] ]\n\n<b>Output:</b> [-1]\n\n<b>Explanation:</b> There is only one interval in the collection, so it outputs -1.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [ [3,4], [2,3], [1,2] ]\n\n<b>Output:</b> [-1, 0, 1]\n\n<b>Explanation:</b> There is no satisfied \"right\" interval for [3,4].\nFor [2,3], the interval [3,4] has minimum-\"right\" start point;\nFor [1,2], the interval [2,3] has minimum-\"right\" start point.\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b> [ [1,4], [2,3], [3,4] ]\n\n<b>Output:</b> [-1, 2, -1]\n\n<b>Explanation:</b> There is no satisfied \"right\" interval for [1,4] and [3,4].\nFor [2,3], the interval [3,4] has minimum-\"right\" start point.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for an interval.\n * public class Interval {\n * int start;\n * int end;\n * Interval() { start = 0; end = 0; }\n * Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n    public int[] findRightInterval(Interval[] intervals) {\n        int[] result = new int[intervals.length];\n        TreeMap<Integer, Integer> intervalMap = new TreeMap<>();\n\n        for (int i = 0; i < intervals.length; ++i) {\n            intervalMap.put(intervals[i].start, i);\n        }\n\n        for (int i = 0; i < intervals.length; ++i) {\n            Map.Entry<Integer, Integer> entry =\n                    intervalMap.ceilingEntry(intervals[i].end);\n            result[i] = (entry != null) ? entry.getValue() : -1;\n        }\n\n        return result;\n    }\n}",
        "tags": "6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 309,
        "number": 442,
        "title": "Find All Duplicates in an Array",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array of integers, 1 ≤ a[i] ≤ <i>n</i> (<i>n</i> = size of array), some elements appear <b>twice</b> and others appear <b>once</b>.</p>\n\n    <p>Find all the elements that appear <b>twice</b> in this array.</p>\n\n    <p>Could you do it without extra space and in O(<i>n</i>) runtime?</p>\n    <p></p>\n    <p><b>Example:</b><br>\n    </p><pre><b>Input:</b>\n[4,3,2,7,8,2,3,1]\n\n<b>Output:</b>\n[2,3]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        // creating a new List\n        List<Integer> newList = new ArrayList<Integer>();\n        for (int i = 0; i < nums.length; i++) {\n            // Taking the absolute value to find index\n            int index = Math.abs(nums[i]);\n            if (nums[index - 1] > 0) {\n                nums[index - 1] = -nums[index - 1];\n            } else {\n                // If it is not greater than 0 (i.e)\n                // negative then the number is a duplicate\n                newList.add(Math.abs(nums[i]));\n            }\n        }\n        return newList;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 310,
        "number": 445,
        "title": "Add Two Numbers II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>You are given two <b>non-empty</b> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n\n    <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n    <p><b>Follow up:</b><br>\n        What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\n    </p>\n\n    <p>\n        <b>Example:</b>\n    </p><pre><b>Input:</b> (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n<b>Output:</b> 7 -&gt; 8 -&gt; 0 -&gt; 7\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        Stack<Integer> s1 = new Stack<Integer>();\n        Stack<Integer> s2 = new Stack<Integer>();\n\n        while (l1 != null) {\n            s1.push(l1.val);\n            l1 = l1.next;\n        }\n        ;\n        while (l2 != null) {\n            s2.push(l2.val);\n            l2 = l2.next;\n        }\n\n        int sum = 0;\n        ListNode list = new ListNode(0);\n        while (!s1.empty() || !s2.empty()) {\n            if (!s1.empty()) sum += s1.pop();\n            if (!s2.empty()) sum += s2.pop();\n            list.val = sum % 10;\n            ListNode head = new ListNode(sum / 10);\n            head.next = list;\n            list = head;\n            sum /= 10;\n        }\n\n        return list.val == 0 ? list.next : list;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 311,
        "number": 449,
        "title": "Serialize and Deserialize BST",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. </p>\n\n    <p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n    <p>\n        <b>The encoded string should be as compact as possible.</b>\n    </p>\n\n    <p>\n        <b>Note:</b> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    private static final String SEP = \",\";\n    private static final String NULL = \"null\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        if (root == null) return NULL;\n        //traverse it recursively if you want to, I am doing it iteratively here\n        Stack<TreeNode> st = new Stack<>();\n        st.push(root);\n        while (!st.empty()) {\n            root = st.pop();\n            sb.append(root.val).append(SEP);\n            if (root.right != null) st.push(root.right);\n            if (root.left != null) st.push(root.left);\n        }\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    // pre-order traversal\n    public TreeNode deserialize(String data) {\n        if (data.equals(NULL)) return null;\n        String[] strs = data.split(SEP);\n        Queue<Integer> q = new LinkedList<>();\n        for (String e : strs) {\n            q.offer(Integer.parseInt(e));\n        }\n        return getNode(q);\n    }\n\n    // some notes:\n    //   5\n    //  3 6\n    // 2   7\n    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7\n        if (q.isEmpty()) return null;\n        TreeNode root = new TreeNode(q.poll());//root (5)\n        Queue<Integer> samllerQueue = new LinkedList<>();\n        while (!q.isEmpty() && q.peek() < root.val) {\n            samllerQueue.offer(q.poll());\n        }\n        //smallerQueue : 3,2   storing elements smaller than 5 (root)\n        root.left = getNode(samllerQueue);\n        //q: 6,7   storing elements bigger than 5 (root)\n        root.right = getNode(q);\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
        "tags": "12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 312,
        "number": 450,
        "title": "Delete Node in a BST",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>\n\n    <p>Basically, the deletion can be divided into two stages:\n    </p><ol>\n    <li>Search for a node to remove.</li>\n    <li>If the node is found, delete the node.</li>\n</ol>\n    <p></p>\n\n    <p><b>Note:</b> Time complexity should be O(height of tree).</p>\n\n    <p><b>Example:</b>\n    </p><pre>root = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) return null;\n        if (root.val == key) return replaceNode(root);\n\n        TreeNode parent = root;\n        TreeNode current = (key < root.val) ? root.left : root.right;\n\n        while (current != null) {\n            if (current.val == key) {\n                if (current == parent.left) {\n                    parent.left = replaceNode(current);\n                } else {\n                    parent.right = replaceNode(current);\n                }\n                return root;\n            } else {\n                parent = current;\n                current = (key < current.val) ? current.left : current.right;\n            }\n        }\n        return root;\n    }\n\n    TreeNode replaceNode(TreeNode node) {\n        if (node.left == null && node.right == null) return null;\n        if (node.left != null && node.right == null) return node.left;\n        if (node.left == null && node.right != null) return node.right;\n\n        TreeNode parent = node, current = node.right;\n        while (current.left != null) {\n            parent = current;\n            current = current.left;\n        }\n\n        if (node.right == current) {\n            current.left = node.left;\n        } else {\n            parent.left = current.right;\n            current.right = node.right;\n            current.left = node.left;\n        }\n        return current;\n\n    }\n}",
        "tags": "12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 313,
        "number": 451,
        "title": "Sort Characters By Frequency",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string, sort it in decreasing order based on the frequency of characters.</p>\n\n    <p><b>Example 1:</b>\n    </p><pre><b>Input:</b>\n\"tree\"\n\n<b>Output:</b>\n\"eert\"\n\n<b>Explanation:</b>\n'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre><b>Input:</b>\n\"cccaaa\"\n\n<b>Output:</b>\n\"cccaaa\"\n\n<b>Explanation:</b>\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\nNote that \"cacaca\" is incorrect, as the same characters must be together.\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b>\n    </p><pre><b>Input:</b>\n\"Aabb\"\n\n<b>Output:</b>\n\"bbAa\"\n\n<b>Explanation:</b>\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String frequencySort(String s) {\n        if (s == null) return null;\n\n        Map<Character, Integer> map = new HashMap();\n        char[] charArray = s.toCharArray();\n        int max = 0;\n        for (Character c : charArray) {\n            if (!map.containsKey(c)) {\n                map.put(c, 0);\n            }\n            map.put(c, map.get(c) + 1);\n            max = Math.max(max, map.get(c));\n        }\n\n        List<Character>[] array = buildArray(map, max);\n        return buildString(array);\n    }\n\n    private List<Character>[] buildArray(Map<Character, Integer> map, int maxCount) {\n        List<Character>[] array = new List[maxCount + 1];\n        for (Character c : map.keySet()) {\n            int count = map.get(c);\n            if (array[count] == null) {\n                array[count] = new ArrayList();\n            }\n            array[count].add(c);\n        }\n        return array;\n    }\n\n    private String buildString(List<Character>[] array) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = array.length - 1; i > 0; i--) {\n            List<Character> list = array[i];\n            if (list != null) {\n                for (Character c : list) {\n                    for (int j = 0; j < i; j++) {\n                        sb.append(c);\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }\n}",
        "tags": "1, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 314,
        "number": 452,
        "title": "Minimum Number of Arrows to Burst Balloons",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 10<sup>4</sup> balloons.</p>\n\n    <p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with x<sub>start</sub> and x<sub>end</sub> bursts by an arrow shot at x if x<sub>start</sub> ≤ x ≤ x<sub>end</sub>. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. </p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b>\n[[10,16], [2,8], [1,6], [7,12]]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nOne way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /***\n\n     Idea:\n     We know that eventually we have to shoot down every balloon, so for each ballon\n     there must be an arrow whose position is between balloon[0] and balloon[1].\n     Given that, we can sort the array of balloons by their ending position.\n     Then we make sure that while we take care of each balloon from the beginning,\n     we can shoot as many following balloons as possible.\n\n     So what position should we pick? We should shoot as right as possible,\n     because all balloons' end position is to the right of the current one.\n     Therefore the position should be currentBalloon[1],\n     because we still need to shoot down the current one.\n\n     This is exactly what I do in the for loop:\n     check how many balloons I can shoot down with one shot aiming at\n     the ending position of the current balloon.\n     Then I skip all these balloons and start again from the next one\n     (or the leftmost remaining one) that needs another arrow.\n\n     ***/\n    public int findMinArrowShots(int[][] points) {\n        if (points == null || points.length == 0 || points[0].length == 0)\n            return 0;\n        Arrays.sort(points, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (a[0] == b[0])\n                    return a[1] - b[1];\n                return a[0] - b[0];\n            }\n        });\n\n        int minArrows = 1;\n        int arrowLimit = points[0][1];\n        for (int i = 1; i < points.length; i++) {\n            int[] baloon = points[i];\n            if (baloon[0] <= arrowLimit) {\n                arrowLimit = Math.min(arrowLimit, baloon[1]);\n            } else {\n                minArrows++;\n                arrowLimit = baloon[1];\n            }\n        }\n        return minArrows;\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 315,
        "number": 454,
        "title": "4Sum II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>\n\n    <p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2<sup>28</sup> to 2<sup>28</sup> - 1 and the result is guaranteed to be at most 2<sup>31</sup> - 1.</p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b>\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nThe two tuples are:\n1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Time complexity:  O(n^2)\n    // Space complexity: O(n^2)\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < C.length; i++) {\n            for (int j = 0; j < D.length; j++) {\n                int sum = C[i] + D[j];\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < A.length; i++) {\n            for (int j = 0; j < B.length; j++) {\n                res += map.getOrDefault(-1 * (A[i] + B[j]), 0);\n            }\n        }\n        return res;\n    }\n}",
        "tags": "1, 6",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 316,
        "number": 456,
        "title": "132 Pattern",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a sequence of n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, a 132 pattern is a subsequence a<sub><b>i</b></sub>, a<sub><b>j</b></sub>, a<sub><b>k</b></sub> such\n    that <b>i</b> &lt; <b>j</b> &lt; <b>k</b> and a<sub><b>i</b></sub> &lt; a<sub><b>k</b></sub> &lt; a<sub><b>j</b></sub>. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n\n    <p><b>Note:</b> n will be less than 15,000.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [1, 2, 3, 4]\n\n<b>Output:</b> False\n\n<b>Explanation:</b> There is no 132 pattern in the sequence.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [3, 1, 4, 2]\n\n<b>Output:</b> True\n\n<b>Explanation:</b> There is a 132 pattern in the sequence: [1, 4, 2].\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b> [-1, 3, 2, 0]\n\n<b>Output:</b> True\n\n<b>Explanation:</b> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n\n    class Pair {\n        int min, max;\n\n        public Pair(int min, int max) {\n            this.min = min;\n            this.max = max;\n        }\n    }\n\n    public boolean find132pattern(int[] nums) {\n        Stack<Pair> stack = new Stack();\n        for (int n : nums) {\n            if (stack.isEmpty() || n < stack.peek().min)\n                stack.push(new Pair(n, n));\n            else if (n > stack.peek().min) {\n                Pair last = stack.pop();\n                if (n < last.max)\n                    return true;\n                last.max = n;\n                while (!stack.isEmpty() && n >= stack.peek().max)\n                    stack.pop();\n                // At this time, n < stack.peek().max (if stack not empty)\n                if (!stack.isEmpty() && stack.peek().min < n)\n                    return true;\n                stack.push(last);\n            }\n        }\n        return false;\n    }\n}",
        "tags": "15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 317,
        "number": 462,
        "title": "Minimum Moves to Equal Array Elements II",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p></p><p>Given a <b>non-empty</b> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n\n    <p>You may assume the array's length is at most 10,000.</p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b>\n[1,2,3]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nOnly two moves are needed (remember each move increments or decrements one element):\n\n[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]\n</pre>\n    <p></p><p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int minMoves2(int[] nums) {\n        int sum = 0;\n        int median = quickselect(nums, nums.length / 2 + 1, 0, nums.length - 1);\n        for (int i = 0; i < nums.length; i++)\n            sum += Math.abs(nums[i] - median);\n        return sum;\n    }\n\n    private int quickselect(int[] A, int k, int start, int end) {\n        int l = start, r = end, pivot = A[(l + r) / 2];\n        while (l <= r) {\n            while (A[l] < pivot) l++;\n            while (A[r] > pivot) r--;\n            if (l >= r) break;\n            swap(A, l++, r--);\n        }\n        if (l - start + 1 > k)\n            return quickselect(A, k, start, l - 1);\n        if (l - start + 1 == k && l == r)\n            return A[l];\n        return quickselect(A, k - r + start - 1, r + 1, end);\n    }\n\n    private void swap(int[] A, int i, int j) {\n        int temp = A[i];\n        A[i] = A[j];\n        A[j] = temp;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 318,
        "number": 464,
        "title": "Can I Win",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. </p>\n\n    <p>What if we change the game so that players cannot re-use integers? </p>\n\n    <p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>\n\n    <p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally. </p>\n\n    <p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.\n    </p>\n\n    <p><b>Example</b>\n    </p><pre><b>Input:</b>\nmaxChoosableInteger = 10\ndesiredTotal = 11\n\n<b>Output:</b>\nfalse\n\n<b>Explanation:</b>\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\n        if(sum < desiredTotal) return false;\n        if(desiredTotal <= 0) return true;\n\n        Map<Integer, Boolean> map = new HashMap();\n        boolean[] used = new boolean[maxChoosableInteger+1];\n        return helper(desiredTotal, used, map);\n    }\n\n    private boolean helper(int desiredTotal, boolean[] used, Map<Integer, Boolean> map){\n        if(desiredTotal <= 0) return false;\n        int key = format(used);\n        if(!map.containsKey(key)){\n            // try every unchosen number as next step\n            for(int i = 1; i < used.length; i++){\n                if(used[i]) continue;\n                used[i] = true;\n                // check whether this lead to a win (i.e. the other player lose)\n                if(!helper(desiredTotal - i, used, map)){\n                    map.put(key, true);\n                    used[i] = false;\n                    return true;\n                }\n                used[i] = false;\n            }\n            map.put(key, false);\n        }\n        return map.get(key);\n    }\n\n    // transfer boolean[] to an Integer\n    private int format(boolean[] used){\n        int num = 0;\n        for(boolean b: used){\n            num <<= 1;\n            if(b) num |= 1;\n        }\n        return num;\n    }\n}",
        "tags": "9, 33",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 319,
        "number": 468,
        "title": "Validate IP Address",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\n</p>\n\n    <p>\n        <b>IPv4</b> addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (\".\"), e.g.,<code>172.16.254.1</code>;\n    </p>\n\n    <p>\n        Besides, leading zeros in the IPv4 is invalid. For example, the address <code>172.16.254.01</code> is invalid.\n    </p>\n\n    <p>\n        <b>IPv6</b> addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (\":\"). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).\n    </p>\n\n\n    <p>\n        However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.\n    </p>\n\n    <p>\n        Besides, extra leading zeros in the IPv6 is also invalid. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is invalid.\n    </p>\n\n\n    <p><b>Note:</b>\n        You may assume there is no extra space or special characters in the input string.\n    </p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> \"172.16.254.1\"\n\n<b>Output:</b> \"IPv4\"\n\n<b>Explanation:</b> This is a valid IPv4 address, return \"IPv4\".\n</pre>\n    <p></p>\n\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\n\n<b>Output:</b> \"IPv6\"\n\n<b>Explanation:</b> This is a valid IPv6 address, return \"IPv6\".\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b> \"256.256.256.256\"\n\n<b>Output:</b> \"Neither\"\n\n<b>Explanation:</b> This is neither a IPv4 address nor a IPv6 address.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String validIPAddress(String IP) {\n        if (isValidIPv4(IP))\n            return \"IPv4\";\n        else if (isValidIPv6(IP))\n            return \"IPv6\";\n        else\n            return \"Neither\";\n    }\n\n    private boolean isValidIPv4(String ip) {\n        String[] tokens = ip.split(\"\\\\.\");\n        if (ip.length() < 7 || ip.charAt(0) == '.' ||\n                ip.charAt(ip.length() - 1) == '.' || tokens.length != 4)\n            return false;\n        for (String token : tokens) {\n            if (token.startsWith(\"0\") && token.length() > 1)\n                return false;\n            try {\n                int parsedInt = Integer.parseInt(token);\n                if (parsedInt < 0 || parsedInt > 255 ||\n                        parsedInt == 0 && token.charAt(0) != '0')\n                    return false;\n            } catch (NumberFormatException nfe) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isValidIPv6(String ip) {\n        String[] tokens = ip.split(\":\");\n        if (ip.length() < 15 || ip.charAt(0) == ':' ||\n                ip.charAt(ip.length() - 1) == ':' || tokens.length != 8)\n            return false;\n        for (String token : tokens) {\n            if (token.length() > 4 || token.length() == 0)\n                return false;\n            char[] chars = token.toCharArray();\n            for (char c : chars) {\n                if (!Character.isDigit(c) && !((c - 'A') >= 0 && (c - 'A') <= 5) &&\n                        !((c - 'a') >= 0 && (c - 'a') <= 5))\n                    return false;\n            }\n        }\n        return true;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 320,
        "number": 473,
        "title": "Matchsticks to Square",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used <b>exactly</b> one time.</p>\n\n    <p> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [1,1,2,2,2]\n<b>Output:</b> true\n\n<b>Explanation:</b> You can form a square with length 2, one side of the square came two sticks with length 1.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [3,3,3,3,4]\n<b>Output:</b> false\n\n<b>Explanation:</b> You cannot find a way to form a square with all the matchsticks.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The length sum of the given matchsticks is in the range of <code>0</code> to <code>10^9</code>.\n    </li><li>The length of the given matchstick array will not exceed <code>15</code>.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean makesquare(int[] nums) {\n        if (nums == null || nums.length < 4) return false;\n        int sum = 0;\n        for (int num : nums) sum += num;\n        if (sum % 4 != 0) return false;\n\n        Arrays.sort(nums);\n        reverse(nums);\n\n        return dfs(nums, new int[4], 0, sum / 4);\n    }\n\n    private boolean dfs(int[] nums, int[] sums, int index, int target) {\n        if (index == nums.length) {\n            if (sums[0] == target && sums[1] == target && sums[2] == target) {\n                return true;\n            }\n            return false;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            if (sums[i] + nums[index] < target) continue;\n            sums[i] += nums[index];\n            if (dfs(nums, sums, index + 1, target)) return true;\n            sums[i] -= nums[index];\n        }\n        return false;\n    }\n\n    private void reverse(int[] nums) {\n        int i = 0, j = nums.length - 1;\n        while (i < j) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n            i++;\n            j--;\n        }\n    }\n}",
        "tags": "14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 321,
        "number": 474,
        "title": "Ones and Zeroes",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\n    <p>For now, suppose you are a dominator of <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p>\n\n    <p>\n        Now your task is to find the maximum number of strings that you can form with given <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most <b>once</b>.\n    </p>\n\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The given numbers of <code>0s</code> and <code>1s</code> will both not exceed <code>100</code></li>\n    <li>The size of given string array won't exceed <code>600</code>.</li>\n</ol>\n    <p></p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\n<b>Output:</b> 4\n\n<b>Explanation:</b> This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n<b>Output:</b> 2\n\n<b>Explanation:</b> You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int[][] max = new int[m + 1][n + 1];\n        for (int i = 0; i < strs.length; i++) {\n            String str = strs[i];\n            int neededZero = 0;\n            int neededOne = 0;\n            for (int j = 0; j < str.length(); j++) {\n                if (str.charAt(j) == '0') {\n                    neededZero++;\n                } else {\n                    neededOne++;\n                }\n            }\n\n            int[][] newMax = new int[m + 1][n + 1];\n            for (int zero = 0; zero <= m; zero++) {\n                for (int one = 0; one <= n; one++) {\n                    if (zero >= neededZero && one >= neededOne) {\n                        int zeroLeft = zero - neededZero;\n                        int oneLeft = one - neededOne;\n                        // Since we have one valid combination so +1\n                        newMax[zero][one] = Math.max(1 + max[zeroLeft][oneLeft], max[zero][one]);\n                    } else {\n                        newMax[zero][one] = max[zero][one];\n                    }\n                }\n            }\n            max = newMax;\n        }\n        return max[m][n];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 322,
        "number": 477,
        "title": "Total Hamming Distance",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n    <p>Now your job is to find the total Hamming distance between all pairs of the given numbers.\n\n\n    </p><p><b>Example:</b><br>\n</p><pre><b>Input:</b> 4, 14, 2\n\n<b>Output:</b> 6\n\n<b>Explanation:</b> In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case). So the answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>Elements of the given array are in the range of <code>0 </code> to <code>10^9</code>\n    </li><li>Length of the array will not exceed <code>10^4</code>. </li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int totalHammingDistance(int[] nums) {\n        int total = 0, n = nums.length;\n        for (int j = 0; j < 32; j++) {\n            int bitCount = 0;\n            for (int i = 0; i < n; i++)\n                bitCount += (nums[i] >> j) & 1;\n            total += bitCount * (n - bitCount);\n        }\n        return total;\n    }\n}",
        "tags": "22",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 323,
        "number": 481,
        "title": "Magical String",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    A magical string <b>S</b> consists of only '1' and '2' and obeys the following rules:\n</p>\n    <p>\n        The string <b>S</b> is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string <b>S</b> itself.\n    </p>\n\n    <p>\n        The first few elements of string <b>S</b> is the following:\n        <b>S</b> = \"1221121221221121122……\"\n    </p>\n\n    <p>\n        If we group the consecutive '1's and '2's in <b>S</b>, it will be:\n    </p>\n    <p>\n        1   22  11  2  1  22  1  22  11  2  11  22 ......\n    </p>\n    <p>\n        and the occurrences of '1's or '2's in each group are:\n    </p>\n    <p>\n        1   2\t   2    1   1    2     1    2     2    1    2    2 ......\n    </p>\n\n    <p>\n        You can see that the occurrence sequence above is the <b>S</b> itself.\n    </p>\n\n    <p>\n        Given an integer N as input, return the number of '1's in the first N number in the magical string <b>S</b>.\n    </p>\n\n    <p><b>Note:</b>\n        N will not exceed 100,000.\n    </p>\n\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> 6\n<b>Output:</b> 3\n<b>Explanation:</b> The first 6 elements of magical string S is \"12211\" and it contains three 1's, so return 3.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int magicalString(int n) {\n        if (n <= 0) return 0;\n        if (n <= 3) return 1;\n\n        // Create an int array a and initialize the first 3 elements\n        int[] a = new int[n + 1];\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 2;\n        // head is the index to generate new numbers\n        int head = 2;\n        // tail is the index to put the new number\n        int tail = 3;\n        int num = 1; // current number\n        int result = 1;\n\n        while (tail < n) {\n            // Generate number with count of a[head]\n            for (int i = 0; i < a[head]; i++) {\n                a[tail] = num;\n                if (num == 1 && tail < n)\n                    result++;\n                tail++;\n            }\n            // flip number back and forth between 1 and 2\n            num = num ^ 3;\n            head++;\n        }\n\n        return result;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 324,
        "number": 523,
        "title": "Continuous Subarray Sum",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a list of <b>non-negative</b> numbers and a target <b>integer</b> k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of <b>k</b>, that is, sums up to n*k where n is also an <b>integer</b>.\n</p>\n\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> [23, 2, 4, 6, 7],  k=6\n<b>Output:</b> True\n<b>Explanation:</b> Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\n</pre>\n    <p></p>\n\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> [23, 2, 6, 4, 7],  k=6\n<b>Output:</b> True\n<b>Explanation:</b> Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The length of the array won't exceed 10,000.</li>\n    <li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // if a % c == b % c，then (a-b) / c == 0\n    public boolean checkSubarraySum(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int runningSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            runningSum += nums[i];\n            if (k != 0)\n                runningSum %= k;\n            Integer prev = map.get(runningSum);\n            if (prev != null) {\n                if (i - prev > 1) return true;\n            } else\n                map.put(runningSum, i);\n        }\n        return false;\n    }\n}",
        "tags": "3, 9",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 325,
        "number": 592,
        "title": "Fraction Addition and Subtraction",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be <a href=\"https://en.wikipedia.org/wiki/Irreducible_fraction\">irreducible fraction</a>. If your final result is an integer, say <code>2</code>, you need to change it to the format of fraction that has denominator <code>1</code>. So in this case, <code>2</code> should be converted to <code>2/1</code>.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b>\"-1/2+1/2\"\n<b>Output:</b> \"0/1\"\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b>\"-1/2+1/2+1/3\"\n<b>Output:</b> \"1/3\"\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b>\"1/3-1/2\"\n<b>Output:</b> \"-1/6\"\n</pre>\n    <p></p>\n\n    <p><b>Example 4:</b><br>\n    </p><pre><b>Input:</b>\"5/3+1/3\"\n<b>Output:</b> \"2/1\"\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The input string only contains <code>'0'</code> to <code>'9'</code>, <code>'/'</code>, <code>'+'</code> and <code>'-'</code>. So does the output.</li>\n    <li>Each fraction (input and output) has format <code>±numerator/denominator</code>. If the first input fraction or the output is positive, then <code>'+'</code> will be omitted.</li>\n    <li>The input only contains valid <b>irreducible fractions</b>, where the <b>numerator</b> and <b>denominator</b> of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.</li>\n    <li>The number of given fractions will be in the range [1,10].</li>\n    <li>The numerator and denominator of the <b>final result</b> are guaranteed to be valid and in the range of 32-bit int.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    private int gcd(int x, int y){\n        if(y == 0) return x;\n        return gcd(y, x % y);\n    }\n\n    public String fractionAddition(String expression) {\n        StringBuilder res = new StringBuilder();\n        // Split the expression to get fracs\n        if(expression.charAt(0) != '-' && expression.charAt(0) != '+')\n            expression = '+' + expression;\n        String[] fracs = expression.split(\"[+-]\");\n        // Get signs of each fracs\n        int[] signs = new int[fracs.length];\n        int signInd = 0;\n        for(int i = 0; i < expression.length(); i++){\n            if(expression.charAt(i) == '+' || expression.charAt(i) == '-')\n                signs[signInd++] = expression.charAt(i) == '+' ? 1 : -1;\n        }\n        // x is sum of nomerator and y is total denominator\n        // starts with x/y = 0/1\n        int x = 0, y = 1;\n        for(int i = 1; i < fracs.length; i++){\n            String f = fracs[i];\n            String[] ft = f.split(\"/\");\n            // numerator\n            int a = Integer.valueOf(ft[0])*signs[i-1];\n            // denominator\n            int b = Integer.valueOf(ft[1]);\n            x = x*b + a*y;\n            y *= b;\n        }\n        // If x <= 0\n        if(x == 0){\n            y = 1;\n        } else if (x < 0){\n            res.append('-');\n            x *= -1;\n        }\n        // x and y > 0\n        if (x > 0 && y > 0){\n            int g = gcd(x, y);\n            x /= g;\n            y /= g;\n        }\n        res.append(String.valueOf(x) + '/' + String.valueOf(y));\n        return res.toString();\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 326,
        "number": 593,
        "title": "Valid Square",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given the coordinates of four points in 2D space, return whether the four points could construct a square.</p>\n\n    <p>The coordinate (x,y) of a point is represented by an integer array with two integers.</p>\n\n    <p><b>Example:</b><br>\n    </p><pre><b>Input:</b> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n<b>Output:</b> True\n</pre>\n    <p></p>\n\n    <p> Note:\n    </p><ol>\n    <li>All the input integers are in the range [-10000, 10000].</li>\n    <li>A valid square has four equal sides with positive length and four equal angles (90-degree angles).</li>\n    <li>Input points have no order.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[][] p = {p1,p2,p3,p4};\n        return checkAllPermutations(p, 0);\n    }\n\n    private boolean checkAllPermutations(int[][] p, int l) {\n        if (l == 4) {\n            return check(p[0], p[1], p[2], p[3]);\n        }\n\n        boolean res = false;\n        for (int i = l; i < 4; i++) {\n            swap(p, l, i);\n            res |= checkAllPermutations(p, l + 1);\n            swap(p, l, i);\n        }\n        return res;\n    }\n\n    private boolean check(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return dist(p1,p2) > 0 && dist(p1, p2) == dist(p2, p3) &&\n            dist(p2, p3) == dist(p3, p4) && dist(p3, p4) == dist(p4, p1) &&\n            dist(p1, p3) == dist(p2, p4);\n    }\n\n    private double dist(int[] p1, int[] p2) {\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) +\n            (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n\n    private void swap(int[][] p, int x, int y) {\n        int[] temp = p[x];\n        p[x] = p[y];\n        p[y] = temp;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 327,
        "number": 609,
        "title": "Find Duplicate File in System",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p>\n\n    <p>A group of duplicate files consists of at least <b>two</b> files that have exactly the same content.</p>\n\n    <p>A single directory info string in the <b>input</b> list has the following format: </p>\n    <p><code>\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"</code><br></p>\n    <p>It means there are <b>n</b> files (<code>f1.txt</code>, <code>f2.txt</code> ... <code>fn.txt</code> with content <code>f1_content</code>, <code>f2_content</code> ... <code>fn_content</code>, respectively) in directory <code>root/d1/d2/.../dm</code>. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory.</p>\n\n    <p>The <b>output</b> is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: </p>\n    <p><code>\"directory_path/file_name.txt\"</code></p>\n\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b>\n[\"root/a 1.txt(abcd) 2.txt(efgh)\", \"root/c 3.txt(abcd)\", \"root/c/d 4.txt(efgh)\", \"root 4.txt(efgh)\"]\n<b>Output:</b>\n[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n    <p></p>\n\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>No order is required for the final output.</li>\n    <li>You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].</li>\n    <li>The number of files given is in the range of [1,20000].</li>\n    <li>You may assume no files or directories share the same name in the same directory.</li>\n    <li>You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.</li>\n</ol>\n    <p></p>\n\n\n    <b>Follow-up beyond contest:</b>\n    <ol>\n        <li> Imagine you are given a real file system, how will you search files? DFS or BFS?</li>\n        <li> If the file content is very large (GB level), how will you modify your solution?</li>\n        <li> If you can only read the file by 1kb each time, how will you modify your solution?</li>\n        <li> What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?</li>\n        <li> How to make sure the duplicated files you find are not false positive?</li>\n    </ol><p></p>\n</div>",
        "solution": "public class Solution {\n    // Time complexity : O(n*x). n strings of average length x is parsed.\n    // Space complexity : O(n*x). map and res size grows upto n*x.\n    public List<List<String>> findDuplicate(String[] paths) {\n        Map<String, List<String>> map = new HashMap<>();\n        for (String path: paths) {\n            String[] values = path.split(\" \");\n            for (int i = 1; i < values.length; i++) {\n                String[] name_cont = values[i].split(\"\\\\(\");\n                name_cont[1] = name_cont[1].replace(\")\", \"\");\n                List<String> list = map.getOrDefault(name_cont[1], new ArrayList<String>());\n                list.add(values[0] + \"/\" + name_cont[0]);\n                map.put(name_cont[1], list);\n            }\n        }\n        List<List<String>> res = new ArrayList<>();\n        for (String key: map.keySet()) {\n            if (map.get(key).size() > 1)\n                res.add(map.get(key));\n        }\n        return res;\n    }\n}",
        "tags": "1, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 328,
        "number": 611,
        "title": "Valid Triangle Number",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p>Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n\n    </p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [2,2,3,4]\n<b>Output:</b> 3\n<b>Explanation:</b>\nValid combinations are:\n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The length of the given array won't exceed 1000.</li>\n    <li>The integers in the given array are in the range of [0, 1000].</li>\n</ol>\n    <p></p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public int triangleNumber(int[] nums) {\n        int result = 0;\n        if (nums.length < 3) return result;\n\n        Arrays.sort(nums);\n\n        for (int i = 2; i < nums.length; i++) {\n            int left = 0, right = i - 1;\n            while (left < right) {\n                if (nums[left] + nums[right] > nums[i]) {\n                    result += (right - left);\n                    right--;\n                }\n                else {\n                    left++;\n                }\n            }\n        }\n\n        return result;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 329,
        "number": 621,
        "title": "Task Scheduler",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>\n\n    <p>However, there is a non-negative cooling interval <b>n</b> that means between two <b>same tasks</b>, there must be at least n intervals that CPU are doing different tasks or just be idle. </p>\n\n    <p>You need to return the <b>least</b> number of intervals the CPU will take to finish all the given tasks.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> tasks = ['A','A','A','B','B','B'], n = 2\n<b>Output:</b> 8\n<b>Explanation:</b> A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The number of tasks is in the range [1, 10000].</li>\n    <li>The integer n is in the range [0, 100].</li>\n</ol>\n    <p></p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        // Map task to number of tasks\n        Map<Character, Integer> map = new HashMap<>();\n        for(char task : tasks){\n            map.put(task, map.getOrDefault(task, 0) + 1);\n        }\n        // Sort tasks based on frequency\n        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(\n                (a, b) -> a.getValue() != b.getValue() ?\n                        b.getValue() - a.getValue() : a.getKey() - b.getKey()\n        );\n        pq.addAll(map.entrySet());\n\n        int count = 0;\n        while(!pq.isEmpty()){\n            int cycle = n + 1; // total time to execute a task\n            List<Map.Entry<Character, Integer>> remainingTasks = new ArrayList<>();\n            while(cycle > 0 && !pq.isEmpty()){\n                Map.Entry<Character, Integer> top = pq.poll();\n                // Update count of this task if still has left\n                if(top.getValue() - 1 > 0){\n                    top.setValue(top.getValue() - 1);\n                    remainingTasks.add(top);\n                }\n                cycle--; // Update time left in this cycle\n                count++; // Successfully executed task\n            }\n            for(Map.Entry<Character, Integer> t : remainingTasks){\n                pq.add(t);\n            }\n            if(pq.isEmpty()) break;\n            count += cycle;\n        }\n        return count;\n    }\n}",
        "tags": "0, 17, 18",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 330,
        "number": 623,
        "title": "Add One Row to Tree",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given the root of a binary tree, then value <code>v</code> and depth <code>d</code>, you need to add a row of nodes with value <code>v</code> at the given depth <code>d</code>. The root node is at depth 1. </p>\n\n    <p>The adding rule is: given a positive integer depth <code>d</code>, for each NOT null tree nodes <code>N</code> in depth <code>d-1</code>, create two tree nodes with value <code>v</code> as <code>N's</code> left subtree root and right subtree root. And <code>N's</code> <b>original left subtree</b> should be the left subtree of the new left subtree root, its <b>original right subtree</b> should be the right subtree of the new right subtree root. If depth <code>d</code> is 1 that means there is no depth d-1 at all, then create a tree node with value <b>v</b> as the new root of the whole original tree, and the original tree is the new root's left subtree.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b>\nA binary tree as following:\n       4\n     /   \\\n    2     6\n   / \\   /\n  3   1 5\n\n<b>v = 1</b>\n\n<b>d = 2</b>\n\n<b>Output:</b>\n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     /\n 3   1   5\n\n</pre>\n    <p></p>\n\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b>\nA binary tree as following:\n      4\n     /\n    2\n   / \\\n  3   1\n\n<b>v = 1</b>\n\n<b>d = 3</b>\n\n<b>Output:</b>\n      4\n     /\n    2\n   / \\\n  1   1\n /     \\\n3       1\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The given d is in range [1, maximum depth of the given tree + 1].</li>\n    <li>The given binary tree has at least one tree node.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode addOneRow(TreeNode root, int v, int d) {\n        if (d == 1) {\n\t\t\tTreeNode newRoot = new TreeNode(v);\n\t\t\tnewRoot.left = root;\n\t\t\treturn newRoot;\n\t\t}\n        int curDepth = 1;\n        Deque<TreeNode> parentLevel = new ArrayDeque<>();\n        parentLevel.offerFirst(root);\n        while(curDepth < d - 1){\n            Deque<TreeNode> nextLevel = new ArrayDeque<>();\n            while(!parentLevel.isEmpty()){\n                TreeNode top = parentLevel.pollFirst();\n                if(top.left != null)\n                    nextLevel.offerFirst(top.left);\n                if(top.right != null)\n                    nextLevel.offerFirst(top.right);\n            }\n            parentLevel = nextLevel;\n            curDepth++;\n        }\n\n        while(!parentLevel.isEmpty()){\n            TreeNode top = parentLevel.pollFirst();\n            TreeNode temp = top.left;\n            top.left = new TreeNode(v);\n            top.left.left = temp;\n            temp = top.right;\n            top.right = new TreeNode(v);\n            top.right.right = temp;\n        }\n        return root;\n    }\n}",
        "tags": "12",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 331,
        "number": 625,
        "title": "Minimum Factorization",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a positive integer <code>a</code>, find the smallest positive integer <code>b</code> whose multiplication of each digit equals to <code>a</code>. </p>\n\n    <p>\n        If there is no answer or the answer is not fit in 32-bit signed integer, then return 0.</p>\n\n    <p>\n        <b>Example 1</b><br>\n        Input:\n    </p><pre>48 </pre>\n    Output:\n    <pre>68</pre>\n    <p></p>\n\n    <p>\n        <b>Example 2</b><br>\n        Input:\n    </p><pre>15</pre>\n\n    Output:\n    <pre>35</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int smallestFactorization(int n) {\n        // Case 1: If number is smaller than 10\n        if (n < 10) return n;\n\n        // Case 2: Start with 9 and try every possible digit\n        List<Integer> res = new ArrayList<>();\n        for (int i = 9; i > 1; i--) {\n            // If current digit divides n, then store all\n            // occurrences of current digit in res\n            while (n % i == 0) {\n                n = n / i;\n                res.add(i);\n            }\n        }\n\n        // If n could not be broken in form of digits\n        if (n != 1) return 0;\n\n        // Get the result from the array in reverse order\n        long result = 0;\n        for (int i = res.size() - 1; i >= 0; i--) {\n            result = result * 10 + res.get(i);\n            if (result > Integer.MAX_VALUE) return 0;\n        }\n\n        return (int)result;\n    }\n}",
        "tags": "3, 32",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 332,
        "number": 629,
        "title": "K Inverse Pairs Array",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two integers <code>n</code> and <code>k</code>, find how many different arrays consist of numbers from <code>1</code> to <code>n</code> such that there are exactly <code>k</code> inverse pairs.\n</p>\n    <p>\n        We define an inverse pair as following:\n        For <code>i<sub>th</sub></code> and <code>j<sub>th</sub></code> element in the array, if <code>i</code> &lt; <code>j</code> and <code>a[i]</code> &gt; <code>a[j]</code> then it's an inverse pair; Otherwise, it's not.\n    </p>\n\n    <p>\n        Since the answer may very large, the answer should be modulo 10<sup>9</sup> + 7.\n    </p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> n = 3, k = 0\n<b>Output:</b> 1\n<b>Explanation:</b>\nOnly the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> n = 3, k = 1\n<b>Output:</b> 2\n<b>Explanation:</b>\nThe array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The integer <code>n</code> is in the range [1, 1000] and <code>k</code> is in the range [0, 1000].</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     * dp[n][k] denotes the number of arrays that have k inverse pairs for array composed of 1 to n\nwe can establish the recursive relationship between dp[n][k] and dp[n-1][i]:\n\nif we put n as the last number then all the k inverse pair should come from the first n-1 numbers\nif we put n as the second last number then there's 1 inverse pair involves n so the rest k-1 comes from the first n-1 numbers\n...\nif we put n as the first number then there's n-1 inverse pairs involve n so the rest k-(n-1) comes from the first n-1 numbers\n\ndp[n][k] = dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]+dp[n-1][k-n+1]\n\nIt's possible that some where in the right hand side the second array index become negative,\nsince we cannot generate negative inverse pairs we just treat them as 0,\nbut still leave the item there as a place holder.\n\ndp[n][k] = dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]+dp[n-1][k-n+1]\ndp[n][k+1] = dp[n-1][k+1]+dp[n-1][k]+dp[n-1][k-1]+dp[n-1][k-2]+...+dp[n-1][k+1-n+1]\n\nso by deducting the first line from the second line, we have\n\ndp[n][k+1] = dp[n][k]+dp[n-1][k+1]-dp[n-1][k+1-n]\n     *\n    **/\n    public int kInversePairs(int n, int k) {\n        int mod = 1000000007;\n        if (k > n*(n-1)/2 || k < 0) return 0;\n        if (k == 0 || k == n*(n-1)/2) return 1;\n        long[][] dp = new long[n+1][k+1];\n        dp[2][0] = 1;\n        dp[2][1] = 1;\n        for (int i = 3; i <= n; i++) {\n            dp[i][0] = 1;\n            for (int j = 1; j <= Math.min(k, i*(i-1)/2); j++) {\n                dp[i][j] = dp[i][j-1] + dp[i-1][j];\n                if (j >= i) dp[i][j] -= dp[i-1][j-i];\n                dp[i][j] = (dp[i][j]+mod) % mod;\n            }\n        }\n        return (int) dp[n][k];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 333,
        "number": 630,
        "title": "Course Schedule III",
        "difficulty": "Medium",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    There are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. Each course has some duration(course length)  <code>t</code> and closed on <code>d<sub>th</sub></code> day. A course should be taken <b>continuously</b> for <code>t</code> days and must be finished before or on the <code>d<sub>th</sub></code> day. You will start at the <code>1<sub>st</sub></code> day.\n</p>\n\n    <p>\n        Given <code>n</code> online courses represented by pairs <code>(t,d)</code>, your task is to find the maximal number of courses that can be taken.\n    </p>\n\n\n    <p><b>Example:</b><br>\n    </p><pre><b>Input:</b> [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\n<b>Output:</b> 3\n<b>Explanation:</b>\nThere're totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.\nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.\nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n</pre>\n    <p></p>\n\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The integer 1 &lt;= d, t, n &lt;= 10,000. </li>\n    <li>You can't take two courses simultaneously.</li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int scheduleCourse(int[][] courses) {\n        // Sort the courses by their deadlines\n        // (Greedy! We have to deal with courses with early deadlines first)\n        Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a);\n        int time = 0;\n        for (int[] c: courses) {\n            if (time + c[0] <= c[1]) {\n                queue.offer(c[0]);\n                time += c[0];\n            } else if (!queue.isEmpty() && queue.peek() > c[0]) {\n                // If time exceeds, drop the previous course which costs the most time.\n                // (That must be the best choice!)\n                time += c[0] - queue.poll();\n                queue.offer(c[0]);\n            }\n        }\n        return queue.size();\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 334,
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "description": "<div class=\"question-content\">\n    <p></p>\n    <p>There are two sorted arrays <b>nums1</b> and <b>nums2</b> of size m and n respectively.</p>\n\n    <p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\n\n    <p><b>Example 1:</b><br>\n    </p>\n    <pre>nums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p>\n    <pre>nums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5\n</pre>\n\n\n</div>",
        "solution": "public class Solution {\n    /***\n     * Time Complexity: O(log(n+m))\n     * Space Complexity: O(1)\n     *\n     * if total count is odd then find the one in the middle\n     * else find the another one on the left and get average\n     *\n     * the method of find middle can be converted to find the kth\n     * element recursively\n     *\n     */\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int totalCount = nums1.length + nums2.length;\n        int right = getKthElement(totalCount/2 + 1, nums1, nums2, 0, 0);\n        if(totalCount %2 != 0){\n            return 1.0*right;\n        }\n        int left = getKthElement(totalCount/2, nums1, nums2, 0, 0);\n        return (left + right)/2.0;\n    }\n\n    private int getKthElement(int k, int[] nums1, int[] nums2, int start1, int start2){\n        if(start1 >= nums1.length){\n            return nums2[start2 + k - 1];\n        }\n        if(start2 >= nums2.length){\n            return nums1[start1 + k - 1];\n        }\n\n        if(k == 1)\n            return Math.min(nums1[start1], nums2[start2]);\n        int mid1 = (start1 + k/2 - 1 < nums1.length) ? nums1[start1 + k/2 - 1] : Integer.MAX_VALUE;\n        int mid2 = (start2 + k/2 - 1 < nums2.length) ? nums2[start2 + k/2 - 1] : Integer.MAX_VALUE;\n\n        // Key is to use k - k/2 not k/2\n        if(mid1 < mid2)\n            return getKthElement(k - k/2, nums1, nums2, start1 + k/2, start2);\n        return getKthElement(k - k/2, nums1, nums2, start1, start2 + k/2);\n    }\n}",
        "tags": "0, 6, 7",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 335,
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p>\n\n    <pre>'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the <b>entire</b> input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch(\"aa\",\"a\") → false\nisMatch(\"aa\",\"aa\") → true\nisMatch(\"aaa\",\"aa\") → false\nisMatch(\"aa\", \"a*\") → true\nisMatch(\"aa\", \".*\") → true\nisMatch(\"ab\", \".*\") → true\nisMatch(\"aab\", \"c*a*b\") → true\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    /**\n     1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\n     2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\n     3, If p.charAt(j) == '*': here are two sub conditions:\n     3.1, if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\n     3.2, if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':\n     dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a\n     or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\n     or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty\n     ***/\n    public boolean isMatch(String s, String p) {\n        if (s == null || p == null) {\n            return false;\n        }\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\n        dp[0][0] = true;\n        for (int i = 1; i < p.length(); i++) {\n            if (p.charAt(i) == '*' && dp[0][i-1]) {\n                dp[0][i+1] = true;\n            }\n        }\n        for (int i = 0 ; i < s.length(); i++) {\n            for (int j = 0; j < p.length(); j++) {\n                if (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i)) {\n                    dp[i + 1][j + 1] = dp[i][j];\n                }\n                if (p.charAt(j) == '*') {\n                    if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {\n                        dp[i+1][j+1] = dp[i+1][j-1];\n                    } else {\n                        dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);\n                    }\n                }\n            }\n        }\n        return dp[s.length()][p.length()];\n    }\n}",
        "tags": "5, 8, 9",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 336,
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Merge <i>k</i> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n</p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        PriorityQueue<ListNode> queue = new PriorityQueue<>(lists.length, new Comparator<ListNode>() {\n            @Override\n            public int compare(ListNode o1, ListNode o2) {\n                if (o1.val < o2.val)\n                    return -1;\n                else if (o1.val == o2.val)\n                    return 0;\n                else\n                    return 1;\n            }\n        });\n\n        ListNode dummy = new ListNode(0);\n        ListNode tail = dummy;\n\n        for (ListNode node : lists)\n            if (node != null)\n                queue.add(node);\n\n        while (!queue.isEmpty()) {\n            tail.next = queue.poll();\n            tail = tail.next;\n\n            if (tail.next != null)\n                queue.add(tail.next);\n        }\n        return dummy.next;\n    }\n}",
        "tags": "2, 7, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 337,
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a linked list, reverse the nodes of a linked list <i>k</i> at a time and return its modified list.\n</p>\n\n    <p>\n        <i>k</i> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <i>k</i> then left-out nodes in the end should remain as it is.</p>\n\n    <p>You may not alter the values in the nodes, only nodes itself may be changed.</p>\n\n    <p>Only constant memory is allowed.</p>\n\n    <p>\n        For example,<br>\n        Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>\n    </p>\n\n    <p>\n        For <i>k</i> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code>\n    </p>\n\n    <p>\n        For <i>k</i> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code>\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode begin;\n        if (head == null || head.next == null || k == 1)\n            return head;\n        ListNode dummyhead = new ListNode(-1);\n        ListNode cur = head;\n        dummyhead.next = cur;\n        begin = dummyhead;\n        int i = 0;\n        while (cur != null) {\n            i++;\n            if (i % k == 0) {\n                begin = reverse(begin, cur.next);\n                cur = begin.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummyhead.next;\n    }\n\n    private ListNode reverse(ListNode begin, ListNode end) {\n        ListNode curr = begin.next;\n        while (curr.next != end) {\n            ListNode temp = begin.next;\n            begin.next = curr.next;\n            curr.next = curr.next.next;\n            begin.next.next = temp;\n        }\n        return curr;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 338,
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    You are given a string, <b>s</b>, and a list of words, <b>words</b>, that are all of the same length. Find all starting indices of substring(s) in <b>s</b> that is a concatenation of each word in <b>words</b> exactly once and without any intervening characters.\n</p>\n\n    <p>\n        For example, given:<br>\n        <b>s</b>: <code>\"barfoothefoobarman\"</code><br>\n        <b>words</b>: <code>[\"foo\", \"bar\"]</code>\n    </p>\n\n    <p>\n        You should return the indices: <code>[0,9]</code>.<br>\n        (order does not matter).\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList<>();\n        int n = s.length(), cnt = words.length;\n        if (n <= 0 || cnt <= 0) {\n            return ans;\n        }\n\n        // init word occurence\n        Map<String, Integer> dict = new HashMap<>();\n        for (int i = 0; i < cnt; ++i) {\n            if (dict.containsKey(words[i])) {\n                dict.put(words[i], dict.get(words[i]) + 1);\n            } else {\n                dict.put(words[i], 1);\n            }\n        }\n\n        // travel all sub string combinations\n        int wl = words[0].length();\n        for (int i = 0; i < wl; ++i) {\n            int left = i, count = 0;\n            Map<String, Integer> tdict = new HashMap<>();\n            for (int j = i; j <= n - wl; j += wl) {\n                String str = s.substring(j, j + wl);\n                // a valid word, accumulate results\n                if (dict.containsKey(str)) {\n                    if (tdict.containsKey(str)) {\n                        tdict.put(str, tdict.get(str) + 1);\n                    } else {\n                        tdict.put(str, 1);\n                    }\n                    if (tdict.get(str) <= dict.get(str))\n                        count++;\n                    else {\n                        // a more word, advance the window left side possiablly\n                        while (tdict.get(str) > dict.get(str)) {\n                            String str1 = s.substring(left, left + wl);\n                            tdict.put(str1, tdict.get(str1) - 1);\n                            if (tdict.get(str1) < dict.get(str1)) {\n                                count--;\n                            }\n                            left += wl;\n                        }\n                    }\n                    // come to a result\n                    if (count == cnt) {\n                        ans.add(left);\n                        // advance one word\n                        tdict.put(s.substring(left, left + wl), dict.get(s.substring(left, left + wl)) - 1);\n                        count--;\n                        left += wl;\n                    }\n                } else {\n                    tdict.clear();\n                    count = 0;\n                    left = j + wl;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "tags": "1, 4, 5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 339,
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, find the length of the longest valid (well-formed) parentheses substring.\n</p>\n    <p>\n        For <code>\"(()\"</code>, the longest valid parentheses substring is <code>\"()\"</code>, which has length = 2.\n    </p>\n    <p>\n        Another example is <code>\")()())\"</code>, where the longest valid parentheses substring is <code>\"()()\"</code>, which has length = 4.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    // Solution with Stack\n    public int longestValidParentheses(String s) {\n        int res = 0;\n        Stack<Integer> indexStack = new Stack<Integer>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == ')' && !indexStack.isEmpty() &&\n                    s.charAt(indexStack.peek()) == '(') {\n                indexStack.pop();\n                if (indexStack.isEmpty())\n                    res = i + 1;\n                else\n                    res = Math.max(res, i - indexStack.peek());\n            } else {\n                indexStack.push(i);\n            }\n        }\n        return res;\n    }\n\n    Solution without stack\n    public int longestValidParentheses(String s) {\n        int left = 0, right = 0, maxlength = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = Math.max(maxlength, 2 * right);\n            } else if (right >= left) {\n                left = right = 0;\n            }\n        }\n        left = right = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = Math.max(maxlength, 2 * left);\n            } else if (left >= right) {\n                left = right = 0;\n            }\n        }\n        return maxlength;\n    }\n}",
        "tags": "5, 9",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 340,
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>\n\n    <p>Empty cells are indicated by the character <code>'.'</code>.</p>\n\n    <p>You may assume that there will be only one unique solution.\n\n    </p><p>\n    <img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\"><br>\n</p><p style=\"font-size: 11px\">A sudoku puzzle...</p>\n    <p></p>\n\n    <p>\n        <img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\"><br>\n    </p><p style=\"font-size: 11px\">...and its solution numbers marked in red.\n</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public void solveSudoku(char[][] board) {\n        solve(board, 0, 0);\n    }\n\n    private boolean solve(char[][] board, int row, int col) {\n        //all cells satisfy the constraints and valid, board is full\n        if (row == 9) {\n            return true;\n        }\n\n        int nextRow = (col == 8) ? row + 1 : row;\n        int nextCol = (col == 8) ? 0 : col + 1;\n        //already filled, fill rest of board and return truw if sol exists\n        if (board[row][col] != '.'){\n            return solve(board, nextRow, nextCol);\n        }\n\n        //if cur char is '.', try diff numbers and see if sol possible, if doesnt, backtrack\n        for (int i = 1; i <= 9; i++) {\n            board[row][col] = (char) ('0' + i);\n            if (isValid(board, row, col) && solve(board, nextRow, nextCol)) {\n                return true;\n            }\n        }\n        //none of the above solutions fitted, so set to its initital value\n        board[row][col] = '.';\n        return false;\n    }\n\n    // Method to validate current board\n    public boolean isValid(char[][] board, int row, int col) {\n        char cur = board[row][col];\n        for (int i = 0; i < 9; i++) {\n            if (board[row][i] == cur && i != col || board[i][col] == cur && i != row)\n                return false;\n        }\n\n        int bx = row / 3;\n        int by = col / 3;\n        for (int i = bx * 3; i < bx * 3 + 3; i++){\n            for (int j = by * 3; j < by * 3 + 3; j++) {\n                if (board[i][j] == cur && !(i == row && j == col))\n                    return false;\n            }\n        }\n        return true;\n    }\n}",
        "tags": "1, 8",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 341,
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an unsorted integer array, find the first missing positive integer.\n</p>\n\n    <p>\n        For example,<br>\n        Given <code>[1,2,0]</code> return <code>3</code>,<br>\n        and <code>[3,4,-1,1]</code> return <code>2</code>.\n    </p>\n\n    <p>\n        Your algorithm should run in <i>O</i>(<i>n</i>) time and uses constant space.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int firstMissingPositive(int[] A) {\n        int i = 0;\n        while(i < A.length){\n            if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;\n            else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);\n            else i++;\n        }\n        i = 0;\n        while(i < A.length && A[i] == i+1) i++;\n        return i+1;\n    }\n\n    private void swap(int[] A, int i, int j){\n        int temp = A[i];\n        A[i] = A[j];\n        A[j] = temp;\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 342,
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given <i>n</i> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n</p>\n\n    <p>\n        For example, <br>\n        Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.\n    </p>\n\n    <p>\n        <img src=\"http://www.leetcode.com/static/images/problemset/rainwatertrap.png\"><br>\n    </p><p style=\"font-size: 11px\">The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. <b>Thanks Marcos</b> for contributing this image!</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int trap(int[] A) {\n        int left = 0, right = height.length - 1;\n        int ans = 0;\n        int left_max = 0, right_max = 0;\n        while (left < right) {\n            // Find shorter line to iterate\n            if (height[left] < height[right]) {\n                if(height[left] >= left_max)\n                    left_max = height[left];\n                else\n                    ans += left_max - height[left];\n                ++left;\n            } else {\n                if(height[right] >= right_max)\n                    right_max = height[right];\n                else\n                    ans += right_max - height[right];\n                --right;\n            }\n        }\n        return ans;\n    }\n}",
        "tags": "0, 4 ,15",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 343,
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement wildcard pattern matching with support for <code>'?'</code> and <code>'*'</code>.</p>\n\n    <pre>'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the <b>entire</b> input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch(\"aa\",\"a\") → false\nisMatch(\"aa\",\"aa\") → true\nisMatch(\"aaa\",\"aa\") → false\nisMatch(\"aa\", \"*\") → true\nisMatch(\"aa\", \"a*\") → true\nisMatch(\"ab\", \"?*\") → true\nisMatch(\"aab\", \"c*a*b\") → false\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    // DP solution\n    public boolean isMatch(String s, String p) {\n        boolean[][] dp = new boolean[s.length() + 1][p.length()+1];\n        dp[0][0] = true;\n\n        int j = 1;\n        while(j <= p.length() && p.charAt(j-1)=='*')\n            dp[0][j++] = true;\n\n        for(int i = 1; i <= s.length(); i++) {\n            for(j = 1; j <= p.length(); j++) {\n                if (p.charAt(j-1)!='*') {\n                    dp[i][j] = dp[i-1][j-1] && (s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='?');\n                } else {\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\n                }\n            }\n        }\n        return dp[s.length()][p.length()];\n    }\n\n    // Two pointer solution\n    public boolean isMatch(String s, String p) {\n        public boolean isMatch(String str, String pattern) {\n            int s = 0, p = 0, match = 0, starIdx = -1;\n            while (s < str.length()){\n                // advancing both pointers\n                if (p < pattern.length()  &&\n                        (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\n                    s++;\n                    p++;\n                } else if (p < pattern.length() && pattern.charAt(p) == '*'){\n                    // * found, only advancing pattern pointer\n                    starIdx = p;\n                    match = s;\n                    p++;\n                } else if (starIdx != -1){\n                    // set pattern pointer to after * and advance string pointer\n                    p = starIdx + 1;\n                    match++;\n                    s = match;\n                } else {\n                    return false;\n                }\n            }\n\n            //check for remaining characters in pattern\n            while (p < pattern.length() && pattern.charAt(p) == '*')\n                p++;\n\n            return p == pattern.length();\n        }\n    }\n}",
        "tags": "5, 8, 9, 17",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 344,
        "number": 45,
        "title": "Jump Game II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array of non-negative integers, you are initially positioned at the first index of the array.\n</p>\n    <p>\n        Each element in the array represents your maximum jump length at that position.\n    </p>\n    <p>\n        Your goal is to reach the last index in the minimum number of jumps.\n    </p>\n\n    <p>\n        For example:<br>\n        Given array A = <code>[2,3,1,1,4]</code>\n    </p>\n    <p>\n        The minimum number of jumps to reach the last index is <code>2</code>. (Jump <code>1</code> step from index 0 to 1, then <code>3</code> steps to the last index.)\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        You can assume that you can always reach the last index.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int jump(int[] A) {\n        int count = 0, max = 0, nextMax = 0;\n        for (int i = 0; i < A.length - 1; i++) {\n            nextMax = Math.max(nextMax, i + A[i]);\n            if (i == max) {\n                max = nextMax;\n                count++; // Only need to more steps when reach the max\n            }\n        }\n        // if there is no way to get to the end, return -1\n        return max >= A.length - 1 ? count : -1;\n    }\n}",
        "tags": "0, 17",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 345,
        "number": 51,
        "title": "N-Queens",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>The <i>n</i>-queens puzzle is the problem of placing <i>n</i> queens on an <i>n</i>×<i>n</i> chessboard such that no two queens attack each other.</p>\n\n    <p>Given an integer <i>n</i>, return all distinct solutions to the <i>n</i>-queens puzzle.</p>\n\n    <p>Each solution contains a distinct board configuration of the <i>n</i>-queens' placement, where <code>'Q'</code> and <code>'.'</code> both indicate a queen and an empty space respectively.</p>\n\n    <p>For example,<br>\n        There exist two distinct solutions to the 4-queens puzzle:</p>\n    <pre>[\n [\".Q..\",  // Solution 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // Solution 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n</pre><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> re = new ArrayList<>();\n        if (n <= 0){\n            return re;\n        }\n        int[][] place = new int[n][n];\n        placeQueens(re, place, n, 0);\n        return re;\n    }\n\n    void placeQueens(List<List<String>> re, int[][] place, int n, int level) {\n        if (level == n) {\n            re.add(shape(place, n));\n            return;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (canplace(level, i, place, n)) {\n                place[level][i] = 1;\n                placeQueens(re, place, n, level + 1);\n                place[level][i] = 0;\n            }\n        }\n    }\n\n    boolean canplace(int i, int j, int[][] place, int n) {\n        for (int k = 0; k < n; k++) {\n            if (k == i){\n                continue;\n            }\n            if (place[k][j] == 1){\n                return false;\n            }\n            for (int m = 0; m < n; m++) {\n                if (Math.abs(k - i) == Math.abs(m - j) && place[k][m] == 1)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    List<String> shape(int[][] p, int n) {\n        List<String> strs = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            StringBuilder temp = new StringBuilder();\n            for (int j = 0; j < n; j++) {\n                if (p[i][j] == 0)\n                    temp.append(\".\");\n                else\n                    temp.append(\"Q\");\n            }\n            strs.add(temp.toString());\n        }\n        return strs;\n    }\n}",
        "tags": "8",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 346,
        "number": 52,
        "title": "N-Queens II",
        "difficulty": "Hard",
        "description": "Follow up for N-Queens problem.\n<br>\nNow, instead outputting board configurations, return the total number of distinct solutions.",
        "solution": "public class Solution {\n    public int totalNQueens(int n) {\n        if(n<=0) return 0;\n        int[] place = new int[n];\n        int[] count = new int[1];\n\n        placeQueens(count,place,n,0);\n        return count[0];\n    }\n\n    public void placeQueens(int[] count, int[] place, int n, int level){\n        if(level == n){\n            count[0]++;\n            return;\n        }\n\n        for(int i=0; i<n; i++){\n            if(canplace(level,place,i)){\n                place[level] = i;\n                placeQueens(count,place,n,level+1);\n            }\n        }\n    }\n\n    public boolean canplace(int i, int[] place, int n){\n        for(int j=0; j<i; j++){\n            if(place[j]==n)\n                return false;\n            if(Math.abs(n-place[j]) == i-j)\n                return false;\n        }\n        return true;\n    }\n}",
        "tags": "8",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 347,
        "number": 57,
        "title": "Insert Interval",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a set of <i>non-overlapping</i> intervals, insert a new interval into the intervals (merge if necessary).</p>\n\n    <p>You may assume that the intervals were initially sorted according to their start times.</p>\n\n    <p>\n        <b>Example 1:</b><br>\n        Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.\n    </p>\n\n    <p>\n        <b>Example 2:</b><br>\n        Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.\n    </p>\n\n    <p>\n        This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        List<Interval> result = new ArrayList<Interval>();\n\n        for(Interval interval: intervals){\n            // new interval is behind cur interval\n            if(interval.end < newInterval.start){\n                result.add(interval);\n            }else if(interval.start > newInterval.end){\n                // cur interval is behind new interval\n                result.add(newInterval);\n                newInterval = interval;\n            }else if(interval.end >= newInterval.start || interval.start <= newInterval.end){\n                // merge the current interval with new interval as new interval\n                newInterval = new Interval(Math.min(interval.start, newInterval.start),\n                        Math.max(newInterval.end, interval.end));\n            }\n        }\n        result.add(newInterval);\n        return result;\n    }\n}",
        "tags": "0, 13",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 348,
        "number": 65,
        "title": "Valid Number",
        "difficulty": "Hard",
        "description": "<div class=\"question-content\">\n    <p></p><p>Validate if a given string is numeric.</p>\n\n    <p>\n        Some examples:<br>\n        <code>\"0\"</code> =&gt; <code>true</code><br>\n        <code>\"   0.1  \"</code> =&gt; <code>true</code><br>\n        <code>\"abc\"</code> =&gt; <code>false</code><br>\n        <code>\"1 a\"</code> =&gt; <code>false</code><br>\n        <code>\"2e10\"</code> =&gt; <code>true</code><br>\n    </p>\n\n    <p><b>Note:</b> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.\n    </p>\n\n</div>",
        "solution": "public class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        int len = s.length();\n        if(len == 0) return false;\n\n        boolean hasdot = false;\n        boolean hase = false;\n        boolean hasnum = false;\n        int i = 0;\n\n        // deal with \"+\" and \"-\"\n        if(s.charAt(0) == '+' || s.charAt(0) == '-')\n            i++;\n        else if(s.charAt(0) == 'e')\n            return false;\n\n        // start validation\n        while(i < len){\n            // deal with '.'\n            if(s.charAt(i) == '.'){\n                if(hasdot)\n                    return false;\n                hasdot = true;\n            } else if (s.charAt(i) == 'e'){\n                //different invalid casse: e34, 34ee, 34e+\n                if(!hasnum || hase || i == len - 1 ||\n                        (i == len - 2 && (s.charAt(i+1)=='+' || s.charAt(i+1)=='-'))){\n                    return false;\n                }\n                if(s.charAt(i+1) == '-' || s.charAt(i+1) == '+')\n                    i++;\n                hase = true;\n                hasdot = true; // after \"e\" we cannot have any \".\"\n            } else if (s.charAt(i) >= '0' && s.charAt(i) <= '9'){\n                hasnum = true;\n            } else {\n                return false;\n            }\n            i++;\n        }\n        return hasnum;\n    }\n}",
        "tags": "3, 5",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 349,
        "number": 68,
        "title": "Text Justification",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given an array of words and a length <i>L</i>, format the text such that each line has exactly <i>L</i> characters and is fully (left and right) justified.\n</p>\n\n    <p>\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>' '</code> when necessary so that each line has exactly <i>L</i> characters.\n    </p>\n\n    <p>\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n    </p>\n\n    <p>\n        For the last line of text, it should be left justified and no extra space is inserted between words.\n    </p>\n\n    <p>\n        For example,<br>\n        <b>words</b>: <code>[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]</code><br>\n        <b>L</b>: <code>16</code>.\n    </p>\n\n    <p>\n        Return the formatted lines as:<br>\n    </p><pre>[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n</pre>\n    <p></p>\n\n    <p>\n        <b>Note:</b> Each word is guaranteed not to exceed <i>L</i> in length.\n    </p>\n\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show corner cases.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><b>Corner Cases:</b>\n        <p>\n        </p><ul>\n            <li>A line other than the last line might contain only one word. What should you do in this case?<br>\n                In this case, that line should be left-justified.</li>\n            <p></p>\n        </ul></div><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> res = new ArrayList<String>();\n        int i = 0, count = 0, len = 0;\n        while (i < words.length) {\n            len += words[i].length() + 1;\n            if (len - 1 <= maxWidth) {\n                i++;\n                count++;\n                continue;\n            }\n            fillString(words, res, count, i - count, maxWidth);\n            len = 0;\n            count = 0;\n        }\n        fillString(words, res, count, i - count, maxWidth);\n        return res;\n    }\n\n    void fillString(String[] words, List<String> res, int count, int start, int maxWidth) {\n        StringBuilder sb = new StringBuilder(maxWidth);\n        int totalspace = maxWidth;\n        for (int i = start; i < start + count; i++)\n            totalspace -= words[i].length();\n\n        // Only one word in this line or last line\n        if (count == 1 || start + count == words.length) {\n            for (int i = start; i < start + count; i++) {\n                sb.append(words[i]);\n                if (totalspace > 0) {\n                    sb.append(\" \");\n                    totalspace--;\n                }\n            }\n            while (totalspace > 0) {\n                sb.append(\" \");\n                totalspace--;\n            }\n            res.add(sb.toString());\n            return;\n        }\n\n        int extraspacelen = totalspace % (count - 1);\n        StringBuilder evenSpaces = new StringBuilder(totalspace / (count - 1));\n        for (int i = 0; i < totalspace / (count - 1); i++)\n            evenSpaces.append(\" \");\n        for (int i = start; i < start + count - 1; i++) {\n            sb.append(words[i]);\n            sb.append(evenSpaces);\n            if (extraspacelen > 0) {\n                sb.append(\" \");\n                extraspacelen--;\n            }\n        }\n        sb.append(words[start + count - 1]);\n        res.add(sb.toString());\n    }\n}\n",
        "tags": "5",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 350,
        "number": 72,
        "title": "Edit Distance",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two words <i>word1</i> and <i>word2</i>, find the minimum number of steps required to convert <i>word1</i> to <i>word2</i>. (each operation is counted as 1 step.)\n</p>\n\n    <p>\n        You have the following 3 operations permitted on a word:\n    </p>\n\n    <p>\n        a) Insert a character<br>\n        b) Delete a character<br>\n        c) Replace a character<br>\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int minDistance(String word1, String word2) {\n        int len1 = word1.length() + 1;\n        int len2 = word2.length() + 1;\n\n        if (len1 == 1) return len2 - 1;\n        if (len2 == 1) return len1 - 1;\n\n        int[][] mat = new int[len1][len2];\n        for (int i = 0; i < len2; i++) {\n            mat[0][i] = i;\n        }\n\n        for (int i = 0; i < len1; i++) {\n            mat[i][0] = i;\n        }\n\n        for (int i = 1; i < len1; i++) {\n            for (int j = 1; j < len2; j++) {\n                mat[i][j] = word1.charAt(i - 1) == word2.charAt(j - 1) ? mat[i - 1][j - 1] :\n                        Math.min(mat[i - 1][j - 1], Math.min(mat[i - 1][j], mat[i][j - 1])) + 1;\n            }\n        }\n        return mat[len1 - 1][len2 - 1];\n    }\n}",
        "tags": "5, 9",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 351,
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n</p>\n\n    <p>\n        For example,<br>\n        <b>S</b> = <code>\"ADOBECODEBANC\"</code><br>\n        <b>T</b> = <code>\"ABC\"</code><br>\n    </p>\n    <p>\n        Minimum window is <code>\"BANC\"</code>.\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        If there is no such window in S that covers all characters in T, return the empty string <code>\"\"</code>.\n    </p>\n    <p>\n        If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String minWindow(String s, String t) {\n        String result = \"\";\n        if (s.length() == 0 || t.length() == 0) {\n            return result;\n        }\n\n        int[] map = new int[256];\n        int[] window = new int[256];\n        for (int i = 0; i < t.length(); i++) {\n            map[t.charAt(i)]++;\n        }\n\n        int minLength = Integer.MAX_VALUE;\n        int letterCounter = 0;\n        for (int slow = 0, fast = 0; fast < s.length(); fast++) {\n            if (map[s.charAt(fast)] > 0) {\n                window[s.charAt(fast)]++;\n                if (window[s.charAt(fast)] <= map[s.charAt(fast)]) {\n                    letterCounter++;\n                }\n            }\n\n            if (letterCounter >= t.length()) {\n                while (map[s.charAt(slow)] == 0 || window[s.charAt(slow)] > map[s.charAt(slow)]) {\n                    window[s.charAt(slow)]--;\n                    slow++;\n                }\n                if (fast - slow + 1 < minLength) {\n                    minLength = fast - slow + 1;\n                    result = s.substring(slow, slow + minLength);\n                }\n            }\n        }\n        return result;\n    }\n}",
        "tags": "1, 4, 5",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 352,
        "number": 84,
        "title": "Largest Rectangle in Histogram",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given <i>n</i> non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n</p>\n\n    <p>\n        <img src=\"https://leetcode.com/static/images/problemset/histogram.png\"><br>\n    </p><p style=\"font-size: 11px\">Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>\n    <p></p>\n\n    <p>\n        <img src=\"https://leetcode.com/static/images/problemset/histogram_area.png\"><br>\n    </p><p style=\"font-size: 11px\">The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>\n    <p></p>\n\n    <p>\n        For example,<br>\n        Given heights = <code>[2,1,5,6,2,3]</code>,<br>\n        return <code>10</code>.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int largestRectangleArea(int[] heights) {\n        if (heights == null || heights.length == 0) return 0;\n\n        Stack<Integer> stack = new Stack<Integer>();\n        int max = 0, i = 0;\n\n        while (i < heights.length) {\n            //push index to stack when the current height is larger than the previous one\n            if (stack.isEmpty() || heights[i] >= heights[stack.peek()]) {\n                stack.push(i);\n                i++;\n            } else { //calculate max value when the current height is less than the previous one\n                int p = stack.pop();\n                max = Math.max(max, heights[p]*(stack.isEmpty() ? i : i - stack.peek() - 1));\n            }\n        }\n\n        while (!stack.isEmpty()) {\n            int p = stack.pop();\n            max = Math.max(max, heights[p]*(stack.isEmpty() ? i : i - stack.peek() - 1));\n        }\n        return max;\n    }\n}",
        "tags": "0, 15",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 353,
        "number": 85,
        "title": "Maximal Rectangle",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n</p>\n\n    <p>For example, given the following matrix:\n    </p><pre>1 0 1 0 0\n1 0 <font color=\"red\">1</font> <font color=\"red\">1</font> <font color=\"red\">1</font>\n1 1 <font color=\"red\">1</font> <font color=\"red\">1</font> <font color=\"red\">1</font>\n1 0 0 1 0\n</pre>\n    Return 6.\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    // This problem can be converted to the \"Largest Rectangle in Histogram\" problem.\n    public int maximalRectangle(char[][] matrix) {\n        int m = matrix.length;\n        int n = m == 0 ? 0 : matrix[0].length;\n        int[][] height = new int[m][n + 1];\n\n        int maxArea = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == '0') {\n                    height[i][j] = 0;\n                } else {\n                    height[i][j] = i == 0 ? 1 : height[i - 1][j] + 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            int area = maxAreaInHist(height[i]);\n            if (area > maxArea) {\n                maxArea = area;\n            }\n        }\n        return maxArea;\n    }\n\n    int maxAreaInHist(int[] height) {\n        Stack<Integer> stack = new Stack<Integer>();\n        int i = 0, max = 0;\n\n        while (i < height.length) {\n            if (stack.isEmpty() || height[stack.peek()] <= height[i]) {\n                stack.push(i++);\n            } else {\n                int t = stack.pop();\n                max = Math.max(max, height[t]*(stack.isEmpty() ? i : i - stack.peek() - 1));\n            }\n        }\n        return max;\n    }\n}",
        "tags": "0, 1, 9, 15",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 354,
        "number": 87,
        "title": "Scramble String",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string <i>s1</i>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n</p>\n    <p>\n        Below is one possible representation of <i>s1</i> = <code>\"great\"</code>:\n    </p>\n    <pre>    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\n</pre>\n    <p>\n        To scramble the string, we may choose any non-leaf node and swap its two children.\n    </p>\n    <p>\n        For example, if we choose the node <code>\"gr\"</code> and swap its two children, it produces a scrambled string <code>\"rgeat\"</code>.\n    </p>\n    <pre>    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\n</pre>\n    <p>\n        We say that <code>\"rgeat\"</code> is a scrambled string of <code>\"great\"</code>.\n    </p>\n    <p>\n        Similarly, if we continue to swap the children of nodes <code>\"eat\"</code> and <code>\"at\"</code>, it produces a scrambled string <code>\"rgtae\"</code>.\n    </p>\n    <pre>    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\n</pre>\n    <p>\n        We say that <code>\"rgtae\"</code> is a scrambled string of <code>\"great\"</code>.\n    </p>\n    <p>\n        Given two strings <i>s1</i> and <i>s2</i> of the same length, determine if <i>s2</i> is a scrambled string of <i>s1</i>.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    /*************\n     * memo[i][j][k] means state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string\n     * Two conditions we can regard as scramble, for range of word1(i -> i+k) or word2(j -> j+k):\n     * i -> i + split = j -> j + split (len = split) and split + i -> i + k = split + i -> j + k (len = k - split)\n     * i -> i + split = j + (k - split) -> j+k [len = split] and i + split -> i+k = j -> j + (k - split)(len = k - split)\n     * Consider about the initialization:\n     * for k == 1, we only check if word1[i] == word2[j]\n     ***********/\n    public boolean isScramble(String s1, String s2) {\n        // check length\n        if(s1 == null || s2 == null || s1.length() != s2.length()) return false;\n        // check anagram\n        char[] c1 = s1.toCharArray();\n        char[] c2 = s2.toCharArray();\n        Arrays.sort(c1);\n        Arrays.sort(c2);\n        if (!Arrays.equals(c1, c2))  return false;\n        if(s1.length() != s2.length()) return false;\n\n        int len = s1.length();\n        // state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string\n        boolean[][][] memo = new boolean[len][len][len+1];\n\n        // initial, only check if s1[i] == s2[j]\n        for(int i = 0; i < s1.length(); i++)\n            for(int j = 0; j < s2.length(); j++)\n                memo[i][j][1] = s1.charAt(i) == s2.charAt(j);\n\n        for(int k = 2; k <= len; k++) {\n            for(int i = 0; i <= len - k; i++) {\n                for(int j = 0; j <= len - k; j++) {\n                    // split point should start from 1 to k - 1\n                    for(int split = 1; split < k; split++) {\n                        memo[i][j][k] = memo[i][j][k] ||\n                                (memo[i][j][split] && memo[i + split][j + split][k - split]) ||\n                                (memo[i][j + (k - split)][split] && memo[i + split][j][k - split]);\n                    }\n                }\n            }\n        }\n        return memo[0][0][len];\n    }\n}",
        "tags": "5, 9",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 355,
        "number": 97,
        "title": "Interleaving String",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given <i>s1</i>, <i>s2</i>, <i>s3</i>, find whether <i>s3</i> is formed by the interleaving of <i>s1</i> and <i>s2</i>.\n</p>\n\n    <p>\n        For example,<br>\n        Given:<br>\n        <i>s1</i> = <code>\"aabcc\"</code>,<br>\n        <i>s2</i> = <code>\"dbbca\"</code>,\n    </p>\n    <p>\n        When <i>s3</i> = <code>\"aadbbcbcac\"</code>, return true.<br>\n        When <i>s3</i> = <code>\"aadbbbaccc\"</code>, return false.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    /***\n     * Match[i][j]  =   (s3.lastChar == s1.lastChar) && Match[i-1][j] || (s3.lastChar == s2.lastChar) && Match[i][j-1]\n     * Initial Condition：\n     *    i=0 && j=0，Match[0][0] = true;\n     *    i=0， s3[j] = s2[j], Match[0][j] |= Match[0][j-1]\n     *           s3[j] != s2[j], Match[0][j] = false;\n     *\n     *   j=0， s3[i] = s1[i], Match[i][0] |= Match[i-1][0]\n     *          s3[i] != s1[i], Match[i][0] = false;\n     *******************/\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int l1 = s1.length(), l2 = s2.length(), l3 = s3.length();\n        if (l1 + l2 != l3) return false;\n        int[][] dptable = new int[l2 + 1][l1 + 1];\n        // Initial condition 1\n        dptable[0][0] = 1;\n        // Initial condition 2\n        for (int i = 1; i <= l1; i++) {\n            if (dptable[0][i - 1] == 1 && s3.charAt(l3 - i) == s1.charAt(l1 - i))\n                dptable[0][i] = 1;\n            else\n                dptable[0][i] = 0;\n        }\n        // Initial condition 3\n        for (int i = 1; i <= l2; i++) {\n            if (dptable[i - 1][0] == 1 && s3.charAt(l3 - i) == s2.charAt(l2 - i))\n                dptable[i][0] = 1;\n            else\n                dptable[i][0] = 0;\n        }\n\n        for (int i = 1; i <= l2; i++)\n            for (int j = 1; j <= l1; j++) {\n                if (dptable[i - 1][j] == 0 && dptable[i][j - 1] == 0)\n                    dptable[i][j] = 0;\n                else if (dptable[i - 1][j] == 1) {\n                    if (s3.charAt(l3 - i - j) == s2.charAt(l2 - i)) {\n                        dptable[i][j] = 1;\n                        continue;\n                    }\n                } else if (dptable[i][j - 1] == 1) {\n                    if (s3.charAt(l3 - i - j) == s1.charAt(l1 - j)) {\n                        dptable[i][j] = 1;\n                        continue;\n                    }\n                } else\n                    dptable[i][j] = 0;\n            }\n\n        return dptable[l2][l1] == 1 ? true : false;\n    }\n}",
        "tags": "5, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 356,
        "number": 99,
        "title": "Recover Binary Search Tree",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Two elements of a binary search tree (BST) are swapped by mistake.</p>\n\n    <p>Recover the tree without changing its structure.\n    </p>\n\n    <b>Note:</b><br>\n    A solution using O(<i>n</i>) space is pretty straight forward. Could you devise a constant space solution?\n    <p></p><p></p>\n</div>",
        "solution": "/**\n * Definition for binary tree\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public void recoverTree(TreeNode root) {\n        TreeNode pre = null;\n        TreeNode first = null, second = null;\n        // Morris Traversal\n        TreeNode temp = null;\n        while(root!=null){\n            if(root.left!=null){\n                // connect threading for root\n                temp = root.left;\n                while(temp.right!=null && temp.right != root)\n                    temp = temp.right;\n                // the threading already exists\n                if(temp.right!=null){\n                    if(pre!=null && pre.val > root.val){\n                        if(first==null){first = pre;second = root;}\n                        else{second = root;}\n                    }\n                    pre = root;\n\n                    temp.right = null;\n                    root = root.right;\n                }else{\n                    // construct the threading\n                    temp.right = root;\n                    root = root.left;\n                }\n            }else{\n                if(pre!=null && pre.val > root.val){\n                    if(first==null){first = pre;second = root;}\n                    else{second = root;}\n                }\n                pre = root;\n                root = root.right;\n            }\n        }\n        // swap two node values;\n        if(first!= null && second != null){\n            int t = first.val;\n            first.val = second.val;\n            second.val = t;\n        }\n    }\n}",
        "tags": "12, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 357,
        "number": 115,
        "title": "Distinct Subsequences",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string <b>S</b> and a string <b>T</b>, count the number of distinct subsequences of <b>S</b> which equals <b>T</b>.\n</p>\n\n    <p>\n        A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>\"ACE\"</code> is a subsequence of <code>\"ABCDE\"</code> while <code>\"AEC\"</code> is not).\n    </p>\n\n    <p>\n        Here is an example:<br>\n        <b>S</b> = <code>\"rabbbit\"</code>, <b>T</b> = <code>\"rabbit\"</code>\n    </p>\n    <p>\n        Return <code>3</code>.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int numDistinct(String S, String T) {\n        int si = S.length(), ti = T.length();\n        if (si <= 0 || ti <= 0 || si < ti) return 0;\n\n        int[][] dptable = new int[si][ti];\n        dptable[0][0] = S.charAt(0) == T.charAt(0) ? 1 : 0;\n        for (int j = 0; j < ti; j++) {\n            for (int i = 1; i < si; i++) {\n                dptable[i][j] = dptable[i-1][j];\n                if (S.charAt(i) == T.charAt(j)) {\n                    dptable[i][j] += j == 0 ? 1 : dptable[i - 1][j - 1];\n                }\n            }\n        }\n        return dptable[si - 1][ti - 1];\n    }\n}",
        "tags": "5, 9",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 358,
        "number": 123,
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n    <p>Design an algorithm to find the maximum profit. You may complete at most <i>two</i> transactions.</p>\n\n    <p><b>Note:</b><br>\n        You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length < 2) {\n            return 0;\n        }\n\n        //highest profit in 0 ... i\n        int[] left = new int[prices.length];\n        int[] right = new int[prices.length];\n\n        // DP from left to right\n        left[0] = 0;\n        int min = prices[0];\n        for (int i = 1; i < prices.length; i++) {\n            min = Math.min(min, prices[i]);\n            left[i] = Math.max(left[i - 1], prices[i] - min);\n        }\n\n        // DP from right to left\n        right[prices.length - 1] = 0;\n        int max = prices[prices.length - 1];\n        for (int i = prices.length - 2; i >= 0; i--) {\n            max = Math.max(max, prices[i]);\n            right[i] = Math.max(right[i + 1], max - prices[i]);\n        }\n\n        int profit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            profit = Math.max(profit, left[i] + right[i]);\n        }\n        return profit;\n    }\n}",
        "tags": "0, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 359,
        "number": 124,
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a binary tree, find the maximum path sum.\n</p>\n\n    <p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <b>at least one node</b> and does not need to go through the root.</p>\n\n    <p>\n        For example:<br>\n        Given the below binary tree,\n    </p><pre>       1\n      / \\\n     2   3\n</pre>\n    <p></p>\n    <p>\n        Return <code>6</code>.\n    </p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int maxPathSum(TreeNode root) {\n        int max[] = new int[1];\n        max[0] = Integer.MIN_VALUE;\n        calculateSum(root, max);\n        return max[0];\n    }\n\n    int calculateSum(TreeNode root, int[] max) {\n        if (root == null) return 0;\n\n        int left = calculateSum(root.left, max);\n        int right = calculateSum(root.right, max);\n\n        int current = Math.max(root.val, Math.max(root.val + left, root.val + right));\n        max[0] = Math.max(max[0], Math.max(current, left + root.val + right));\n\n        return current;\n    }\n}",
        "tags": "12, 14",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 360,
        "number": 126,
        "title": "Word Ladder II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary's word list, find all shortest transformation sequence(s) from <i>beginWord</i> to <i>endWord</i>, such that:\n</p>\n    <ol>\n        <li>Only one letter can be changed at a time</li>\n        <li>Each transformed word must exist in the word list. Note that <i>beginWord</i> is <i>not</i> a transformed word.</li>\n    </ol>\n\n    <p>\n        For example,\n    </p>\n    <p>\n        Given:<br>\n        <i>beginWord</i> = <code>\"hit\"</code><br>\n        <i>endWord</i> = <code>\"cog\"</code><br>\n        <i>wordList</i> = <code>[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</code><br>\n    </p>\n    <p>\n        Return<br>\n    </p><pre>  [\n    [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\n    [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\n  ]\n</pre>\n    <p></p>\n\n    <p>\n        <b>Note:</b><br>\n    </p><ul>\n    <li>Return an empty list if there is no such transformation sequence.</li>\n    <li>All words have the same length.</li>\n    <li>All words contain only lowercase alphabetic characters.</li>\n    <li>You may assume no duplicates in the word list.</li>\n    <li>You may assume <i>beginWord</i> and <i>endWord</i> are non-empty and are not the same.</li>\n</ul>\n</div>",
        "solution": "public class Solution {\n\n    class WordNode {\n        String word;\n        int numSteps;\n        WordNode pre;\n\n        public WordNode(String word, int numSteps, WordNode pre) {\n            this.word = word;\n            this.numSteps = numSteps;\n            this.pre = pre;\n        }\n    }\n\n    // Single direction BFS\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> result = new ArrayList<>();\n        LinkedList<WordNode> queue = new LinkedList<>();\n        queue.add(new WordNode(beginWord, 1, null));\n        int minStep = 0;\n\n        HashSet<String> visited = new HashSet<>();\n        HashSet<String> unvisited = new HashSet<>();\n        unvisited.addAll(wordList);\n        int preNumSteps = 0;\n\n        while (!queue.isEmpty()) {\n            WordNode top = queue.remove();\n            String word = top.word;\n            int currNumSteps = top.numSteps;\n\n            if (word.equals(endWord)) {\n                if (minStep == 0) {\n                    minStep = top.numSteps;\n                }\n\n                if (top.numSteps == minStep && minStep != 0) {\n                    ArrayList<String> t = new ArrayList<>();\n                    t.add(top.word);\n                    while (top.pre != null) {\n                        t.add(0, top.pre.word);\n                        top = top.pre;\n                    }\n                    result.add(t);\n                    continue;\n                }\n            }\n\n            // The used word is only removed when steps change.\n            // Start of the next level\n            if (preNumSteps < currNumSteps) {\n                unvisited.removeAll(visited);\n            }\n            preNumSteps = currNumSteps;\n\n            char[] arr = word.toCharArray();\n            for (int i = 0; i < arr.length; i++) {\n                for (char c = 'a'; c <= 'z'; c++) {\n                    char temp = arr[i];\n                    if (arr[i] != c) {\n                        arr[i] = c;\n                    }\n\n                    String newWord = new String(arr);\n                    if (unvisited.contains(newWord)) {\n                        queue.add(new WordNode(newWord, top.numSteps + 1, top));\n                        visited.add(newWord);\n                    }\n                    arr[i] = temp;\n                }\n            }\n        }\n        return result;\n    }\n\n    // Bi-direction BFS\n    //flag of whether we have connected two parts\n    boolean isConnected = false;\n    public List<List<String>> findLadders(String beginWord, String endWord, Set<String> wordList) {\n        //we use bi-directional BFS to find shortest path\n        Set<String> fwd = new HashSet<>();\n        fwd.add(beginWord);\n        Set<String> bwd = new HashSet<>();\n        bwd.add(endWord);\n\n        Map<String, List<String>> hs = new HashMap<>();\n        BFS(fwd, bwd, wordList, false, hs);\n        List<List<String>> result = new ArrayList<>();\n        //if two parts cannot be connected, then return empty list\n        if(!isConnected) return result;\n\n        //we need to add start node to temp list as there is no other node can get start node\n        List<String> temp = new ArrayList<>();\n        temp.add(beginWord);\n\n        DFS(result, temp, beginWord, endWord, hs);\n        return result;\n    }\n\n    public void BFS(Set<String> forward, Set<String> backward, Set<String> dict, boolean swap, Map<String, List<String>> hs){\n        //boundary check\n        if(forward.isEmpty() || backward.isEmpty()){\n            return;\n        }\n\n        //we always do BFS on direction with less nodes\n        //here we assume forward set has less nodes, if not, we swap them\n        if(forward.size() > backward.size()){\n            BFS(backward, forward, dict, !swap, hs);\n            return;\n        }\n\n        //remove all forward/backward words from dict to avoid duplicate addition\n        dict.removeAll(forward);\n        dict.removeAll(backward);\n\n        //new set contains all new nodes from forward set\n        Set<String> set3 = new HashSet<String>();\n\n        //do BFS on every node of forward direction\n        for(String str : forward){\n            //try to change each char of str\n            for(int i = 0; i < str.length(); i++){\n                //try to replace current char with every chars from a to z\n                char[] ary = str.toCharArray();\n                for(char j = 'a'; j <= 'z'; j++){\n                    ary[i] = j;\n                    String temp = new String(ary);\n\n                    //we skip this string if it is not in dict nor in backward\n                    if(!backward.contains(temp) && !dict.contains(temp)){\n                        continue;\n                    }\n\n                    //we follow forward direction\n                    String key = !swap? str : temp;\n                    String val = !swap? temp : str;\n\n                    if(!hs.containsKey(key))\n                        hs.put(key, new ArrayList<String>());\n                    //if temp string is in backward set, then it will connect two parts\n                    if(backward.contains(temp)){\n                        hs.get(key).add(val);\n                        isConnected = true;\n                    }\n\n                    //if temp is in dict, then we can add it to set3 as new nodes in next layer\n                    if(!isConnected && dict.contains(temp)){\n                        hs.get(key).add(val);\n                        set3.add(temp);\n                    }\n                }\n\n            }\n        }\n\n        //to force our path to be shortest, we will not do BFS if we have found shortest path(isConnected = true)\n        if(!isConnected){\n            BFS(set3, backward, dict, swap, hs);\n        }\n    }\n\n    public void DFS(List<List<String>> result, List<String> temp, String start, String end, Map<String, List<String>> hs){\n        //we will use DFS, more specifically backtracking to build paths\n        //boundary case\n        if(start.equals(end)){\n            result.add(new ArrayList<String>(temp));\n            return;\n        }\n\n        //not each node in hs is valid node in shortest path, if we found current node does not have children node,\n        //then it means it is not in shortest path\n        if(!hs.containsKey(start)){\n            return;\n        }\n\n        for(String s : hs.get(start)){\n            temp.add(s);\n            DFS(result, temp, s, end, hs);\n            temp.remove(temp.size()-1);\n\n        }\n    }\n}",
        "tags": "0, 5, 14, 19",
        "companies": "0",
        "specialtags": "0, 2"
    },
    {
        "id": 361,
        "number": 128,
        "title": "Longest Consecutive Sequence",
        "difficulty": "Hard",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\n</p>\n    <p>\n        For example,<br>\n        Given <code>[100, 4, 200, 1, 3, 2]</code>,<br>\n        The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.\n    </p>\n    <p>\n        Your algorithm should run in O(<i>n</i>) complexity.\n    </p><p></p>\n\n</div>",
        "solution": "public class Solution {\n    /***\n     *  Use a map to store ranges\n     *  Get lower bound with smaller value\n     *  Get upper bound with larger value\n     *  Update max length with new bound\n     *  Put all possible ranges into map\n     *  1. num, num\n     *  2. low, upp\n     *  3. upp, low\n     *\n     */\n    public int longestConsecutive(int[] nums) {\n        if(nums == null || nums.length == 0) return 0;\n        Map<Integer, Integer> rangeMap = new HashMap<>();\n        int maxLen = 0;\n        for(int num : nums){\n            // Ignore duplicates\n            if(rangeMap.containsKey(num)) continue;\n            int low = num;\n            int upp = num;\n            if(rangeMap.containsKey(num - 1))\n                low = rangeMap.get(num - 1);\n            if(rangeMap.containsKey(num + 1))\n                upp = rangeMap.get(num + 1);\n            maxLen = Math.max(maxLen, upp - low + 1);\n            // All possible ranges\n            rangeMap.put(num, num);\n            rangeMap.put(low, upp);\n            rangeMap.put(upp, low);\n        }\n        return maxLen;\n    }\n}",
        "tags": "0, 16",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 362,
        "number": 132,
        "title": "Palindrome Partitioning II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.\n</p>\n    <p>\n        Return the minimum cuts needed for a palindrome partitioning of <i>s</i>.\n    </p>\n    <p>\n        For example, given <i>s</i> = <code>\"aab\"</code>,<br>\n        Return <code>1</code> since the palindrome partitioning <code>[\"aa\",\"b\"]</code> could be produced using 1 cut.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int minCut(String s) {\n        int n = s.length();\n        boolean dp[][] = new boolean[n][n];\n        int cut[] = new int[n];\n\n        for (int j = 0; j < n; j++) {\n            cut[j] = j; //set maximum # of cut\n            for (int i = 0; i <= j; i++) {\n                if (s.charAt(i) != s.charAt(j) || (j - i > 1 && !dp[i + 1][j - 1]))\n                    continue;\n                dp[i][j] = true;\n                // if [0...j] is palindrome, no need to cut\n                // else need to cut, add 1 to the previous cut[i-1]\n                cut[j] = (i == 0) ? 0 : Math.min(cut[j], cut[i - 1] + 1);\n            }\n        }\n        return cut[n - 1];\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 363,
        "number": 135,
        "title": "Candy",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    There are <i>N</i> children standing in a line. Each child is assigned a rating value.\n</p>\n    <p>\n        You are giving candies to these children subjected to the following requirements:\n    </p>\n    <ul>\n        <li>Each child must have at least one candy.</li>\n        <li>Children with a higher rating get more candies than their neighbors.</li>\n    </ul>\n    <p>\n        What is the minimum candies you must give?\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int candy(int[] ratings) {\n        int[] candys = new int[ratings.length];\n        // Each person get one\n        Arrays.fill(candys, 1);\n        // This ensure the right advanced child has more candy than child on left\n        for(int i = 1; i < ratings.length; i++) {\n            if(ratings[i] > ratings[i - 1]) {\n                candys[i] = candys[i - 1] + 1;\n            }\n        }\n\n        // This ensure the advanced child on the right has more than child on right\n        for(int i = ratings.length - 2; i >= 0; i--) {\n            if(ratings[i] > ratings[i + 1] && candys[i] <= candys[i + 1]) {\n                candys[i] = candys[i + 1] + 1;\n            }\n        }\n\n        int n = 0;\n        for(int i = 0; i < candys.length; i++) {\n            n += candys[i];\n        }\n        return n;\n    }\n\n    // One pass and constant space\n    public int candy(int[] ratings) {\n        if (ratings.length <= 1) {\n            return ratings.length;\n        }\n        int candies = 0;\n        int up = 0;\n        int down = 0;\n        int old_slope = 0;\n        for (int i = 1; i < ratings.length; i++) {\n            int new_slope = (ratings[i] > ratings[i - 1]) ? 1 : (ratings[i] < ratings[i - 1] ? -1 : 0);\n            if ((old_slope > 0 && new_slope == 0) || (old_slope < 0 && new_slope >= 0)) {\n                candies += count(up) + count(down) + Math.max(up, down);\n                up = 0;\n                down = 0;\n            }\n            if (new_slope > 0)\n                up++;\n            if (new_slope < 0)\n                down++;\n            if (new_slope == 0)\n                candies++;\n\n            old_slope = new_slope;\n        }\n        candies += count(up) + count(down) + Math.max(up, down) + 1;\n        return candies;\n    }\n\n    private int count(int n) {\n        return (n * (n + 1)) / 2;\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 364,
        "number": 140,
        "title": "Word Break II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a <b>non-empty</b> string <i>s</i> and a dictionary <i>wordDict</i> containing a list of <b>non-empty</b> words, add spaces in <i>s</i> to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.\n</p>\n\n    <p>\n        Return all such possible sentences.\n    </p>\n\n    <p>\n        For example, given<br>\n        <i>s</i> = <code>\"catsanddog\"</code>,<br>\n        <i>dict</i> = <code>[\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]</code>.\n    </p>\n\n    <p>\n        A solution is <code>[\"cats and dog\", \"cat sand dog\"]</code>.\n    </p>\n\n    <p>\n        <b><font color=\"red\">UPDATE (2017/1/4):</font></b><br>\n        The <i>wordDict</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    // http://www.programcreek.com/2014/03/leetcode-word-break-ii-java/\n    public List<String> wordBreak(String s, Set<String> wordDict) {\n        List<String>[] pos = new ArrayList[s.length() + 1];\n        pos[0] = new ArrayList<String>();\n        // Construct a graph for positions with related words\n        for (int i = 0; i < s.length(); i++) {\n            if (pos[i] == null) continue;\n            for (int j = i + 1; j <= s.length(); j++) {\n                String sub = s.substring(i, j);\n                if (!wordDict.contains(sub)) continue;\n                if (pos[j] == null) {\n                    pos[j] = new ArrayList<String>();\n                }\n                pos[j].add(sub);\n            }\n        }\n\n        List<String> result = new ArrayList<String>();\n        if (pos[s.length()] != null)\n            dfs(pos, result, \"\", s.length());\n        return result;\n    }\n\n    public void dfs(List<String>[] pos, List<String> result, String curr, int curInd) {\n        if (curInd == 0) {\n            result.add(curr.trim());\n            return;\n        }\n\n        for (String s : pos[curInd]) {\n            String combined = s + \" \" + curr;\n            dfs(pos, result, combined, curInd - s.length());\n        }\n    }\n}",
        "tags": "8, 9",
        "companies": "0",
        "specialtags": "0"
    },
    {
        "id": 365,
        "number": 145,
        "title": "Binary Tree Postorder Traversal",
        "difficulty": "Hard",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a binary tree, return the <i>postorder</i> traversal of its nodes' values.</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>{1,#,2,3}</code>,<br>\n    </p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n    <p></p>\n    <p>\n        return <code>[3,2,1]</code>.\n    </p>\n\n    <p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Recursive Solution\n    public ArrayList<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> re = new ArrayList<Integer>();\n        if (root == null) return re;\n        re.addAll(postorderTraversal(root.left));\n        re.addAll(postorderTraversal(root.right));\n        re.add(root.val);\n        return re;\n    }\n\n    // Iterative Solution\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if (root == null) return res;\n        Stack<TreeNode> parentStack = new Stack<>();\n        TreeNode lastnodevisited = root, peekNode;\n        while (!parentStack.isEmpty() || root != null) {\n            if (root!= null) {\n                parentStack.push(root);\n                root = root.left;\n            } else {\n                peekNode = parentStack.peek();\n                // If right child exists AND traversing node from left child, move right\n                if (peekNode.right != null && lastnodevisited != peekNode.right) {\n                    root = peekNode.right;\n                } else {\n                    parentStack.pop();\n                    res.add(peekNode.val);\n                    lastnodevisited = peekNode;\n                }\n            }\n        }\n        return res;\n    }\n}",
        "tags": "12, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 366,
        "number": 146,
        "title": "LRU Cache",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Design and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.\n</p>\n\n    <p>\n        <code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\n        <code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\n    </p>\n\n    <p><b>Follow up:</b><br>\n        Could you do both operations in <b>O(1)</b> time complexity?</p>\n\n    <p><b>Example:</b>\n    </p><pre>LRUCache cache = new LRUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.put(4, 4);    // evicts key 1\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class LRUCache {\n    class DoubleLinkedListNode {\n        int val, key;\n        DoubleLinkedListNode pre, post;\n\n        public DoubleLinkedListNode(int key, int value) {\n            this.val = value;\n            this.key = key;\n        }\n    }\n\n    Map<Integer, LRUCache.DoubleLinkedListNode> table;\n    DoubleLinkedListNode head, end;\n    int capacity, len;\n\n    public LRUCache(int capacity) {\n        this.table = new HashMap<Integer, LRUCache.DoubleLinkedListNode>();\n        this.capacity = capacity;\n        this.len = 0;\n    }\n\n    public int get(int key) {\n        if (!table.containsKey(key)) return -1;\n        removeNode(table.get(key));\n        setHead(table.get(key));\n        return table.get(key).val;\n    }\n\n    public void put(int key, int value) {\n        if (table.containsKey(key)) {\n            DoubleLinkedListNode cur = table.get(key);\n            cur.val = value;\n            removeNode(cur);\n            setHead(cur);\n        } else {\n            DoubleLinkedListNode cur = new DoubleLinkedListNode(key, value);\n            if (len < capacity) {\n                setHead(cur);\n                table.put(key, cur);\n                len++;\n            } else {\n                table.remove(end.key);\n                end = end.pre;\n                if (end != null)\n                    end.post = null;\n                setHead(cur);\n                table.put(key, cur);\n            }\n        }\n    }\n\n    void removeNode(DoubleLinkedListNode node) {\n        DoubleLinkedListNode cur = node, pre = cur.pre, post = cur.post;\n        // Link to pre\n        if (pre != null) {\n            pre.post = post;\n        } else {\n            head = post;\n        }\n        // Link to post\n        if (post != null) {\n            post.pre = pre;\n        } else {\n            end = pre;\n        }\n    }\n\n    void setHead(DoubleLinkedListNode node) {\n        node.post = head;\n        node.pre = null;\n        if (head != null) head.pre = node; // check head\n        if (end == null) end = node; // check end\n        head = node;\n    }\n}\n",
        "tags": "10",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 367,
        "number": 149,
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "description": "Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.",
        "solution": "package maxPointsOnaLine;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    /*\n     *  A line is determined by two factors,say y=ax+b  \n     *  If two points(x1,y1) (x2,y2) are on the same line(Of course). \n     *  Consider the gap between two points.\n     *  We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, \n     *  b is canceled since b is a constant.\n     *  If a third point (x3,y3) are on the same line. So we must have y3=ax3+b\n     *  Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\n     *  Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\n     *  So we can use y0&x0 to track a line;\n     */\n    public int maxPoints(Point[] points) {\n        if (points == null)\n            return 0;\n        if (points.length <= 2)\n            return points.length;\n\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\n        int result = 0;\n        for (int i = 0; i < points.length; i++) {\n            map.clear();\n            int overlap = 0, max = 0;\n            for (int j = i + 1; j < points.length; j++) {\n                int x = points[j].x - points[i].x;\n                int y = points[j].y - points[i].y;\n                if (x == 0 && y == 0) {\n                    overlap++;\n                    continue;\n                }\n                int gcd = generateGCD(x, y);\n                if (gcd != 0) {\n                    x /= gcd;\n                    y /= gcd;\n                }\n\n                if (map.containsKey(x)) {\n                    if (map.get(x).containsKey(y)) {\n                        map.get(x).put(y, map.get(x).get(y) + 1);\n                    } else {\n                        map.get(x).put(y, 1);\n                    }\n                } else {\n                    Map<Integer, Integer> m = new HashMap<>();\n                    m.put(y, 1);\n                    map.put(x, m);\n                }\n                max = Math.max(max, map.get(x).get(y));\n            }\n            result = Math.max(result, max + overlap + 1);\n        }\n        return result;\n    }\n\n    private int generateGCD(int a, int b) {\n        return b == 0 ? a : generateGCD(b, a % b);\n    }\n}\n",
        "tags": "1, 3",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 368,
        "number": 154,
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><blockquote>\n    <p><i>Follow up</i> for \"Find Minimum in Rotated Sorted Array\":<br>\n        What if <i>duplicates</i> are allowed?</p>\n\n    <p>Would this affect the run-time complexity? How and why?</p>\n</blockquote>\n\n    <p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n    <p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n    <p>Find the minimum element.</p>\n\n    <p>The array may contain duplicates.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findMin(int[] num) {\n        if (num.length == 0) return 0;\n        int l = 0;\n        int r = num.length - 1;\n        int min = num[0];\n        while (l < r - 1) {\n            int mid = (l + r) / 2;\n            if (num[l] < num[mid]) {\n                min = Math.min(min, num[l]);\n                l = mid + 1;\n            } else if (num[l] > num[mid]) {\n                min = Math.min(min, num[mid]);\n                r = mid - 1;\n            } else {\n                l++;\n            }\n        }\n        return Math.min(Math.min(min, num[l]), num[r]);\n    }\n}",
        "tags": "0, 11",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 369,
        "number": 158,
        "title": "Read N Characters Given Read4 II",
        "difficulty": "Hard",
        "description": "<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    The API:&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">int read4(char *buf)</code>&nbsp;reads 4 characters at a time from a file.</div>\n\n<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    The API:&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">int read4(char *buf)</code>&nbsp;reads 4 characters at a time from a file.</div>\n\n<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    By using the&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">read4</code>&nbsp;API, implement the function&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">int read(char *buf, int n)</code>&nbsp;that reads&nbsp;<i style=\"box-sizing: border-box;\">n</i>&nbsp;characters from the file.</div>\n<div style=\"background-color: white; box-sizing: border-box; color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; margin-bottom: 10px;\">\n    <span style=\"box-sizing: border-box; font-weight: 700;\">Note:</span><br>\n    The&nbsp;<code style=\"background-color: #f9f2f4; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; box-sizing: border-box; color: #c7254e; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; padding: 2px 4px;\">read</code>&nbsp;function may be called multiple times.</div>\n",
        "solution": "public class Solution extends Reader4 {\n    // 时间 O(N) 空间 O(1)\n    Queue<Character> remain = new LinkedList<Character>();\n    public int read(char[] buf, int n) {\n        int i = 0;\n        // 队列不为空时，先读取队列中的暂存字符\n        while (i < n && !remain.isEmpty()) {\n            buf[i] = remain.poll();\n            i++;\n        }\n        for (; i < n; i += 4) {\n            char[] tmp = new char[4];\n            int len = read4(tmp);\n            // 如果读到字符多于我们需要的字符，需要暂存这些多余字符\n            if (len > n - i) {\n                System.arraycopy(tmp, 0, buf, i, n - i);\n                // 把多余的字符存入队列中\n                for (int j = n - i; j < len; j++) {\n                    remain.offer(tmp[j]);\n                }\n                // 如果读到的字符少于我们需要的字符，直接拷贝\n            } else {\n                System.arraycopy(tmp, 0, buf, i, len);\n            }\n            // 同样的，如果读不满4个，说明数据已经读完，返回总所需长度和目前已经读到的长度的较小的\n            if (len < 4) return Math.min(i + len, n);\n        }\n        // 如果到这里，说明都是完美读取，直接返回n\n        return n;\n    }\n}",
        "tags": "0",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 370,
        "number": 164,
        "title": "Maximum Gap",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>\n\n    <p>Try to solve it in linear time/space.</p>\n\n    <p>Return 0 if the array contains less than 2 elements.</p>\n\n    <p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Suppose there are N elements in the array, the min value is min and the max value is max.\n     * Then the maximum gap will be no smaller than ceiling[(max - min ) / (N - 1)].\n     * Let gap = ceiling[(max - min ) / (N - 1)].\n     * We divide all numbers in the array into n-1 buckets,\n     * where k-th bucket contains all numbers in [min + (k-1)gap, min + k*gap).\n     * Since there are n-2 numbers that are not equal min or max and there are n-1 buckets,\n     * at least one of the buckets are empty.\n     * We only need to store the largest number and the smallest number in each bucket.\n     * After we put all the numbers into the buckets.\n     * We can scan the buckets sequentially and get the max gap.\n     */\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length < 2)\n            return 0;\n        // get the max and min value of the array\n        int min = nums[0];\n        int max = nums[0];\n        for (int i : nums) {\n            min = Math.min(min, i);\n            max = Math.max(max, i);\n        }\n        // the minimum possibale gap, ceiling of the integer division\n        int gap = (int) Math.ceil((double) (max - min) / (nums.length - 1));\n        int[] bucketsMIN = new int[nums.length - 1]; // store the min value in that bucket\n        int[] bucketsMAX = new int[nums.length - 1]; // store the max value in that bucket\n        Arrays.fill(bucketsMIN, Integer.MAX_VALUE);\n        Arrays.fill(bucketsMAX, Integer.MIN_VALUE);\n        // put numbers into buckets\n        for (int i : nums) {\n            if (i == min || i == max)\n                continue;\n            int idx = (i - min) / gap; // index of the right position in the buckets\n            bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);\n            bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);\n        }\n        // scan the buckets for the max gap\n        int maxGap = Integer.MIN_VALUE;\n        int previous = min;\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (bucketsMIN[i] == Integer.MAX_VALUE && bucketsMAX[i] == Integer.MIN_VALUE)\n                // empty bucket\n                continue;\n            // min value minus the previous value is the current gap\n            maxGap = Math.max(maxGap, bucketsMIN[i] - previous);\n            // update previous bucket value\n            previous = bucketsMAX[i];\n        }\n        maxGap = Math.max(maxGap, max - previous); // updata the final max value gap\n        return maxGap;\n    }\n}",
        "tags": "13",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 371,
        "number": 174,
        "title": "Dungeon Game",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p><style>\ntable.dungeon, .dungeon th, .dungeon td {\n  border:3px solid black;\n}\n\n .dungeon th, .dungeon td {\n    text-align: center;\n    height: 70px;\n    width: 70px;\n}\n</style>\n\n    </p><p>The demons had captured the princess (<b>P</b>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<b>K</b>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. </p>\n    <p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. </p>\n    <p>Some of the rooms are guarded by demons, so the knight loses health (<i>negative</i> integers) upon entering these rooms;\n        other rooms are either empty (<i>0's</i>) or contain magic orbs that increase the knight's health (<i>positive</i> integers).</p>\n    <p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. </p>\n\n    <br>\n    <p><b>Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.</b></p>\n    <p>For example, given the dungeon below, the initial health of the knight must be at least <b>7</b> if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p>\n\n    <table class=\"dungeon\">\n        <tbody><tr>\n            <td>-2 (K)</td>\n            <td>-3</td>\n            <td>3</td>\n        </tr>\n        <tr>\n            <td>-5</td>\n            <td>-10</td>\n            <td>1</td>\n        </tr>\n        <tr>\n            <td>10</td>\n            <td>30</td>\n            <td>-5 (P)</td>\n        </tr>\n        </tbody></table>\n    <!---2K   -3  3\n    -5   -10   1\n    10 30   5P-->\n\n    <br>\n    <p><b>Notes:</b>\n    </p><ul>\n    <li>The knight's health has no upper bound.</li>\n    <li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  </li>\n</ul>\n\n</div>",
        "solution": "public class Solution {\n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length;\n        int n = dungeon[0].length;\n\n        //init dp table\n        int[][] h = new int[m][n];\n        h[m - 1][n - 1] = Math.max(1 - dungeon[m - 1][n - 1], 1);\n        //init last row\n        for (int i = m - 2; i >= 0; i--) {\n            h[i][n - 1] = Math.max(h[i + 1][n - 1] - dungeon[i][n - 1], 1);\n        }\n        //init last column\n        for (int j = n - 2; j >= 0; j--) {\n            h[m - 1][j] = Math.max(h[m - 1][j + 1] - dungeon[m - 1][j], 1);\n        }\n\n        //calculate dp table\n        for (int i = m - 2; i >= 0; i--) {\n            for (int j = n - 2; j >= 0; j--) {\n                int down = Math.max(h[i + 1][j] - dungeon[i][j], 1);\n                int right = Math.max(h[i][j + 1] - dungeon[i][j], 1);\n                h[i][j] = Math.min(right, down);\n            }\n        }\n        return h[0][0];\n    }\n}",
        "tags": "11, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 372,
        "number": 188,
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n    <p>Design an algorithm to find the maximum profit. You may complete at most <b>k</b> transactions.</p>\n\n    <p><b>Note:</b><br>\n        You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\n\n</div>",
        "solution": "public class Solution {\n    public int maxProfit(int k, int[] prices) {\n        if (prices.length < 2) return 0;\n        if (k >= prices.length / 2) return maxProfit2(prices);\n\n        int[] local = new int[k + 1];\n        int[] global = new int[k + 1];\n\n        for (int i = 1; i < prices.length; i++) {\n            int diff = prices[i] - prices[i - 1];\n            for (int j = k; j > 0; j--) {\n                local[j] = Math.max(global[j - 1], local[j] + diff);\n                global[j] = Math.max(global[j], local[j]);\n            }\n        }\n        return global[k];\n    }\n\n    public int maxProfit2(int[] prices) {\n        int maxProfit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1]) {\n                maxProfit += prices[i] - prices[i - 1];\n            }\n        }\n        return maxProfit;\n    }\n}",
        "tags": "9",
        "companies": "0",
        "specialtags": "0, 2"
    },
    {
        "id": 373,
        "number": 212,
        "title": "Word Search II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a 2D board and a list of words from the dictionary, find all words in the board.\n</p>\n    <p>\n        Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n    </p>\n\n    <p>\n        For example,<br>\n        Given <b>words</b> = <code>[\"oath\",\"pea\",\"eat\",\"rain\"]</code> and <b>board</b> =\n    </p><pre>[\n  ['<span style=\"color:#d70\">o</span>','<span style=\"color:#d70\">a</span>','a','n'],\n  ['e','<span style=\"color:#d30\">t</span>','<span style=\"color:#d00\">a</span>','<span style=\"color:#d00\">e</span>'],\n  ['i','<span style=\"color:#d70\">h</span>','k','r'],\n  ['i','f','l','v']\n]\n</pre>\n\n    Return <code>[\"eat\",\"oath\"]</code>.\n    <p></p>\n\n    <p>\n        <b>Note:</b><br>\n        You may assume that all inputs are consist of lowercase letters <code>a-z</code>.\n    </p>\n\n    <p class=\"showspoilers\"><a href=\"#\" onclick=\"showSpoilers(this); return false;\">click to show hint.</a></p>\n\n    <div class=\"spoilers\" style=\"display: block;\"><p>You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?</p>\n\n        <p>If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: <a href=\"https://leetcode.com/problems/implement-trie-prefix-tree/\">Implement Trie (Prefix Tree)</a> first.</p>\n    </div><p></p>\n</div>",
        "solution": "public class Solution {\n    class TrieNode {\n        TrieNode[] next = new TrieNode[26];\n        String word;\n    }\n\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> res = new ArrayList<>();\n        TrieNode root = buildTrie(words);\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                dfs (board, i, j, root, res);\n            }\n        }\n        return res;\n    }\n\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\n        char c = board[i][j];\n        if (c == '#' || p.next[c - 'a'] == null) return;\n        p = p.next[c - 'a'];\n        if (p.word != null) {   // found one\n            res.add(p.word);\n            p.word = null;     // de-duplicate\n        }\n\n        board[i][j] = '#';\n        if (i > 0) dfs(board, i - 1, j ,p, res);\n        if (j > 0) dfs(board, i, j - 1, p, res);\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res);\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res);\n        board[i][j] = c;\n    }\n\n    public TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String w : words) {\n            TrieNode p = root;\n            for (char c : w.toCharArray()) {\n                int i = c - 'a';\n                if (p.next[i] == null) p.next[i] = new TrieNode();\n                p = p.next[i];\n            }\n            p.word = w;\n        }\n        return root;\n    }\n}",
        "tags": "8, 11",
        "companies": "0",
        "specialtags": "0, 2"
    },
    {
        "id": 374,
        "number": 214,
        "title": "Shortest Palindrome",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\n</p>\n\n    <p>For example: </p>\n    <p>Given <code>\"aacecaaa\"</code>, return <code>\"aaacecaaa\"</code>.</p>\n    <p>Given <code>\"abcd\"</code>, return <code>\"dcbabcd\"</code>.</p>\n\n</div>",
        "solution": "public class Solution {\n    public String shortestPalindrome(String s) {\n        // Find out explaination on https://www.youtube.com/channel/UCMNkvKnD3mo3Jj9eTwJllWw\n        String rev_s = new StringBuilder(s).reverse().toString();\n        //use special character to avoid overlap\n        String l = s + \"#\" + rev_s;\n\n        int[] p = getOverlay(l);\n        return rev_s.substring(0, s.length() - p[l.length() - 1]) + s;\n    }\n\n    // Generate the prefix function for pattern itself\n    int[] getOverlay(String pattern){\n        int[] res = new int[pattern.length()];\n        res[0] = 0;\n\n        for(int i = 1; i < pattern.length(); i++){\n            int index = res[i-1];\n            while (index > 0 && pattern.charAt(index) != pattern.charAt(i))\n                index = res[index-1];\n            res[i] = (pattern.charAt(index) == pattern.charAt(i)) ? index + 1 : 0;\n        }\n        return res;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 375,
        "number": 218,
        "title": "The Skyline Problem",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <b>given the locations and height of all the buildings</b> as shown on a cityscape photo (Figure A), write a program to <b>output the skyline</b> formed by these buildings collectively (Figure B).</p>\n\n    <!-- Use the following image if we'd like to define the output as 'horizontal lines' rather than 'turning points'-->\n    <!--\n    <a href=\"http://tinypic.com?ref=mij3wi\" target=\"_blank\">\n    <img style=\"max-width: 45%;\" src=\"http://i59.tinypic.com/mij3wi.jpg\" border=\"0\" alt=\"Skyline Contour\">\n    </a>\n    -->\n\n    <p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>\n\n    <p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] </code>.</p>\n\n    <p>The output is a list of \"<b>key points</b>\" (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <b>A key point is the left endpoint of a horizontal line segment</b>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\n    </p><p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>\n\n    <p><b>Notes:</b>\n    </p><ul>\n    <li> The number of buildings in any input list is guaranteed to be in the range <code>[0, 10000]</code>.</li>\n    <li> The input list is already sorted in ascending order by the left x position <code>Li</code>. </li>\n    <li> The output list must be sorted by the x position. </li>\n    <li> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...[2 3], [4 5], [12 7], ...]</code></li>\n</ul>\n    <p></p>\n\n    <p><b>Credits:</b><br>Special thanks to <a href=\"https://oj.leetcode.com/discuss/user/stellari\">@stellari</a> for adding this problem, creating these two awesome images and all test cases.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public List<int[]> getSkyline(int[][] buildings) {\n        if (buildings.length==0) return new ArrayList<int[]>();\n        return divide(buildings, 0, buildings.length-1);\n    }\n\n    public List<int[]> divide(int[][] buildings,int i,int j){\n        if(i == j){\n            List<int[]> tmp=new ArrayList<>();\n            tmp.add(new int[]{buildings[i][0], buildings[i][2]});\n            tmp.add(new int[]{buildings[i][1], 0});\n            return tmp;\n        }\n        List<int[]> left = divide(buildings, i, i+(j-i)/2);\n        List<int[]> right = divide(buildings, i+(j-i)/2+1, j);\n        return merge(left,right);\n    }\n\n    public List<int[]> merge(List<int[]> left,List<int[]> right){\n        List<int[]> ans = new ArrayList<>();\n        int l1 = 0, l2 = 0, curh1 = 0, curh2 = 0, curlocation = 0, skyline = 0;\n        while(l1 < left.size() && l2 < right.size()){\n            int[] cur1 = left.get(l1);\n            int[] cur2 = right.get(l2);\n\n            // Compare x to see which line to be cur\n            if(cur1[0] < cur2[0]){\n                curh1 = cur1[1];\n                curlocation = cur1[0];\n                l1++;\n            } else if(cur1[0] > cur2[0]){\n                curh2 = cur2[1];\n                curlocation = cur2[0];\n                l2++;\n            } else {\n                curh1 = cur1[1];\n                curh2 = cur2[1];\n                curlocation = cur1[0];\n                l1++;\n                l2++;\n            }\n\n            // If max same as skyline no need to add new point\n            // Keep track of pre skyline\n            if(skyline != Math.max(curh1, curh2)){\n                skyline = Math.max(curh1, curh2);\n                ans.add(new int[]{curlocation, skyline});\n            }\n        }\n        // Add those points left out\n        for(int i = l1; i < left.size(); i++) ans.add(left.get(i));\n        for(int i = l2; i < right.size(); i++) ans.add(right.get(i));\n        return ans;\n    }\n}",
        "tags": "7, 20, 26, 27",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 376,
        "number": 224,
        "title": "Basic Calculator",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement a basic calculator to evaluate a simple expression string.</p>\n\n    <p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <b>non-negative</b> integers and empty spaces <code> </code>.</p>\n\n    <p>You may assume that the given expression is always valid.</p>\n\n    <p>Some examples:<br>\n    </p><pre>\"1 + 1\" = 2\n\" 2-1 + 2 \" = 3\n\"(1+(4+5+2)-3)+(6+8)\" = 23\n</pre>\n    <p></p>\n\n    <p>\n        <b>Note:</b> <b>Do not</b> use the <code>eval</code> built-in library function.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int calculate(String s) {\n        Stack<Integer> stack = new Stack<Integer>();\n\t    int result = 0, number = 0, sign = 1;\n\t    for(int i = 0; i < s.length(); i++){\n\t        char c = s.charAt(i);\n\t        if(Character.isDigit(c)){\n\t            number = 10 * number + (int)(c - '0');\n\t        }else if(c == '+'){\n\t            result += sign * number;\n\t            number = 0;\n\t            sign = 1;\n\t        }else if(c == '-'){\n\t            result += sign * number;\n\t            number = 0;\n\t            sign = -1;\n\t        }else if(c == '('){\n\t            //we push the result first, then sign;\n\t            stack.push(result);\n\t            stack.push(sign);\n\t            //reset the sign and result for the value in the parenthesis\n\t            sign = 1;\n\t            result = 0;\n\t        }else if(c == ')'){\n\t            result += sign * number;\n\t            number = 0;\n\t            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\n\t            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\n\t        }\n\t    }\n\t    if(number != 0) result += sign * number;\n\t    return result;\n    }\n}",
        "tags": "3, 15",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 377,
        "number": 233,
        "title": "Number of Digit One",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.</p>\n\n    <p>\n        For example:<br>\n        Given n = 13,<br>\n        Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    /*********************\n     *   There are three cases according to number in digit:\n     *    1. cur > 1: i.e. n = 1223. cur at tens-digit\n     *      (nums[:cur] + 1)*pow(10, digit) '1' at cur:\n     *          130 '1' at tens-digit. (10...19, 110...119,......,1210...1219)\n     *    2. cur == 1:  i.e. n = 1213. cur at tens-digit\n     *      (nums[:cur])*pow(10, digit) '1' at cur:\n     *          120 '1' at tens-digit. (10...19, 110...119,......,1110...1119)\n     *      (nums[cur+1:] + 1) '1' at cur:\n     *          Four '1' at tens-digit. (1210...1213)\n     *    3. cur < 1:  i.e. n = 1203. cur at tens-digit\n     *      (nums[:cur])*pow(10, digit) '1' at cur.\n     *          120 '1' at tens-digit. (10...19, 110...119,......,1110...1119)\n     *************/\n    public int countDigitOne(int n) {\n        if(n <= 0) return 0;\n        int totalDigits = String.valueOf(n).length();\n        int digit = 0, res = 0;\n        while(digit < totalDigits){\n            int cur = (int)((n / Math.pow(10, digit)) % 10);\n            // Case 3\n            res += (int)(n / Math.pow(10, digit+1))*Math.pow(10, digit);\n            // Case 1 additional to Case 3\n            res += (cur > 1) ? Math.pow(10, digit) : 0;\n            // Case 2 additonal\n            res += (cur == 1) ? (int)(n % Math.pow(10, digit)) + 1 : 0;\n            digit++;\n        }\n        return res;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 378,
        "number": 239,
        "title": "Sliding Window Maximum",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p>\n    <p>Given an array <i>nums</i>, there is a sliding window of size <i>k</i> which is moving from the very left of the array\n        to the very right. You can only see the <i>k</i> numbers in the window. Each time the sliding window moves right\n        by one position.</p>\n\n    <p>For example,<br> Given <i>nums</i> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <i>k</i> = 3.</p>\n\n    <pre>Window position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n</pre>\n\n    <p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>\n\n    <p><b>Note: </b><br> You may assume <i>k</i> is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.</p>\n\n    <p><b>Follow up:</b><br> Could you solve it in linear time?</p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length == 0) return nums;\n        final int[] max_left = new int[nums.length];\n        final int[] max_right = new int[nums.length];\n\n        max_left[0] = nums[0];\n        max_right[nums.length - 1] = nums[nums.length - 1];\n\n        for (int i = 1; i < nums.length; i++) {\n            max_left[i] = (i % k == 0) ? nums[i] : Math.max(max_left[i - 1], nums[i]);\n\n            final int j = nums.length - i - 1;\n            max_right[j] = (j % k == 0) ? nums[j] : Math.max(max_right[j + 1], nums[j]);\n        }\n\n        final int[] sliding_max = new int[nums.length - k + 1];\n        for (int i = 0, j = 0; i + k <= nums.length; i++) {\n            sliding_max[j++] = Math.max(max_right[i], max_left[i + k - 1]);\n        }\n\n        return sliding_max;\n    }\n}",
        "tags": "20",
        "companies": "0",
        "specialtags": "0, 2"
    },
    {
        "id": 379,
        "number": 248,
        "title": "Strobogrammatic Number III",
        "difficulty": "Hard",
        "description": "<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>\n\n<p>Write a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.</p>\n\n<p>For example,</p>\n<p>Given low = \"50\", high = \"100\", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.</p>\n\n<p>Note:</p>\n<p>Because the range might be a large number, the low and high numbers are represented as string.</p>",
        "solution": "public class Solution {\n    private int count = 0;\n    private Map<Character, Character> map = new HashMap<>();\n\n    public int strobogrammaticInRange(String low, String high) {\n        if (low == null || low.length() == 0 || high == null || high.length() == 0) {\n            return 0;\n        }\n\n        fillMap();\n\n        for (int n = low.length(); n <= high.length(); n++) {\n            char[] arr = new char[n];\n            getStrobogrammaticNumbers(arr, 0, n - 1, low, high);\n        }\n\n        return count;\n    }\n\n    private void getStrobogrammaticNumbers(char[] arr, int start, int end, String low, String high) {\n        if (start > end) {\n            String s = new String(arr);\n            if ((s.length() == 1 || s.charAt(0) != '0') && compare(low, s) && compare(s, high)) {\n                count++;\n            }\n            return;\n        }\n\n        for (char c : map.keySet()) {\n            arr[start] = c;\n            arr[end] = map.get(c);\n\n            if ((start < end) || (start == end && map.get(c) == c)) {\n                getStrobogrammaticNumbers(arr, start + 1, end - 1, low, high);\n            }\n        }\n    }\n\n    // Return true if s1 <= s2\n    private boolean compare(String s1, String s2) {\n        if (s1.length() == s2.length()) {\n            if (s1.compareTo(s2) <= 0) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private void fillMap() {\n        map.put('0', '0');\n        map.put('1', '1');\n        map.put('8', '8');\n        map.put('6', '9');\n        map.put('9', '6');\n    }\n}",
        "tags": "5",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 380,
        "number": 273,
        "title": "Integer to English Words",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2<sup>31</sup> - 1.\n</p>\n\n    <p>For example,<br>\n    </p><pre>123 -&gt; \"One Hundred Twenty Three\"\n12345 -&gt; \"Twelve Thousand Three Hundred Forty Five\"\n1234567 -&gt; \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"</pre><p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    private final String[] lessThan20 = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\n            \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\",\n            \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n    private final String[] tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n            \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n    private final String[] thousands = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n\n    public String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        int i = 0;\n        String words = \"\";\n\n        while (num > 0) {\n            if (num % 1000 != 0)\n                words = helper(num % 1000) + thousands[i] + \" \" + words;\n            num /= 1000;\n            i++;\n        }\n        return words.trim();\n    }\n\n    String helper(int num) {\n        if (num == 0)\n            return \"\";\n        else if (num < 20)\n            return lessThan20[num] + \" \";\n        else if (num < 100)\n            return tens[num / 10] + \" \" + helper(num % 10);\n        else\n            return lessThan20[num / 100] + \" Hundred \" + helper(num % 100);\n    }\n}",
        "tags": "3, 5",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 381,
        "number": 282,
        "title": "Expression Add Operators",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven a string that contains only digits <code>0-9</code> and a target value, return all possibilities to add <b>binary</b> operators (not unary) <code>+</code>, <code>-</code>, or <code>*</code> between the digits so they evaluate to the target value.\n</p>\n<p>\nExamples: <br>\n</p><pre>\"123\", 6 -&gt; [\"1+2+3\", \"1*2*3\"] \n\"232\", 8 -&gt; [\"2*3+2\", \"2+3*2\"]\n\"105\", 5 -&gt; [\"1*0+5\",\"10-5\"]\n\"00\", 0 -&gt; [\"0+0\", \"0-0\", \"0*0\"]\n\"3456237490\", 9191 -&gt; []\n</pre>\n\n      </div>",
        "solution": "public class Solution {\n    \n    public List<String> addOperators(String num, int target) {\n        List<String> res = new ArrayList<String>();\n        helper(num, target, \"\", 0, 0, res);\n        return res;\n    }\n    \n    private void helper(String num, int target, String tmp, long currRes, long prevNum, List<String> res){\n        // If result = target and all numbers are used, then it is a valid result\n        if(currRes == target && num.length() == 0){\n            String exp = new String(tmp);\n            res.add(exp);\n            return;\n        }\n        // Search for all possible divided situations\n        for(int i = 1; i <= num.length(); i++){\n            String currStr = num.substring(0, i);\n            // If starts with 0 then not valid\n            if(currStr.length() > 1 && currStr.charAt(0) == '0'){\n                return;\n            }\n            // Get current number\n            long currNum = Long.parseLong(currStr);\n            // Get rid of the current number and what to search in next round\n            String next = num.substring(i);\n            // If it isn't first char, then operations else it is a number\n            if(tmp.length() != 0){\n                // multiply\n                helper(next, target, tmp+\"*\"+currNum, (currRes - prevNum) + prevNum * currNum, prevNum * currNum, res);\n                // plus\n                helper(next, target, tmp+\"+\"+currNum, currRes + currNum, currNum, res);\n                // minus\n                helper(next, target, tmp+\"-\"+currNum, currRes - currNum, -currNum, res); \n            } else {\n                // first number\n                helper(next, target, currStr, currNum, currNum, res);\n            }\n        }\n    }\n}",
        "tags": "7",
        "companies": "",
        "specialtags": "0"
    },
    {
        "id": 382,
        "number": 295,
        "title": "Find Median from Data Stream",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>\nExamples: <br>\n<p><code>[2,3,4]</code> , the median is <code>3</code></p>\n<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code> </p>\n\n<p>\nDesign a data structure that supports the following two operations:\n</p>\n<ul>\n<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>\n<li>double findMedian() - Return the median of all elements so far.</li>\n</ul>\n\n<p>\nFor example:</p>\n<pre>addNum(1)\naddNum(2)\nfindMedian() -&gt; 1.5\naddNum(3) \nfindMedian() -&gt; 2\n</pre>\n\n      </div>",
        "solution": "class MedianFinder {\n    // minHeap\n    Queue<Integer> largePQ = new PriorityQueue<>();  \n    // max Heap\n    Queue<Integer> smallPQ = new PriorityQueue<>(10, revComp); \n\n    // Adds a number into the data structure.\n    public void addNum(int num) {\n        if(smallPQ.size() <= largePQ.size()){\n            if(largePQ.isEmpty() || num <= largePQ.peek())\n                smallPQ.offer(num);\n            else{\n                smallPQ.offer(largePQ.poll());\n                largePQ.offer(num);\n            }\n        } else {\n            if(num < smallPQ.peek()){\n                largePQ.offer(smallPQ.poll());\n                smallPQ.offer(num);\n            } else {\n                largePQ.offer(num);\n            }\n        }\n    }\n\n    // Returns the median of current data stream\n    public double findMedian() {\n        if(smallPQ.size() == largePQ.size())\n            return (smallPQ.peek() + largePQ.peek())/2.0;\n        return smallPQ.peek();\n    }\n    \n    static final Comparator<Integer> revComp = new Comparator<Integer>(){\n        @Override\n        public int compare(Integer left, Integer right){\n            return right - left;\n        }\n    };\n};\n\n// Your MedianFinder object will be instantiated and called as such:\n// MedianFinder mf = new MedianFinder();\n// mf.addNum(1);\n// mf.findMedian();",
        "tags": "10, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 383,
        "number": 297,
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. </p>\n\n<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n<p>\nFor example, you may serialize the following tree\n</p><pre>    1\n   / \\\n  2   3\n     / \\\n    4   5\n</pre>\nas <code>\"[1,2,3,null,null,4,5]\"</code>, just the same as <a href=\"https://leetcode.com/faq/#binary-tree\">how LeetCode OJ serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n<p></p>\n\n<p>\n<b>Note:</b> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\n</p>\n\n      </div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) return \"\";\n        Queue<TreeNode> q = new LinkedList<>();\n        StringBuilder res = new StringBuilder();\n        q.add(root);\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (node == null) {\n                res.append(\"n \");\n                continue;\n            }\n            res.append(node.val + \" \");\n            q.add(node.left);\n            q.add(node.right);\n        }\n        return res.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data == \"\") return null;\n        Queue<TreeNode> q = new LinkedList<>();\n        String[] values = data.split(\" \");\n        TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n        q.add(root);\n        for (int i = 1; i < values.length; i++) {\n            TreeNode parent = q.poll();\n            if (!values[i].equals(\"n\")) {\n                TreeNode left = new TreeNode(Integer.parseInt(values[i]));\n                parent.left = left;\n                q.add(left);\n            }\n            if (!values[++i].equals(\"n\")) {\n                TreeNode right = new TreeNode(Integer.parseInt(values[i]));\n                parent.right = right;\n                q.add(right);\n            }\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));",
        "tags": "10, 12",
        "companies": "",
        "specialtags": "0, 2"
    },
    {
        "id": 384,
        "number": 301,
        "title": "Remove Invalid Parentheses",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>\n\n<p>Note: The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>. \n</p>\n\n<p>\n<b>Examples:</b><br>\n</p><pre>\"()())()\" -&gt; [\"()()()\", \"(())()\"]\n\"(a)())()\" -&gt; [\"(a)()()\", \"(a())()\"]\n\")(\" -&gt; [\"\"]\n</pre>\n<p></p>\n\n      </div>",
        "solution": "public class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        Set<String> res = new HashSet<>();\n        int rmL = 0, rmR = 0;\n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == '(') rmL++;\n            if(s.charAt(i) == ')') {\n                if(rmL != 0) rmL--;\n                else rmR++;\n            }\n        }\n        DFS(res, s, 0, rmL, rmR, 0, new StringBuilder());\n        return new ArrayList<String>(res);  \n    }\n\n    public void DFS(Set<String> res, String s, int i, int rmL, \n                        int rmR, int open, StringBuilder sb) {\n        if(i == s.length() && rmL == 0 && rmR == 0 && open == 0) {\n            res.add(sb.toString());\n            return;\n        }\n        if(i == s.length() || rmL < 0 || rmR < 0 || open < 0) \n            return;\n\n        char c = s.charAt(i);\n        int len = sb.length();\n\n        if(c == '(') {\n            DFS(res, s, i + 1, rmL - 1, rmR, open, sb);\n            DFS(res, s, i + 1, rmL, rmR, open + 1, sb.append(c));\n        } else if(c == ')') {\n            DFS(res, s, i + 1, rmL, rmR - 1, open, sb);\n            DFS(res, s, i + 1, rmL, rmR, open - 1, sb.append(c));\n        } else {\n            DFS(res, s, i + 1, rmL, rmR, open, sb.append(c)); \n        }\n        sb.setLength(len);\n    }\n}",
        "tags": "6, 9",
        "companies": "0",
        "specialtags": "0, 2"
    },
    {
        "id": 385,
        "number": 312,
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a\n    number on it represented by array <code>nums</code>.\n\n    You are asked to burst all the balloons. If the you burst\n    balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code>\n    and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code>\n    then becomes adjacent.\n</p>\n<p>\n    Find the maximum coins you can collect by bursting the balloons wisely.\n</p>\n<p>\n    <b>Note:</b> <br>\n    (1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>\n    (2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100\n</p>\n\n\n<p>\n    <b>Example:</b>\n</p>\n<p>\n    Given <code>[3, 1, 5, 8]</code>\n</p>\n<p>\n    Return <code>167</code>\n</p>\n<pre>    nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []\n   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n</pre>\n\n      </div>",
        "solution": "public class Solution {\n    // dp[i][j] = max(dp[i][j], \n    // dp[i][x – 1] + nums[i – 1] * nums[x] * nums[j + 1] + dp[x + 1][j]);\n    public int DP(int i, int j, int[] nums, int[][] dp) {\n        if (dp[i][j] > 0) return dp[i][j];\n        for (int x = i; x <= j; x++) {\n            dp[i][j] = Math.max(dp[i][j], DP(i, x - 1, nums, dp) + \n                nums[i - 1] * nums[x] * nums[j + 1] + DP(x + 1, j, nums, dp));\n        }\n        return dp[i][j];\n    }\n \n    public int maxCoins(int[] iNums) {\n        int n = iNums.length;\n        int[] nums = new int[n + 2];\n        for (int i = 0; i < n; i++) nums[i + 1] = iNums[i];\n        nums[0] = nums[n + 1] = 1;\n        int[][] dp = new int[n + 2][n + 2];\n        return DP(1, n, nums, dp);\n    }\n}",
        "tags": "7, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 386,
        "number": 315,
        "title": "Count of Smaller Numbers After Self",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nYou are given an integer array <i>nums</i> and you have to return a new <i>counts</i> array.\nThe <i>counts</i> array has the property where <code>counts[i]</code> is \nthe number of smaller elements to the right of <code>nums[i]</code>.\n</p>\n\n<p><b>Example:</b></p>\n\n<pre>Given <i>nums</i> = [5, 2, 6, 1]\n\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\nTo the right of 2 there is only <b>1</b> smaller element (1).\nTo the right of 6 there is <b>1</b> smaller element (1).\nTo the right of 1 there is <b>0</b> smaller element.\n</pre>\n\n<p>\nReturn the array <code>[2, 1, 1, 0]</code>.\n</p><p></p>\n      </div>",
        "solution": "public class Solution {\n    private void add(int[] bit, int i, int val) {\n        for (; i < bit.length; i += i&(-i)) bit[i] += val;\n    }\n\n    private int query(int[] bit, int i) {\n        int ans = 0;\n        for (; i > 0; i -= i&(-i)) ans += bit[i];\n        return ans;\n    }\n\n    public List<Integer> countSmaller(int[] nums) {\n        int[] tmp = nums.clone();\n        Arrays.sort(tmp);\n        int[] indexes = new int[nums.length];\n        for (int i = 0; i < indexes.length; i++)\n            indexes[i] = Arrays.binarySearch(tmp, nums[i]);\n        int[] bit = new int[indexes.length];\n        int[] ans = new int[indexes.length];\n        for (int i = indexes.length - 1; i >= 0; i--) {\n            ans[i] = query(bit, indexes[i]);\n            add(bit, indexes[i]+1, 1);\n        }\n        List<Integer> res = new ArrayList();\n        for(int n : ans)\n            res.add(n);\n        return res;\n    }\n}",
        "tags": "7, 26, 27, 28",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 387,
        "number": 316,
        "title": "Remove Duplicate Letters",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\nGiven a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n</p>\n\n<p>\n<b>Example:</b><br>\n</p>\n<p>\nGiven <code>\"bcabc\"</code><br>\nReturn <code>\"abc\"</code>\n</p>\n<p>\nGiven <code>\"cbacdcbc\"</code><br>\nReturn <code>\"acdb\"</code>\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public String removeDuplicateLetters(String s) {\n         //will contain number of occurences of character (i+'a')\n        int[] res = new int[26];\n        //will contain if character (i+'a') is present in current result Stack\n        boolean[] visited = new boolean[26]; \n        char[] ch = s.toCharArray();\n        for(char c : ch){  //count number of occurences of character \n            res[c-'a']++;\n        }\n        Stack<Character> st = new Stack<>(); // answer stack\n        int index;\n        for(char c : ch){ \n            index = c - 'a';\n            //decrement number of characters remaining in the string to be analysed\n            res[index]--;   \n            if(visited[index]) //if character is already present in stack, dont bother\n                continue;\n            //if current character is smaller than last character in stack which occurs later in the string again\n            //it can be removed and added later e.g stack = bc remaining string abc then a can pop b and then c\n            while(!st.isEmpty() && c < st.peek() && res[st.peek()-'a'] != 0){ \n                visited[st.pop()-'a']=false;\n            }\n            st.push(c); //add current character and mark it as visited\n            visited[index]=true;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        //pop character from stack and build answer string from back\n        while(!st.isEmpty()){\n            sb.insert(0,st.pop());\n        }\n        return sb.toString();\n    }\n}",
        "tags": "15, 17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 388,
        "number": 321,
        "title": "Create Maximum Number",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given two arrays of length <code>m</code> and <code>n</code> with digits <code>0-9</code> representing two numbers.\n    Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two. The relative order of the digits\n    from the same array must be preserved. Return an array of the <code>k</code> digits. You should try to optimize your time and space complexity.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n</p>\n<p>\n    nums1 = <code>[3, 4, 6, 5]</code><br>\n    nums2 = <code>[9, 1, 2, 5, 8, 3]</code><br>\n    k = <code>5</code><br>\n    return <code>[9, 8, 6, 5, 3]</code>\n</p>\n<p>\n    <b>Example 2:</b><br>\n</p>\n<p>\n    nums1 = <code>[6, 7]</code><br>\n    nums2 = <code>[6, 0, 4]</code><br>\n    k = <code>5</code><br>\n    return <code>[6, 7, 6, 0, 4]</code>\n</p>\n<p>\n    <b>Example 3:</b><br>\n</p>\n<p>\n    nums1 = <code>[3, 9]</code><br>\n    nums2 = <code>[8, 9]</code><br>\n    k = <code>3</code><br>\n    return <code>[9, 8, 9]</code>\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    // http://blog.csdn.net/u010025211/article/details/50527279\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int[] ans = new int[k];\n        for(int i = Math.max(0, k-nums2.length); i <= k && i <= nums1.length; ++i){\n            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k-i), k);\n            if(greater(candidate, 0, ans, 0))\n                ans = candidate;\n        }\n        return ans;\n    }\n    // Given one array of length n, create the maximum number of length k\n    public int[] maxArray(int[] nums,int k){\n        int[] ans = new int[k];\n        int j = 0;\n        for(int i = 0; i < nums.length; ++i){\n            while(nums.length-i+j > k && j > 0 && ans[j-1] < nums[i]) j--;\n            if(j < k)\n                ans[j++] = nums[i];\n        }\n        return ans;\n    }\n    //Given two array of length m and n, create maximum number of length k = m + n.\n    private int[] merge(int[] nums1, int[] nums2, int k){\n        int[] ans = new int[k];\n        int i = 0, j = 0, r = 0;\n        while(r < k)\n            ans[r++] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];\n        return ans;\n    }\n    // Compare nums1 with nums2 from index i and j\n    boolean greater(int[] nums1, int i, int[] nums2, int j){\n        while(i < nums1.length && j < nums2.length && nums1[i] == nums2[j]){\n            i++;\n            j++;\n        }\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n    }\n}",
        "tags": "9, 17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 389,
        "number": 327,
        "title": "Count of Range Sum",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given an integer array <code>nums</code>, return the number of range sums that lie in <code>[lower, upper]</code> inclusive.<br>\n\n    Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and \n    <code>j</code> (<code>i</code> ≤ <code>j</code>), inclusive.\n</p>\n\n<p>\n    <b>Note:</b><br>\n    A naive algorithm of <i>O</i>(<i>n</i><sup>2</sup>) is trivial. You MUST do better than that.\n</p>\n<p>\n    <b>Example:</b><br>\n    Given <i>nums</i> = <code>[-2, 5, -1]</code>, <i>lower</i> = <code>-2</code>, <i>upper</i> = <code>2</code>,<br>\n    Return <code>3</code>.<br>\n    The three ranges are : <code>[0, 0]</code>, <code>[2, 2]</code>, <code>[0, 2]</code> and their respective sums are: <code>-2, -1, 2</code>.\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        int n = nums.length;\n        long[] sums = new long[n + 1];\n        for (int i = 0; i < n; ++i)\n            sums[i + 1] = sums[i] + nums[i];\n        return countWhileMergeSort(sums, 0, n + 1, lower, upper);\n    }\n\n    private int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) {\n        if (end - start <= 1) return 0;\n        int mid = (start + end) / 2;\n        int count = countWhileMergeSort(sums, start, mid, lower, upper) \n              + countWhileMergeSort(sums, mid, end, lower, upper);\n        int j = mid, k = mid, t = mid;\n        long[] cache = new long[end - start];\n        for (int i = start, r = 0; i < mid; ++i, ++r) {\n            while (k < end && sums[k] - sums[i] < lower) k++;\n            while (j < end && sums[j] - sums[i] <= upper) j++;\n            while (t < end && sums[t] < sums[i]) cache[r++] = sums[t++];\n            cache[r] = sums[i];\n            count += j - k;\n        }\n        System.arraycopy(cache, 0, sums, start, t - start);\n        return count;\n    }\n}",
        "tags": "7, 28",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 390,
        "number": 329,
        "title": "Longest Increasing Path in a Matrix",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given an integer matrix, find the length of the longest increasing path.</p>\n\n<p>\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n\n<p>\n<b>Example 1:</b>\n</p><pre>nums = [\n  [<font color=\"red\">9</font>,9,4],\n  [<font color=\"red\">6</font>,6,8],\n  [<font color=\"red\">2</font>,<font color=\"red\">1</font>,1]\n]\n</pre>\n<p></p>\n\n<p>\nReturn <code>4</code><br>\n\nThe longest increasing path is <code>[1, 2, 6, 9]</code>.</p>\n\n<p>\n<b>Example 2:</b>\n</p><pre>nums = [\n  [<font color=\"red\">3</font>,<font color=\"red\">4</font>,<font color=\"red\">5</font>],\n  [3,2,<font color=\"red\">6</font>],\n  [2,2,1]\n]\n</pre>\n<p></p>\n\n<p>\nReturn <code>4</code><br>\n\nThe longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p>\n\n      </div>",
        "solution": "public class Solution {\n    private int dfs(int[][] matrix, int i, int j, int[][] cache) {\n        if(cache[i][j] > 0)\n            return cache[i][j];\n        int longest = 0;\n        if(i > 0 && matrix[i][j] < matrix[i-1][j]) \n            longest = Math.max(longest, dfs(matrix, i-1, j, cache));\n        if(j > 0 && matrix[i][j] < matrix[i][j-1])\n            longest = Math.max(longest, dfs(matrix, i, j-1, cache));\n        if(i < matrix.length-1 && matrix[i][j] < matrix[i+1][j])\n            longest = Math.max(longest, dfs(matrix, i+1, j, cache));\n        if(j < matrix[0].length-1 && matrix[i][j] < matrix[i][j+1])\n            longest = Math.max(longest, dfs(matrix, i, j+1, cache));\n        cache[i][j] = longest+1;\n        return longest+1;\n    }\n\n    public int longestIncreasingPath(int[][] matrix) {\n        if(matrix.length==0)\n            return 0;\n        int[][] cache = new int[matrix.length][matrix[0].length];\n        int longest = 0;\n        for(int i=0; i<matrix.length; i++)\n            for(int j=0; j<matrix[0].length; j++)\n                longest = Math.max(longest, dfs(matrix, i, j, cache));\n        return longest;\n    }\n}",
        "tags": "14, 24, 30",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 391,
        "number": 330,
        "title": "Patching Array",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a sorted positive integer array <i>nums</i> and an integer <i>n</i>, add/patch elements to the array such that any number in range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\n</p>\n\n<p><strong>Example 1:</strong><br>\n<i>nums</i> = <code>[1, 3]</code>, <i>n</i> = <code>6</code><br>\nReturn <code>1</code>.</p>\n\n<p>Combinations of <i>nums</i> are <code>[1], [3], [1,3]</code>, which form possible sums of: <code>1, 3, 4</code>.<br>\nNow if we add/patch <code>2</code> to <i>nums</i>, the combinations are: <code>[1], [2], [3], [1,3], [2,3], [1,2,3]</code>.<br>\nPossible sums are <code>1, 2, 3, 4, 5, 6</code>, which now covers the range <code>[1, 6]</code>.<br>\nSo we only need <code>1</code> patch.</p>\n\n<p><strong>Example 2:</strong><br>\n<i>nums</i> = <code>[1, 5, 10]</code>, <i>n</i> = <code>20</code><br>\nReturn <code>2</code>.<br>\nThe two patches can be <code>[2, 4]</code>.</p>\n\n<p><strong>Example 3:</strong><br>\n<i>nums</i> = <code>[1, 2, 2]</code>, <i>n</i> = <code>5</code><br>\nReturn <code>0</code>.<br>\n\n      </div>",
        "solution": "public class Solution {\n    public int minPatches(int[] nums, int n) {\n        long miss = 1;\n        int count = 0, i = 0;\n \n        while(miss <= n){\n            if(i < nums.length && nums[i] <= miss){\n                miss = miss + nums[i];\n                i++;\n            } else {\n                miss += miss;\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "tags": "17",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 392,
        "number": 335,
        "title": "Self Crossing",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    You are given an array <i>x</i> of <code>n</code> positive numbers. You start at point <code>(0,0)</code> and moves <code>x[0]</code> metres to the north, then <code>x[1]</code> metres to the west,\n    <code>x[2]</code> metres to the south,\n    <code>x[3]</code> metres to the east and so on. In other words, after each move your direction changes\n    counter-clockwise.\n</p>\n<p>\n    Write a one-pass algorithm with <code>O(1)</code> extra space to determine, if your path crosses itself, or not.\n</p>\n\n</div>",
        "solution": "public class Solution {\n    public boolean isSelfCrossing(int[] x) {\n        if (x.length <= 3) {\n            return false;\n        }\n        int i = 2;\n        // keep spiraling outward\n        while (i < x.length && x[i] > x[i - 2]) {\n            i++;\n        }\n        if (i >= x.length) {\n            return false;\n        }\n        // transition from spiraling outward to spiraling inward\n        if ((i >= 4 && x[i] >= x[i - 2] - x[i - 4]) ||\n                (i == 3 && x[i] == x[i - 2])) {\n            x[i - 1] -= x[i - 3];\n        }\n        i++;\n        // keep spiraling inward\n        while (i < x.length) {\n            if (x[i] >= x[i - 2]) {\n                return true;\n            }\n            i++;\n        }\n        return false;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 393,
        "number": 336,
        "title": "Palindrome Pairs",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>\n    Given a list of <b>unique</b> words, find all pairs of <b><i>distinct</i></b> indices <code>(i, j)</code> in the given list, so that the concatenation of the two words, i.e. <code>words[i] + words[j]</code> is a palindrome.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n    Given <code>words</code> = <code>[\"bat\", \"tab\", \"cat\"]</code><br>\n    Return <code>[[0, 1], [1, 0]]</code><br>\n    The palindromes are <code>[\"battab\", \"tabbat\"]</code><br>\n</p>\n<p>\n    <b>Example 2:</b><br>\n    Given <code>words</code> = <code>[\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]</code><br>\n    Return <code>[[0, 1], [1, 0], [3, 2], [2, 4]]</code><br>\n    The palindromes are <code>[\"dcbaabcd\", \"abcddcba\", \"slls\", \"llssssll\"]</code><br>\n</p>\n\n      </div>",
        "solution": "public class Solution {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        Map<String, Integer> map = new HashMap<String, Integer>();\n        for(int i = 0; i < words.length; i++)\n            map.put(words[i], i);\n    \n        for(int i = 0; i < words.length; i++){\n            String s = words[i];\n            //if the word is a palindrome, get index of \"\"\n            if(isPalindrome(s) && map.containsKey(\"\") && map.get(\"\") != i){\n                List<Integer> l = new ArrayList<Integer>();\n                l.add(i);\n                l.add(map.get(\"\"));\n                result.add(l);\n \n                l = new ArrayList<Integer>();\n                l.add(map.get(\"\"));\n                l.add(i);\n                result.add(l);\n            }\n \n            //if the reversed word exists, it is a palindrome\n            String reversed = new StringBuilder(s).reverse().toString();\n            if(map.containsKey(reversed) && map.get(reversed) != i){\n                List<Integer> l = new ArrayList<Integer>();\n                l.add(i);\n                l.add(map.get(reversed));\n                result.add(l);\n            }\n \n            for(int k = 1; k < s.length(); k++){\n                String left = s.substring(0, k);\n                String right= s.substring(k);\n \n                //if left part is palindrome, find reversed right part\n                if(isPalindrome(left)){\n                    String reversedRight = new StringBuilder(right).reverse().toString();\n                    if(map.containsKey(reversedRight) && map.get(reversedRight) != i){\n                        List<Integer> l = new ArrayList<Integer>();\n                        l.add(map.get(reversedRight));\n                        l.add(i);\n                        result.add(l);\n                    }\n                }\n \n                //if right part is a palindrome, find reversed left part\n                if(isPalindrome(right)){\n                    String reversedLeft = new StringBuilder(left).reverse().toString();\n                    if(map.containsKey(reversedLeft) && map.get(reversedLeft)!=i){\n                        List<Integer> l = new ArrayList<Integer>();\n                        l.add(i);\n                        l.add(map.get(reversedLeft));\n                        result.add(l);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    boolean isPalindrome(String s){\n        int i = 0, j = s.length()-1;\n        while(i < j){\n            if(s.charAt(i++) != s.charAt(j--))\n                return false;\n        }\n        return true;\n    }\n}",
        "tags": "1, 5, 11",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 394,
        "number": 352,
        "title": "Data Stream as Disjoint Intervals",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>Given a data stream input of non-negative integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, ..., summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:</p>\n<pre>[1, 1]\n[1, 1], [3, 3]\n[1, 1], [3, 3], [7, 7]\n[1, 3], [7, 7]\n[1, 3], [6, 7]\n</pre>\n\n<p><b>Follow up:</b><br>\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?\n</p>\n\n      </div>",
        "solution": "/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class SummaryRanges {\n    \n    TreeSet<Interval> intervalSet;\n\n    /** Initialize your data structure here. */\n    public SummaryRanges() {\n        intervalSet = new TreeSet<Interval>(new Comparator<Interval>(){\n            public int compare(Interval a, Interval b){\n                return a.start - b.start;\n            }\n        });\n    }\n    \n    public void addNum(int val) {\n        Interval valInterval = new Interval(val, val);\n        Interval floor = intervalSet.floor(valInterval);\n        if(floor != null){\n            if(floor.end >= val) return;\n            if(floor.end + 1 == val){\n                valInterval.start = floor.start;\n                intervalSet.remove(floor);\n            }\n        }\n        Interval higher = intervalSet.higher(valInterval);\n        if(higher != null && higher.start == val+1){\n            valInterval.end = higher.end;\n            intervalSet.remove(higher);\n        }\n        intervalSet.add(valInterval);\n    }\n    \n    public List<Interval> getIntervals() {\n        List<Interval> res = new ArrayList<Interval>();\n        res.addAll(intervalSet);\n        return res;\n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.addNum(val);\n * List<Interval> param_2 = obj.getIntervals();\n */",
        "tags": "29",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 395,
        "number": 354,
        "title": "Russian Doll Envelopes",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n        <p></p><p>You have a number of envelopes with widths and heights given as a pair of integers <code>(w, h)</code>. One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>\n\n<p>\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\n</p>\n\n<p><b>Example:</b><br>\nGiven envelopes = <code>[[5,4],[6,4],[6,7],[2,3]]</code>, the maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).\n</p><p></p>\n      </div>",
        "solution": "public class Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        if(envelopes == null || envelopes.length == 0 || envelopes[0] == null || envelopes[0].length != 2)\n            return 0;\n        Arrays.sort(envelopes, new Comparator<int[]>(){\n            public int compare(int[] arr1, int[] arr2){\n                if(arr1[0] == arr2[0])\n                    return arr2[1] - arr1[1];\n                else\n                    return arr1[0] - arr2[0];\n            } \n        });\n        int dp[] = new int[envelopes.length];\n        int len = 0;\n        for(int[] envelope : envelopes){\n            int index = Arrays.binarySearch(dp, 0, len, envelope[1]);\n            if(index < 0)\n                index = -(index + 1);\n            dp[index] = envelope[1];\n            if(index == len)\n                len++;\n        }\n        return len;\n    }\n}",
        "tags": "6, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 396,
        "number": 363,
        "title": "Max Sum of Rectangle No Larger Than K",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a non-empty 2D matrix <i>matrix</i> and an integer <i>k</i>, find the max sum of a rectangle in the <i>matrix</i> such that its sum is no larger than <i>k</i>.</p>\n\n    <p><b>Example:</b><br>\n    </p><pre>Given matrix = [\n  [1,  0, 1],\n  [0, -2, 3]\n]\nk = 2\n</pre>\n    <p></p>\n\n    <p>The answer is <code>2</code>. Because the sum of rectangle <code>[[0, 1], [-2, 3]]</code> is 2 and 2 is the max number no larger than k (k = 2).</p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The rectangle inside the matrix must have an area &gt; 0.</li>\n    <li>What if the number of rows is much larger than the number of columns?</li>\n</ol>\n\n</div>",
        "solution": "public class Solution {\n    /* first  consider the situation matrix is 1D\n     * we can save every sum of 0~i(0<=i<len) and binary search previous sum to\n     * find possible result for every index, time complexity is O(NlogN).\n     * so in 2D matrix, we can sum up all values from row i to row j and\n     * create a 1D array to use 1D array solution.\n     * If col number is less than row number, we can sum up all values\n     * from col i to col j then use 1D array solution.\n    */\n    public int maxSumSubmatrix(int[][] matrix, int target) {\n        int row = matrix.length;\n        if(row == 0)\n            return 0;\n        int col = matrix[0].length;\n        int m = Math.min(row,col);\n        int n = Math.max(row,col);\n        //indicating sum up in every row or every column\n        boolean colIsBig = col > row;\n        int res = Integer.MIN_VALUE;\n        for(int i = 0; i < m; i++){\n            int[] array = new int[n];\n            // sum from row j to row i\n            for(int j = i; j >= 0; j--){\n                int val = 0;\n                TreeSet<Integer> set = new TreeSet<>();\n                set.add(0);\n                //traverse every column/row and sum up\n                for(int k = 0; k < n; k++){\n                    array[k] += colIsBig ? matrix[j][k] : matrix[k][j];\n                    val += array[k];\n                    //use TreeMap to binary search previous sum to get possible result\n                    Integer subres = set.ceiling(val - target);\n                    if(null!=subres){\n                        res=Math.max(res,val-subres);\n                    }\n                    set.add(val);\n                }\n            }\n        }\n        return res;\n    }\n}",
        "tags": "6, 9, 25",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 397,
        "number": 391,
        "title": "Perfect Rectangle",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region.\n</p>\n\n    <p>\n        Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).\n    </p>\n\n    <div style=\"float:right\"><img src=\"https://leetcode.com/static/images/problemset/rectangle_perfect.gif\"></div>\n    <p><b>Example 1:</b>\n    </p><pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [3,2,4,4],\n  [1,3,2,4],\n  [2,3,3,4]\n]\n\nReturn true. All 5 rectangles together form an exact cover of a rectangular region.\n</pre>\n    <p></p>\n\n    <div style=\"clear:both\"></div>\n\n    <div style=\"float:right\"><img src=\"https://leetcode.com/static/images/problemset/rectangle_separated.gif\"></div>\n    <p><b>Example 2:</b>\n    </p><pre>rectangles = [\n  [1,1,2,3],\n  [1,3,2,4],\n  [3,1,4,2],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap between the two rectangular regions.\n</pre>\n    <p></p>\n\n    <div style=\"clear:both\"></div>\n\n    <div style=\"float:right\"><img src=\"https://leetcode.com/static/images/problemset/rectangle_hole.gif\"></div>\n    <p><b>Example 3:</b>\n    </p><pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap in the top center.\n</pre>\n    <p></p>\n\n    <div style=\"clear:both\"></div>\n\n    <div style=\"float:right\"><img src=\"https://leetcode.com/static/images/problemset/rectangle_intersect.gif\"></div>\n    <p><b>Example 4:</b>\n    </p><pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [2,2,4,4]\n]\n\nReturn false. Because two of the rectangles overlap with each other.\n</pre>\n    <p></p>\n\n    <div style=\"clear:both\"></div><p></p>\n</div>",
        "solution": "public class Solution {\n    // 1. the large rectangle area == the sum of small rectangles\n    // 2. count of all the points should be even, and\n    //      that of all the four corner points should be one\n    public boolean isRectangleCover(int[][] rectangles) {\n        if (rectangles.length == 0 || rectangles[0].length == 0)\n            return false;\n\n        int x1 = Integer.MAX_VALUE;\n        int x2 = Integer.MIN_VALUE;\n        int y1 = Integer.MAX_VALUE;\n        int y2 = Integer.MIN_VALUE;\n\n        Set<String> set = new HashSet<String>();\n        int area = 0;\n\n        for (int[] rect : rectangles) {\n            x1 = Math.min(rect[0], x1);\n            y1 = Math.min(rect[1], y1);\n            x2 = Math.max(rect[2], x2);\n            y2 = Math.max(rect[3], y2);\n\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n            String s1 = rect[0] + \" \" + rect[1];\n            String s2 = rect[0] + \" \" + rect[3];\n            String s3 = rect[2] + \" \" + rect[3];\n            String s4 = rect[2] + \" \" + rect[1];\n\n            if (!set.add(s1)) set.remove(s1);\n            if (!set.add(s2)) set.remove(s2);\n            if (!set.add(s3)) set.remove(s3);\n            if (!set.add(s4)) set.remove(s4);\n        }\n\n        if (!set.contains(x1 + \" \" + y1) || !set.contains(x1 + \" \" + y2) ||\n                !set.contains(x2 + \" \" + y1) || !set.contains(x2 + \" \" + y2) ||\n                set.size() != 4) return false;\n\n        return area == (x2-x1) * (y2-y1);\n    }\n}",
        "tags": "0",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 398,
        "number": 403,
        "title": "Frog Jump",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>\n\n    <p>Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\n    </p>\n\n    <p>If the frog's last jump was <i>k</i> units, then its next jump must be either <i>k</i> - 1, <i>k</i>, or <i>k</i> + 1 units. Note that the frog can only jump in the forward direction.</p>\n\n    <p><b>Note:</b>\n    </p><ul>\n    <li>The number of stones is ≥ 2 and is &lt; 1,100.</li>\n    <li>Each stone's position will be a non-negative integer &lt; 2<sup>31</sup>.</li>\n    <li>The first stone's position is always 0.</li>\n</ul>\n    <p></p>\n\n    <p><b>Example 1:</b>\n    </p><pre><b>[0,1,3,5,6,8,12,17]</b>\n\nThere are a total of 8 stones.\nThe first stone at the 0th unit, second stone at the 1st unit,\nthird stone at the 3rd unit, and so on...\nThe last stone at the 17th unit.\n\n<b>Return true</b>. The frog can jump to the last stone by jumping\n1 unit to the 2nd stone, then 2 units to the 3rd stone, then\n2 units to the 4th stone, then 3 units to the 6th stone,\n4 units to the 7th stone, and 5 units to the 8th stone.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b>\n    </p><pre><b>[0,1,2,3,4,8,9,11]</b>\n\n<b>Return false</b>. There is no way to jump to the last stone as\nthe gap between the 5th and 6th stone is too large.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public boolean canCross(int[] stones) {\n        if (stones.length == 0) {\n            return true;\n        }\n\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<Integer, HashSet<Integer>>(stones.length);\n        map.put(0, new HashSet<Integer>());\n        map.get(0).add(1);\n        for (int i = 1; i < stones.length; i++) {\n            map.put(stones[i], new HashSet<Integer>() );\n        }\n\n        for (int i = 0; i < stones.length - 1; i++) {\n            int stone = stones[i];\n            for (int step : map.get(stone)) {\n                int reach = step + stone;\n                if (reach == stones[stones.length - 1]) {\n                    return true;\n                }\n                HashSet<Integer> set = map.get(reach);\n                if (set != null) {\n                    set.add(step);\n                    if (step - 1 > 0) set.add(step - 1);\n                    set.add(step + 1);\n                }\n            }\n        }\n\n        return false;\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 399,
        "number": 407,
        "title": "Trapping Rain Water II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n</p>\n\n    <p><b>Note:</b><br>\n        Both <i>m</i> and <i>n</i> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\n    </p>\n\n    <p><b>Example:</b>\n    </p><pre>Given the following 3x6 height map:\n[\n  [1,4,3,1,3,2],\n  [3,2,1,3,2,4],\n  [2,3,3,2,3,1]\n]\n\nReturn 4.\n</pre>\n    <p></p>\n\n    <p>\n        <img src=\"https://leetcode.com/static/images/problemset/rainwater_empty.png\"><br>\n        The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.\n    </p>\n\n    <p>\n        <img src=\"https://leetcode.com/static/images/problemset/rainwater_fill.png\"><br>\n        After the rain, water are trapped between the blocks. The total volume of water trapped is 4.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n\n    public class Cell {\n        int row;\n        int col;\n        int height;\n        public Cell(int row, int col, int height) {\n            this.row = row;\n            this.col = col;\n            this.height = height;\n        }\n    }\n\n    public int trapRainWater(int[][] heights) {\n        if (heights == null || heights.length == 0 || heights[0].length == 0)\n            return 0;\n\n        PriorityQueue<Cell> queue = new PriorityQueue<>(1, new Comparator<Cell>(){\n            public int compare(Cell a, Cell b) {\n                return a.height - b.height;\n            }\n        });\n\n        int m = heights.length;\n        int n = heights[0].length;\n        boolean[][] visited = new boolean[m][n];\n\n        // Initially, add all the Cells which are on borders to the queue.\n        for (int i = 0; i < m; i++) {\n            visited[i][0] = true;\n            visited[i][n - 1] = true;\n            queue.offer(new Cell(i, 0, heights[i][0]));\n            queue.offer(new Cell(i, n - 1, heights[i][n - 1]));\n        }\n\n        for (int i = 0; i < n; i++) {\n            visited[0][i] = true;\n            visited[m - 1][i] = true;\n            queue.offer(new Cell(0, i, heights[0][i]));\n            queue.offer(new Cell(m - 1, i, heights[m - 1][i]));\n        }\n\n        // from the borders, pick the shortest cell visited and check its neighbors:\n        // if the neighbor is shorter, collect the water it can trap and\n        // update its height as its height plus the water trapped\n        // add all its neighbors to the queue.\n        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        int res = 0;\n        while (!queue.isEmpty()) {\n            Cell cell = queue.poll();\n            for (int[] dir : dirs) {\n                int row = cell.row + dir[0];\n                int col = cell.col + dir[1];\n                if (row >= 0 && row < m && col >= 0 && col < n && !visited[row][col]) {\n                    visited[row][col] = true;\n                    res += Math.max(0, cell.height - heights[row][col]);\n                    queue.offer(new Cell(row, col, Math.max(heights[row][col], cell.height)));\n                }\n            }\n        }\n\n        return res;\n    }\n}",
        "tags": "19, 20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 400,
        "number": 410,
        "title": "Split Array Largest Sum",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given an array which consists of non-negative integers and an integer <i>m</i>, you can split the array into <i>m</i> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <i>m</i> subarrays.\n</p>\n\n    <p><b>Note:</b><br>\n        If <i>n</i> is the length of array, assume the following constraints are satisfied:\n    </p><ul>\n    <li>1 ≤ <i>n</i> ≤ 1000</li>\n    <li>1 ≤ <i>m</i> ≤ min(50, <i>n</i>)</li>\n</ul>\n    <p></p>\n\n    <p><b>Examples: </b>\n    </p><pre>Input:\n<b>nums</b> = [7,2,5,10,8]\n<b>m</b> = 2\n\nOutput:\n18\n\nExplanation:\nThere are four ways to split <b>nums</b> into two subarrays.\nThe best way is to split it into <b>[7,2,5]</b> and <b>[10,8]</b>,\nwhere the largest sum among the two subarrays is only 18.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int splitArray(int[] nums, int m) {\n        int max = 0;\n        long sum = 0;\n        for (int num : nums) {\n            max = Math.max(num, max);\n            sum += num;\n        }\n        if (m == 1) return (int) sum;\n        //binary search\n        long l = max;\n        long r = sum;\n        while (l <= r) {\n            long mid = (l + r) / 2;\n            if (valid(mid, nums, m)) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return (int) l;\n    }\n\n    public boolean valid(long target, int[] nums, int m) {\n        int count = 1;\n        long total = 0;\n        for (int num : nums) {\n            total += num;\n            if (total > target) {\n                total = num;\n                count++;\n                if (count > m) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
        "tags": "6, 9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 401,
        "number": 420,
        "title": "Strong Password Checker",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>A password is considered strong if below conditions are all met:</p>\n\n    <ol>\n        <li> It has at least 6 characters and at most 20 characters. </li>\n        <li> It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. </li>\n        <li> It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met). </li>\n    </ol>\n\n    <p>Write a function strongPasswordChecker(s), that takes a string s as input, and return the <b>MINIMUM</b> change required to make s a strong password. If s is already strong, return 0.</p>\n\n    <p>Insertion, deletion or replace of any one character are all considered as one change.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int strongPasswordChecker(String s) {\n        int res = 0, a = 1, A = 1, d = 1;\n        char[] carr = s.toCharArray();\n        int[] arr = new int[carr.length];\n\n        for (int i = 0; i < arr.length; ) {\n            if (Character.isLowerCase(carr[i])) a = 0;\n            if (Character.isUpperCase(carr[i])) A = 0;\n            if (Character.isDigit(carr[i])) d = 0;\n\n            int j = i;\n            while (i < carr.length && carr[i] == carr[j]) i++;\n            arr[j] = i - j;\n        }\n\n        int total_missing = (a + A + d);\n\n        if (arr.length < 6) {\n            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));\n        } else {\n            int over_len = Math.max(arr.length - 20, 0), left_over = 0;\n            res += over_len;\n\n            for (int k = 1; k < 3; k++) {\n                for (int i = 0; i < arr.length && over_len > 0; i++) {\n                    if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;\n                    arr[i] -= Math.min(over_len, k);\n                    over_len -= k;\n                }\n            }\n\n            for (int i = 0; i < arr.length; i++) {\n                if (arr[i] >= 3 && over_len > 0) {\n                    int need = arr[i] - 2;\n                    arr[i] -= over_len;\n                    over_len -= need;\n                }\n                if (arr[i] >= 3)\n                    left_over += arr[i] / 3;\n            }\n            res += Math.max(total_missing, left_over);\n        }\n        return res;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 402,
        "number": 432,
        "title": "All O`one Data Structure",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Implement a data structure supporting the following operations:</p>\n\n    <p>\n    </p><ol>\n    <li>Inc(Key) - Inserts a new key <key> with value 1. Or increments an existing key by 1. Key is guaranteed to be a <b>non-empty</b> string.</key></li>\n    <li>Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a <b>non-empty</b> string.</li>\n    <li>GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string <code>\"\"</code>.</li>\n    <li>GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string <code>\"\"</code>.</li>\n</ol>\n    <p></p>\n\n    <p>\n        Challenge: Perform all these in O(1) time complexity.\n    </p><p></p>\n</div>",
        "solution": "public class AllOne {\n\n    // maintain a doubly linked list of Buckets\n    private Bucket head;\n    private Bucket tail;\n    // for accessing a specific Bucket among the Bucket list in O(1) time\n    private Map<Integer, Bucket> countBucketMap;\n    // keep track of count of keys\n    private Map<String, Integer> keyCountMap;\n\n    // each Bucket contains all the keys with the same count\n    private class Bucket {\n        int count;\n        Set<String> keySet;\n        Bucket next;\n        Bucket pre;\n\n        public Bucket(int cnt) {\n            count = cnt;\n            keySet = new HashSet<>();\n        }\n    }\n\n    /**\n     * Initialize your data structure here.\n     */\n    public AllOne() {\n        head = new Bucket(Integer.MIN_VALUE);\n        tail = new Bucket(Integer.MAX_VALUE);\n        head.next = tail;\n        tail.pre = head;\n        countBucketMap = new HashMap<>();\n        keyCountMap = new HashMap<>();\n    }\n\n    /**\n     * Inserts a new key <Key> with value 1. Or increments an existing key by 1.\n     */\n    public void inc(String key) {\n        if (keyCountMap.containsKey(key)) {\n            changeKey(key, 1);\n        } else {\n            keyCountMap.put(key, 1);\n            if (head.next.count != 1)\n                addBucketAfter(new Bucket(1), head);\n            head.next.keySet.add(key);\n            countBucketMap.put(1, head.next);\n        }\n    }\n\n    /**\n     * Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.\n     */\n    public void dec(String key) {\n        if (keyCountMap.containsKey(key)) {\n            int count = keyCountMap.get(key);\n            if (count == 1) {\n                keyCountMap.remove(key);\n                removeKeyFromBucket(countBucketMap.get(count), key);\n            } else {\n                changeKey(key, -1);\n            }\n        }\n    }\n\n    /**\n     * Returns one of the keys with maximal value.\n     */\n    public String getMaxKey() {\n        return tail.pre == head ? \"\" : (String) tail.pre.keySet.iterator().next();\n    }\n\n    /**\n     * Returns one of the keys with Minimal value.\n     */\n    public String getMinKey() {\n        return head.next == tail ? \"\" : (String) head.next.keySet.iterator().next();\n    }\n\n    // helper function to make change on given key according to offset\n    private void changeKey(String key, int offset) {\n        int count = keyCountMap.get(key);\n        keyCountMap.put(key, count + offset);\n        Bucket curBucket = countBucketMap.get(count);\n        Bucket newBucket;\n        if (countBucketMap.containsKey(count + offset)) {\n            // target Bucket already exists\n            newBucket = countBucketMap.get(count + offset);\n        } else {\n            // add new Bucket\n            newBucket = new Bucket(count + offset);\n            countBucketMap.put(count + offset, newBucket);\n            addBucketAfter(newBucket, offset == 1 ? curBucket : curBucket.pre);\n        }\n        newBucket.keySet.add(key);\n        removeKeyFromBucket(curBucket, key);\n    }\n\n    private void removeKeyFromBucket(Bucket bucket, String key) {\n        bucket.keySet.remove(key);\n        if (bucket.keySet.size() == 0) {\n            removeBucketFromList(bucket);\n            countBucketMap.remove(bucket.count);\n        }\n    }\n\n    private void removeBucketFromList(Bucket bucket) {\n        bucket.pre.next = bucket.next;\n        bucket.next.pre = bucket.pre;\n        bucket.next = null;\n        bucket.pre = null;\n    }\n\n    // add newBucket after preBucket\n    private void addBucketAfter(Bucket newBucket, Bucket preBucket) {\n        newBucket.pre = preBucket;\n        newBucket.next = preBucket.next;\n        preBucket.next.pre = newBucket;\n        preBucket.next = newBucket;\n    }\n}\n\n/**\n * Your AllOne object will be instantiated and called as such:\n * AllOne obj = new AllOne();\n * obj.inc(key);\n * obj.dec(key);\n * String param_3 = obj.getMaxKey();\n * String param_4 = obj.getMinKey();\n */",
        "tags": "10",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 403,
        "number": 440,
        "title": "K-th Smallest in Lexicographical Order",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given integers <code>n</code> and <code>k</code>, find the lexicographically k-th smallest integer in the range from <code>1</code> to <code>n</code>.</p>\n\n    <p>Note: 1 ≤ k ≤ n ≤ 10<sup>9</sup>.</p>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b>\nn: 13   k: 2\n\n<b>Output:</b>\n10\n\n<b>Explanation:</b>\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findKthNumber(int n, int k) {\n        int curr = 1;\n        k = k - 1;\n        while (k > 0) {\n            int steps = calSteps(n, curr, curr + 1);\n            if (steps <= k) {\n                curr += 1;\n                k -= steps;\n            } else {\n                curr *= 10;\n                k -= 1;\n            }\n        }\n        return curr;\n    }\n\n    //use long in case of overflow\n    public int calSteps(int n, long n1, long n2) {\n        int steps = 0;\n        while (n1 <= n) {\n            steps += Math.min(n + 1, n2) - n1;\n            n1 *= 10;\n            n2 *= 10;\n        }\n        return steps;\n    }\n}",
        "tags": "3",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 404,
        "number": 446,
        "title": "Arithmetic Slices II - Subsequence",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>\n\n    <p>For example, these are arithmetic sequences:</p>\n    <pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n    <p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre>\n    <br>\n\n    <p>A zero-indexed array A consisting of N numbers is given. A <b>subsequence</b> slice of that array is any sequence of integers (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) such that 0 ≤ P<sub>0</sub> &lt; P<sub>1</sub> &lt; ... &lt; P<sub>k</sub> &lt; N.</p>\n\n    <p>A <b>subsequence</b> slice (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) of array A is called arithmetic if the sequence A[P<sub>0</sub>], A[P<sub>1</sub>], ..., A[P<sub>k-1</sub>], A[P<sub>k</sub>] is arithmetic. In particular, this means that k ≥ 2.</p>\n\n    <p>The function should return the number of arithmetic subsequence slices in the array A. </p>\n\n    <p>The input contains N integers. Every integer is in the range of -2<sup>31</sup> and 2<sup>31</sup>-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 2<sup>31</sup>-1.</p>\n    <br>\n\n    <p><b>Example:</b>\n    </p><pre><b>Input:</b> [2, 4, 6, 8, 10]\n\n<b>Output:</b> 7\n\n<b>Explanation:</b>\nAll arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int re = 0;\n        HashMap<Integer, Integer>[] maps = new HashMap[A.length];\n        for (int i = 0; i < A.length; i++) {\n            maps[i] = new HashMap<>();\n            int num = A[i];\n            for (int j = 0; j < i; j++) {\n                if ((long) num - A[j] > Integer.MAX_VALUE) continue;\n                if ((long) num - A[j] < Integer.MIN_VALUE) continue;\n                int diff = num - A[j];\n                int count = maps[j].getOrDefault(diff, 0);\n                maps[i].put(diff, maps[i].getOrDefault(diff, 0) + count + 1);\n                re += count;\n            }\n        }\n        return re;\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 405,
        "number": 460,
        "title": "LFU Cache",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Design and implement a data structure for <a href=\"https://en.wikipedia.org/wiki/Least_frequently_used\" target=\"_blank\">Least Frequently Used (LFU)</a> cache. It should support the following operations: <code>get</code> and <code>put</code>.\n</p>\n\n    <p>\n        <code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\n        <code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least <b>recently</b> used key would be evicted.\n    </p>\n\n    <p><b>Follow up:</b><br>\n        Could you do both operations in <b>O(1)</b> time complexity?</p>\n\n    <p><b>Example:</b>\n    </p><pre>LFUCache cache = new LFUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.get(3);       // returns 3.\ncache.put(4, 4);    // evicts key 1.\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class LFUCache {\n\n    HashMap<Integer, Integer> vals; // key to val\n    HashMap<Integer, Integer> counts; // key to count\n    // count to list of keys\n    HashMap<Integer, LinkedHashSet<Integer>> lists;\n    int cap; // capacity of the cache\n    int min = -1; // track the min value\n\n    public LFUCache(int capacity) {\n        cap = capacity;\n        vals = new HashMap<>();\n        counts = new HashMap<>();\n        lists = new HashMap<>();\n        lists.put(1, new LinkedHashSet<>());\n    }\n\n    public int get(int key) {\n        // Can't find val for the key\n        if (!vals.containsKey(key))\n            return -1;\n        // Update count of a key in count to key map\n        int count = counts.get(key);\n        counts.put(key, count + 1);\n        lists.get(count).remove(key);\n        // If least frequent key is removed\n        if (count == min && lists.get(count).size() == 0)\n            min++;\n        // Update key to list map\n        if (!lists.containsKey(count + 1))\n            lists.put(count + 1, new LinkedHashSet<>());\n        lists.get(count + 1).add(key);\n        return vals.get(key);\n    }\n\n    public void put(int key, int value) {\n        if (cap <= 0) return;\n        // Update key to val map\n        if (vals.containsKey(key)) {\n            vals.put(key, value);\n            get(key);\n            return;\n        }\n        // If is full remove the min\n        // remove from lists and vals map\n        if (vals.size() >= cap) {\n            int evit = lists.get(min).iterator().next();\n            lists.get(min).remove(evit);\n            vals.remove(evit);\n        }\n        // Not in cache\n        vals.put(key, value);\n        counts.put(key, 1);\n        min = 1;\n        lists.get(1).add(key);\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */",
        "tags": "10",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 406,
        "number": 466,
        "title": "Count The Repetitions",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Define <code>S = [s,n]</code> as the string S which consists of n connected strings s. For example, <code>[\"abc\", 3]</code> =\"abcabcabc\". </p>\n    <p>On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.</p>\n    <p>You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 10<sup>6</sup> and 1 ≤ n2 ≤ 10<sup>6</sup>. Now consider the strings S1 and S2, where <code>S1=[s1,n1]</code> and <code>S2=[s2,n2]</code>. Find the maximum integer M such that <code>[S2,M]</code> can be obtained from <code>S1</code>.</p>\n\n    <p><b>Example:</b>\n    </p><pre>Input:\ns1=\"acb\", n1=4\ns2=\"ab\", n2=2\n\nReturn:\n2\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n        // check if [s1. ∞] obtains s2\n        if (!ableToObtain(s1, s2))\n            return 0;\n        int cnt = 0, k = -1;\n        String s = s1;\n        // record 'remain string'\n        StringBuilder remainBuilder;\n        // record all the 'remain string'\n        List<String> stringList = new ArrayList<>();\n        // record matching count from start to the current remain string\n        List<Integer> countList = new ArrayList<>();\n        stringList.add(\"\"); // record empty string\n        countList.add(0);\n        for (int i = 0; i <= n1; i++) {\n            remainBuilder = new StringBuilder();\n            // get the next remain string, returns the count of matching\n            cnt += getRemain(s, s2, remainBuilder);\n            String remain = remainBuilder.toString();\n            // if there is a loop, break\n            if ((k = stringList.indexOf(remain)) != -1)\n                break;\n            stringList.add(remain); // record the remain string into arraylist\n            countList.add(cnt);\n            s = remain + s1; // append s1 to make a new string\n        }\n        // here, k is the beginning of the loop\n        if (k == -1)\n            return cnt / n2; // if there is no loop\n        // get matching count in the loop, and loop length\n        int countOfLoop = cnt - countList.get(k);\n        int loopLength = stringList.size() - k;\n        cnt = countList.get(k) + countOfLoop * ((n1 - k) / loopLength);\n        n1 = (n1 - k) % loopLength;\n        cnt += countList.get(k + n1) - countList.get(k);\n        return cnt / n2;\n    }\n\n    private boolean ableToObtain(String s1, String s2) {\n        boolean[] cnt = new boolean[26];\n        for (char c : s1.toCharArray())\n            cnt[c - 'a'] = true;\n        for (char c : s2.toCharArray()) {\n            if (!cnt[c - 'a'])\n                return false;\n        }\n        return true;\n    }\n\n    private int getRemain(String s1, String s2, StringBuilder remain) {\n        int cnt = 0, lastMatch = -1, p2 = 0;\n        for (int p1 = 0; p1 < s1.length(); p1++) {\n            if (s1.charAt(p1) != s2.charAt(p2)) continue;\n            if (++p2 == s2.length()) {\n                p2 = 0;\n                cnt++;\n                lastMatch = p1;\n            }\n        }\n        remain.append(s1.substring(lastMatch + 1));\n        return cnt;\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 407,
        "number": 467,
        "title": "Unique Substrings in Wraparound String",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Consider the string <code>s</code> to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so <code>s</code> will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".</p>\n\n    <p>Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.</p>\n\n    <p><b>Note:</b> <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> \"a\"\n<b>Output:</b> 1\n\n<b>Explanation:</b> Only the substring \"a\" of string \"a\" is in the string \u0010s.\n</pre>\n    <p></p>\n\n    <p><b>Example 2:</b><br>\n    </p><pre><b>Input:</b> \"cac\"\n<b>Output:</b> 2\n<b>Explanation:</b> There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\n</pre>\n    <p></p>\n\n    <p><b>Example 3:</b><br>\n    </p><pre><b>Input:</b> \"zab\"\n<b>Output:</b> 6\n<b>Explanation:</b> There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.\n</pre>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int findSubstringInWraproundString(String p) {\n        // count[i] is the maximum unique substring end with ith letter.\n        // 0 - 'a', 1 - 'b', ..., 25 - 'z'.\n        int[] count = new int[26];\n\n        // store longest contiguous substring ends at current position.\n        int maxLengthCur = 0;\n\n        for (int i = 0; i < p.length(); i++) {\n            if (i > 0 && (p.charAt(i) - p.charAt(i - 1) == 1 || (p.charAt(i - 1) - p.charAt(i) == 25))) {\n                maxLengthCur++;\n            }\n            else {\n                maxLengthCur = 1;\n            }\n\n            int index = p.charAt(i) - 'a';\n            count[index] = Math.max(count[index], maxLengthCur);\n        }\n\n        // Sum to get result\n        int sum = 0;\n        for (int i = 0; i < 26; i++) {\n            sum += count[i];\n        }\n        return sum;\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 408,
        "number": 472,
        "title": "Concatenated Words",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p>Given a list of words (<b>without duplicates</b>), please write a program that returns all concatenated words in the given list of words.\n    </p><p>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>\n\n    <p><b>Example:</b><br>\n    </p><pre><b>Input:</b> [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n\n<b>Output:</b> [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n\n<b>Explanation:</b> \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; <br> \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; <br>\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n</pre>\n    <p></p>\n\n    <p><b>Note:</b><br>\n    </p><ol>\n    <li>The number of elements of the given array will not exceed <code>10,000 </code>\n    </li><li>The length sum of elements in the given array will not exceed <code>600,000</code>. </li>\n    <li>All the input string will only include lower case letters.</li>\n    <li>The returned elements order does not matter. </li>\n</ol>\n    <p></p><p></p>\n</div>",
        "solution": "public class Solution {\n\n    class TrieNode {\n        TrieNode[] sons;\n        boolean isEnd;\n        public TrieNode() {\n            sons = new TrieNode[26];\n        }\n    }\n\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        List<String> res = new ArrayList<String>();\n        if (words == null || words.length == 0) {\n            return res;\n        }\n        TrieNode root = new TrieNode();\n        for (String word : words) { // construct Trie tree\n            if (word.length() == 0) {\n                continue;\n            }\n            addWord(word, root);\n        }\n        for (String word : words) { // test word is a concatenated word or not\n            if (word.length() == 0) {\n                continue;\n            }\n            if (testWord(word.toCharArray(), 0, root, 0)) {\n                res.add(word);\n            }\n        }\n        return res;\n    }\n\n    // count means how many words during the search path\n    private boolean testWord(char[] chars, int index, TrieNode root, int count) {\n        TrieNode cur = root;\n        int n = chars.length;\n        for (int i = index; i < n; i++) {\n            if (cur.sons[chars[i] - 'a'] == null) {\n                return false;\n            }\n            if (cur.sons[chars[i] - 'a'].isEnd) {\n                if (i == n - 1) { // no next word, so test count to get result.\n                    return count >= 1;\n                }\n                if (testWord(chars, i + 1, root, count + 1)) {\n                    return true;\n                }\n            }\n            cur = cur.sons[chars[i] - 'a'];\n        }\n        return false;\n    }\n\n    private void addWord(String str, TrieNode root) {\n        char[] chars = str.toCharArray();\n        TrieNode cur = root;\n        for (char c : chars) {\n            if (cur.sons[c - 'a'] == null) {\n                cur.sons[c - 'a'] = new TrieNode();\n            }\n            cur = cur.sons[c - 'a'];\n        }\n        cur.isEnd = true;\n    }\n}",
        "tags": "9, 11, 14",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 409,
        "number": 480,
        "title": "Sliding Window Median",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>\n    Examples: <br>\n    <p><code>[2,3,4]</code> , the median is <code>3</code></p>\n    <p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code> </p>\n\n    <p>Given an array <i>nums</i>, there is a sliding window of size <i>k</i> which is moving from the very left of the array to the very right. You can only see the <i>k</i> numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>\n\n    <p>For example,<br>\n        Given <i>nums</i> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <i>k</i> = 3.</p>\n\n    <pre>Window position                Median\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n</pre>\n\n    <p>Therefore, return the median sliding window as <code>[1,-1,-1,3,5,6]</code>.</p>\n\n    <p><b>Note: </b><br>\n        You may assume <i>k</i> is always valid, ie: 1 ? k ? input array's size for non-empty array.</p><p></p>\n</div>",
        "solution": "public class Solution {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(\n            new Comparator<Integer>() {\n                public int compare(Integer i1, Integer i2) {\n                    return i2.compareTo(i1);\n                }\n            }\n    );\n\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        int n = nums.length - k + 1;\n        if (n <= 0) return new double[0];\n        double[] result = new double[n];\n\n        for (int i = 0; i <= nums.length; i++) {\n            if (i >= k) {\n                result[i - k] = getMedian();\n                remove(nums[i - k]);\n            }\n            if (i < nums.length) {\n                add(nums[i]);\n            }\n        }\n        return result;\n    }\n\n    private void add(int num) {\n        if (num < getMedian()) {\n            maxHeap.add(num);\n        } else {\n            minHeap.add(num);\n        }\n        if (maxHeap.size() > minHeap.size()) {\n            minHeap.add(maxHeap.poll());\n        }\n        if (minHeap.size() - maxHeap.size() > 1) {\n            maxHeap.add(minHeap.poll());\n        }\n    }\n\n    private void remove(int num) {\n        if (num < getMedian()) {\n            maxHeap.remove(num);\n        } else {\n            minHeap.remove(num);\n        }\n        if (maxHeap.size() > minHeap.size()) {\n            minHeap.add(maxHeap.poll());\n        }\n        if (minHeap.size() - maxHeap.size() > 1) {\n            maxHeap.add(minHeap.poll());\n        }\n    }\n\n    private double getMedian() {\n        if (maxHeap.isEmpty() && minHeap.isEmpty()) return 0;\n\n        if (maxHeap.size() == minHeap.size())\n            return ((double) maxHeap.peek() + (double) minHeap.peek()) / 2.0;\n        return (double) minHeap.peek();\n    }\n}",
        "tags": "20",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 410,
        "number": 552,
        "title": "Student Attendance Record II",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>Given a positive integer <b>n</b>, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 10<sup>9</sup> + 7.</p>\n\n    <p>A student attendance record is a string that only contains the following three characters:</p>\n\n    <p>\n    </p><ol>\n    <li><b>'A'</b> : Absent. </li>\n    <li><b>'L'</b> : Late.</li>\n    <li> <b>'P'</b> : Present. </li>\n</ol>\n    <p></p>\n\n    <p>\n        A record is regarded as rewardable if it doesn't contain <b>more than one 'A' (absent)</b> or <b>more than two continuous 'L' (late)</b>.</p>\n\n    <p><b>Example 1:</b><br>\n    </p><pre><b>Input:</b> n = 2\n<b>Output:</b> 8\n<b>Explanation:</b>\nThere are 8 records with length 2 will be regarded as rewardable:\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\"\nOnly \"AA\" won't be regarded as rewardable owing to more than one absent times.\n</pre>\n    <p></p>\n\n    <p><b>Note:</b>\n        The value of <b>n</b> won't exceed 100,000.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    static final int M = 1000000007;\n    public int checkRecord(int n) {\n        // ending with P or L, no A\n        long[] PorL = new long[n + 1];\n        // ending with P, no A\n        long[] P = new long[n + 1];\n        PorL[0] = P[0] = 1; PorL[1] = 2; P[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n            P[i] = PorL[i - 1];\n            PorL[i] = (P[i] + P[i - 1] + P[i - 2]) % M;\n        }\n\n        long res = PorL[n];\n        // inserting A into (n-1)-length strings\n        for (int i = 0; i < n; i++) {\n    \t    long s = (PorL[i] * PorL[n - i - 1]) % M;\n            res = (res + s) % M;\n        }\n        return (int) res;\n    }\n}",
        "tags": "9",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 411,
        "number": 588,
        "title": "Design In-Memory File System",
        "difficulty": "Hard",
        "description": "<div class=\"block-markdown question\">\n    <h2>Question</h2>\n    <blockquote><p>Design an in-memory file system to simulate the following functions:</p>\n\n        <p><code>ls</code>: Given a path in string format. If it is a file path, return a list that only contains this file's name. If it is a directory path, return the list of file and directory names <b>in this directory</b>. Your output (file and directory names together) should in <b>lexicographic order</b>.</p>\n\n        <p><code>mkdir</code>: Given a <b>directory path</b> that does not exist, you should make a new directory according to the path. If the middle directories in the path don't exist either, you should create them as well. This function has void return type. </p>\n\n        <p><code>addContentToFile</code>: Given a <b>file path</b> and <b>file content</b> in string format. If the file doesn't exist, you need to create that file containing given content. If the file already exists, you need to <b>append</b> given content to original content. This function has void return type.</p>\n\n        <p><code>readContentFromFile</code>: Given a <b>file path</b>, return its <b>content</b> in string format.</p>\n\n        <p><b>Example:</b><br>\n        </p><pre><b>Input:</b>\n[\"FileSystem\",\"ls\",\"mkdir\",\"addContentToFile\",\"ls\",\"readContentFromFile\"]\n[[],[\"/\"],[\"/a/b/c\"],[\"/a/b/c/d\",\"hello\"],[\"/\"],[\"/a/b/c/d\"]]\n<b>Output:</b>\n[null,[],null,null,[\"a\"],\"hello\"]\n<b>Explanation:</b>\n<img src=\"https://leetcode.com/static/images/problemset/filesystem.png\" width=\"66%\" alt=\"filesystem\">\n</pre>\n        <p></p>\n\n        <p><b>Note:</b><br>\n        </p><ol>\n            <li>You can assume all file or directory paths are absolute paths which begin with <code>/</code> and do not end with <code>/</code> except that the path is just <code>\"/\"</code>.</li>\n            <li>You can assume that all operations will be passed valid parameters and users will not attempt to retrieve file content or list a directory or file that does not exist.</li>\n            <li>You can assume that all directory names and file names only contain lower-case letters, and same names won't exist in the same directory.</li>\n        </ol>\n        <p></p></blockquote>\n</div>",
        "solution": "public class FileSystem {\n    class Dir {\n        HashMap<String, Dir> dirs = new HashMap<>();\n        HashMap<String, String> files = new HashMap<>();\n    }\n\n    Dir root;\n\n    public FileSystem() {\n        root = new Dir();\n    }\n\n    // Time complexity is O(m + n + klog(k))\n    public List<String> ls(String path) {\n        Dir t = root;\n        List<String> files = new ArrayList<>();\n        if (!path.equals(\"/\")) {\n            String[] d = path.split(\"/\");\n            for (int i = 1; i < d.length - 1; i++) {\n                t = t.dirs.get(d[i]);\n            }\n            if (t.files.containsKey(d[d.length - 1])) {\n                files.add(d[d.length - 1]);\n                return files;\n            } else {\n                t = t.dirs.get(d[d.length - 1]);\n            }\n        }\n        files.addAll(new ArrayList<>(t.dirs.keySet()));\n        files.addAll(new ArrayList<>(t.files.keySet()));\n        Collections.sort(files);\n        return files;\n    }\n\n    // Time complexity is O(m + n)\n    public void mkdir(String path) {\n        Dir t = root;\n        String[] d = path.split(\"/\");\n        for (int i = 1; i < d.length; i++) {\n            if (!t.dirs.containsKey(d[i]))\n                t.dirs.put(d[i], new Dir());\n            t = t.dirs.get(d[i]);\n        }\n    }\n\n    // Time complexity is O(m + n)\n    public void addContentToFile(String filePath, String content) {\n        Dir t = root;\n        String[] d = filePath.split(\"/\");\n        for (int i = 1; i < d.length - 1; i++) {\n            t = t.dirs.get(d[i]);\n        }\n        t.files.put(d[d.length - 1], t.files.getOrDefault(d[d.length - 1], \"\") + content);\n    }\n\n    // Time complexity is O(m + n)\n    public String readContentFromFile(String filePath) {\n        Dir t = root;\n        String[] d = filePath.split(\"/\");\n        for (int i = 1; i < d.length - 1; i++) {\n            t = t.dirs.get(d[i]);\n        }\n        return t.files.get(d[d.length - 1]);\n    }\n}\n\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * List<String> param_1 = obj.ls(path);\n * obj.mkdir(path);\n * obj.addContentToFile(filePath,content);\n * String param_4 = obj.readContentFromFile(filePath);\n */",
        "tags": "10",
        "companies": "",
        "specialtags": ""
    },
    {
        "id": 412,
        "number": 10001,
        "title": "Remove Duplicate Characters",
        "difficulty": "Easy",
        "description": "<div class=\"question-content\">\n    <p></p>\n    <p>Remove duplicate characters in a string if char appear more than once\n    </p>\n\n    <p>\n        <b>Example:</b><br>\n    </p>\n    <pre>Given \"abcba\", return <b>c</b>.</pre>\n    <p></p>\n    <p></p>\n</div>",
        "solution": "public class Solution {\n    /***\n     * for each element in input\n     *      put count and char into map\n     * for each element in input\n     *      if count == 1\n     *          add to res\n     *\n     * @param input\n     * @return\n     */\n    public String remove(String input) {\n        Map<Character, Integer> charToCount = new HashMap<>();\n        StringBuilder res = new StringBuilder();\n\n        for(int i = 0; i < input.length(); i++){\n            char c = input.charAt(i);\n            if(charToCount.containsKey(c)){\n                charToCount.put(c, charToCount.get(c) + 1);\n            } else {\n                charToCount.put(c, 1);\n            }\n        }\n\n        for(int i = 0; i < input.length(); i++){\n            char c = input.charAt(i);\n            if(charToCount.get(c) == 1)\n                res.append(c);\n        }\n        return res.toString();\n    }\n}",
        "tags": "1",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 413,
        "number": 10002,
        "title": "Find Kth Nearest Point",
        "difficulty": "Medium",
        "description": "<section>\n    <h1>Nearest Kth</h1>\n    <p>Use quickSelect to find the kth nearest point to the origin point\n        <br>\n        'Time complexity: average O(n), worst O(n^2) when always pick the most\n        right one -- the time complexity of quick select'</p>\n    <p>Use max Heap\n        maintain a max heap with size K,\n        every time meet a new point, check if its distance is\n        smaller than the heap.peek()\n        if yes, pop out the peek, push this point into heap\n        in the end we will have K points which are the nearest points\n        <br>\n        'Time complexity: O(nlgk), space complexity:O(k)'</p>\n</section>\n",
        "solution": "package facebook.phone.AprilJune.NearestKth;\n\nimport java.util.Random;\n\npublic class Solution {\n\n    public Point findNearestKthPoint(Point[] points, int k){\n        if(k > points.length || k == 0){\n            throw new IllegalArgumentException(\"K's value is invaild.\\n\");\n        }\n        return quickSelect(points, 0, points.length - 1, k - 1);\n    }\n\n    private Point quickSelect(Point[] points, int left, int right, int k) {\n        Random rand = new Random();\n        int pivotIndex = 0;\n        if(right != 0){\n            pivotIndex = rand.nextInt(right) % (right -left + 1) + left;\n        }\n        pivotIndex = partition(pivotIndex, points, left, right);\n        if (pivotIndex == k) {\n            return points[k];\n        } else if (pivotIndex > k) {\n            return quickSelect(points, left, pivotIndex - 1, k);\n        } else {\n            return quickSelect(points, pivotIndex + 1, right, k);\n        }\n    }\n\n    private int partition(int pivotIndex, Point[] points, int left, int right) {\n        int i = left;\n        int j = right;\n        Point temp = points[pivotIndex];\n        int tempDistance = distance(temp);\n        swap(points, left, pivotIndex);\n        while (i < j) {\n            while (j > i && distance(points[j]) >= tempDistance) {\n                j--;\n            }\n            points[i] = points[j];\n            while (j > i && distance(points[i]) <= tempDistance) {\n                i++;\n            }\n            points[j] = points[i];\n        }\n        points[i] = temp;\n        return i;\n    }\n\n    private void swap(Point[] points, int left, int pivotIndex) {\n        Point temp = points[left];\n        points[left] = points[pivotIndex];\n        points[pivotIndex] = temp;\n    }\n\n    private int distance(Point point) {\n        return point.x * point.x + point.y * point.y;\n    }\n\n}\n",
        "tags": "13",
        "companies": "0",
        "specialtags": "0"
    },
    {
        "id": 414,
        "number": 10004,
        "title": "Even Tree",
        "difficulty": "Medium",
        "description": "<div class=\"content-text challenge-text mlB\">\n    <div class=\"challenge_problem_statement\"><div class=\"msB challenge_problem_statement_body\"><div class=\"hackdown-content\"><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n.MathJax_SVG_LineBox {display: table!important}\n.MathJax_SVG_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>You are given a tree (a simple connected graph with no cycles). The tree has <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-1-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.064ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 888.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g></svg></span> nodes numbered from <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-2-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"1.162ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 500.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g></svg></span> to <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-3-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.064ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 888.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g></svg></span> and is rooted at node <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-4-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"1.162ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 500.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g></svg></span>. </p>\n\n        <p>Find the maximum number of edges you can remove from the tree to get a <a href=\"https://www.hackerrank.com/external_redirect?to=http://en.wikipedia.org/wiki/Tree_%28graph_theory%29\" target=\"_blank\">forest</a> such that each connected component of the forest contains an even number of nodes.</p></div></div></div><div class=\"challenge_input_format\"><div class=\"msB challenge_input_format_title\"><p><strong>Input Format</strong></p></div><div class=\"msB challenge_input_format_body\"><div class=\"hackdown-content\"><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n.MathJax_SVG_LineBox {display: table!important}\n.MathJax_SVG_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>The first line of input contains two integers <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-1-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.064ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 888.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g></svg></span> and <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-2-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.442ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 1051.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z\"></path></g></svg></span>. <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-3-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.064ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 888.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g></svg></span> is the number of nodes, and <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-4-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.442ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 1051.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z\"></path></g></svg></span> is the number of edges. <br>\n    The next <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-5-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.442ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 1051.5 936.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z\"></path></g></svg></span> lines contain two integers <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-6-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.129ex\" height=\"2.009ex\" style=\"vertical-align: -0.671ex;\" viewBox=\"0 -576.1 916.8 865.1\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path><g transform=\"translate(572,-150)\"><path stroke-width=\"1\" transform=\"scale(0.707)\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g></svg></span> and <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-7-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"1.927ex\" height=\"2.009ex\" style=\"vertical-align: -0.671ex;\" viewBox=\"0 -576.1 829.8 865.1\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z\"></path><g transform=\"translate(485,-150)\"><path stroke-width=\"1\" transform=\"scale(0.707)\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g></svg></span> which specifies an edge of the tree. </p></div></div></div><div class=\"challenge_constraints\"><div class=\"msB challenge_constraints_title\"><p><strong>Constraints</strong></p></div><div class=\"msB challenge_constraints_body\"><div class=\"hackdown-content\"><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><ul>\n    <li><span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-1-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"12.91ex\" height=\"2.343ex\" style=\"vertical-align: -0.505ex;\" viewBox=\"0 -791.3 5558.6 1008.6\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path><g transform=\"translate(778,0)\"><path stroke-width=\"1\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g><g transform=\"translate(1834,0)\"><path stroke-width=\"1\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g><g transform=\"translate(3000,0)\"><path stroke-width=\"1\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g><g transform=\"translate(4057,0)\"><path stroke-width=\"1\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path><path stroke-width=\"1\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(500,0)\"></path><path stroke-width=\"1\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(1001,0)\"></path></g></g></svg></span> </li>\n</ul>\n\n    <p><em>Note:</em> The tree in the input will be such that it can always be decomposed into components containing an even number of nodes. </p></div></div></div><div class=\"challenge_output_format\"><div class=\"msB challenge_output_format_title\"><p><strong>Output Format</strong></p></div><div class=\"msB challenge_output_format_body\"><div class=\"hackdown-content\"><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>Print the number of removed edges.</p></div></div></div><div class=\"challenge_sample_input\"><div class=\"msB challenge_sample_input_title\"><p><strong>Sample Input</strong></p></div><div class=\"msB challenge_sample_input_body\"><div class=\"hackdown-content\"><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><pre><code>10 9\n2 1\n3 1\n4 3\n5 2\n6 1\n7 2\n8 6\n9 8\n10 8\n</code></pre></div></div></div><div class=\"challenge_sample_output\"><div class=\"msB challenge_sample_output_title\"><p><strong>Sample Output</strong></p></div><div class=\"msB challenge_sample_output_body\"><div class=\"hackdown-content\"><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><pre><code>2\n</code></pre></div></div></div><div class=\"challenge_explanation\"><div class=\"msB challenge_explanation_title\"><p><strong>Explanation</strong></p></div><div class=\"msB challenge_explanation_body\"><div class=\"hackdown-content\"><style id=\"MathJax_SVG_styles\">.MathJax_SVG_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}\n.MathJax_SVG .MJX-monospace {font-family: monospace}\n.MathJax_SVG .MJX-sans-serif {font-family: sans-serif}\n.MathJax_SVG {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}\n.MathJax_SVG * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}\n.mjx-svg-href {fill: blue; stroke: blue}\n</style><svg style=\"display: none;\"><defs id=\"MathJax_SVG_glyphs\"></defs></svg><p>On removing edges <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-1-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"5.168ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewBox=\"0 -863.1 2225.2 1223.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path><g transform=\"translate(389,0)\"><path stroke-width=\"1\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g transform=\"translate(890,0)\"><path stroke-width=\"1\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g transform=\"translate(1335,0)\"><path stroke-width=\"1\" d=\"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z\"></path></g><g transform=\"translate(1835,0)\"><path stroke-width=\"1\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></svg></span> and <span style=\"font-size: 100%; display: inline-block;\" class=\"MathJax_SVG\" id=\"MathJax-Element-2-Frame\"><svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"5.168ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewBox=\"0 -863.1 2225.2 1223.9\" role=\"img\" focusable=\"false\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\"><path stroke-width=\"1\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path><g transform=\"translate(389,0)\"><path stroke-width=\"1\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g transform=\"translate(890,0)\"><path stroke-width=\"1\" d=\"M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z\"></path></g><g transform=\"translate(1335,0)\"><path stroke-width=\"1\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\"></path></g><g transform=\"translate(1835,0)\"><path stroke-width=\"1\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></svg></span>, we can get the desired result.</p>\n\n    <p>Original tree:  </p>\n\n    <p><img src=\"https://s3.amazonaws.com/hr-challenge-images/110/1466090203-2e0cf4f1be-even.png\" alt=\"even.png\" title=\"\"></p>\n\n    <p>Decomposed tree:  </p>\n\n    <p><img src=\"https://s3.amazonaws.com/hr-challenge-images/110/1466090256-fa2d218233-even1.png\" alt=\"even(1).png\" title=\"\"></p></div></div></div>\n</div>",
        "solution": "public class Solution {\n\n    /**\n     * Represents Node of the graph and contains the nodes that are attached to it. We may\n     * also have ids but emitted as array index is being used as node id.\n     */\n    private static class Node<T> {\n        private final List<Node<T>> childNodes = new ArrayList<>();\n\n        private void addChildNode(Node<T> node) {\n            this.childNodes.add(node);\n        }\n    }\n\n    /**\n     * Returns an array of integer containing below information about tree represented by input node:\n     * \t- No of vertices\n     * \t- Edges removed to decompose tree into trees of even vertices\n     */\n    private static int[] decomposeTree(Node<Integer> node) {\n\n        int count = 0, edgesToRemove = 0;\n        for(Node<Integer> childNode : node.childNodes) {\n            // For each child node\n            // calls current method recursively\n            final int[] tmpMetadata = decomposeTree(childNode);\n            // Accumulates edgesToRemove in a local variable\n            edgesToRemove += tmpMetadata[1];\n            // Checks if returned count is even - if yes, increments edgesToRemove by 1\n            // otherwise adds returned count to this method's count\n            if(tmpMetadata[0] % 2 == 0) {\n                edgesToRemove++;\n            } else {\n                count += tmpMetadata[0];\n            }\n        }\n        // Increments count since we are done with current node processing\n        count++;\n        //returns count for input node along with edges that can be removed to decompose the tree\n        return new int[]{count, edgesToRemove};\n    }\n\n    public static void main(String[] args) {\n        final Scanner in = new Scanner(System.in);\n        final int N = in.nextInt();\n        final int M = in.nextInt();\n\n        // Keeps all the nodes of tree in an array\n        final Node<Integer>[] treeNodes = (Node<Integer>[]) new Node[N];\n        for(int i = 0; i < M; i++) {\n            // Gets first node of vertex\n            final int node1 = in.nextInt() - 1;\n            // Gets second node of vertex\n            final int node2 = in.nextInt() - 1;\n\n            // If nodes exist in array, reuses those else creates a new node and adds back to array\n            treeNodes[node1] = (treeNodes[node1] == null ? new Node<Integer>() : treeNodes[node1]);\n            treeNodes[node2] = (treeNodes[node2] == null ? new Node<Integer>() : treeNodes[node2]);\n\n            //In order to create edge, we need to link nodes. Since this is a tree, it will be a directed edge and\n            // for consistency, we will add bigger node to smaller nodes\n            if(node1 < node2) {\n                treeNodes[node1].addChildNode(treeNodes[node2]);\n            } else {\n                treeNodes[node2].addChildNode(treeNodes[node1]);\n            }\n        }\n\n        // Since first element of array represents root of tree, we pass it to recursive method decompose tree\n        final int[] metadata = decomposeTree(treeNodes[0]);\n\n        // Print no of edges to be removed returned by above method invocation\n        System.out.println(metadata[1]);\n\n        in.close();\n    }\n}",
        "tags": "12",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 415,
        "number": 10005,
        "title": "Most Continuous Appearances",
        "difficulty": "Medium",
        "description": "<p>\n    Find all characters that have most continuous appearances.\n</p>\n<p>\n    For example:\n</p>\n<p>\n    1. input: \"this send meet\"  output: [s, e]\n</p>\n<p>\n    2. input: \"this is pea\" output: [t,h,i,s,i,s,p,e,a]\n</p>",
        "solution": "public class Solution {\n    /**\n     * Solution 1 use dp table to track max\n     * Get result in second scan\n     */\n    public static List<Character> mostContinuous(String s) {\n        List<Character> list = new ArrayList<>();\n        if (s == null || s.trim().isEmpty())\n            return list;\n\n        s = s.trim().replaceAll(\" \", \"\");\n        int n = s.length();\n        int[] dp = new int[n];\n        dp[0] = 1;\n        int max = 1;\n        for (int i = 1; i < s.length(); i++) {\n            dp[i] = s.charAt(i) == s.charAt(i - 1) ? dp[i - 1] + 1 : 1;\n            max = Math.max(max, dp[i]);\n        }\n\n        for (int i = 0; i < dp.length; i++) {\n            if (dp[i] == max) {\n                list.add(s.charAt(i));\n            }\n        }\n        return list;\n    }\n\n    /***\n     * Solution2:  Keep track of max, one sacn\n     * @param str\n     */\n    public void continuousChar(String str) {\n        str = str.trim();\n        if (str == null || str.length() == 0)\n            return;\n\n        char[] arr = str.toCharArray();\n        int max = 1;\n        int count = 1;\n        char prev = arr[0];\n        ArrayList<Character> result = new ArrayList<>();\n\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] == ' ')\n                continue;\n            if (arr[i] == prev) {\n                count++;\n            } else {\n                if (count > max) {\n                    result.clear();\n                    result.add(prev);\n                    max = count;\n                } else if (count == max) {\n                    result.add(prev);\n                }\n                prev = arr[i];\n                count = 1;\n            }\n        }\n\n        System.out.println(Arrays.toString(result.toArray()));\n    }\n}",
        "tags": "9",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 416,
        "number": 10006,
        "title": "Count Number Occurrence",
        "difficulty": "Hard",
        "description": "<p>Given a large sorted array which contains lots of duplicate numbers, find out the occurrence of each number. Time complexity should be better than O(n).</p>\n\n<pre>\n    //   input [1 (X200), 2(X50), 3(X10)]\n    //   count the occurrence of the elements\n    //   output {\n    //     1: 200,\n    //     2: 50,\n    //     3: 10,\n    //   }\n</pre>\n\n<p>\nthe solution of start point to start point + 2^n is freaking genius.\nworst case comparison:\n[1,2,3,4,5,6] start point + binary search: O(nlogn), start point + 2^n: O(n)\n</p>",
        "solution": "public class Solution {\n\n    public Map<Integer, Integer> getCount(int[] arr) {\n        Map<Integer, Integer> res = new HashMap<>();\n        if (arr == null || arr.length == 0) {\n            return res;\n        }\n\n        int start = 0;\n        while (start < arr.length) {\n            int end = findLast(start, arr);\n            res.put(arr[start], end - start + 1);\n            start = end + 1;\n        }\n        return res;\n    }\n\n    private int findLast(int start, int[] arr) {\n        int c = arr[start];\n        int diff = 1;\n        while (start + diff < arr.length && arr[start + diff] == c) {\n            diff <<= 1;\n        }\n        if (start + diff >= arr.length) {\n            return arr.length - 1;\n        }\n\n        // Binary Search for end\n        int end = start + diff;\n        while (start + 1 < end) {\n            int mid = (end - start) / 2 + start;\n            if (arr[mid] == c) {\n                start = mid;\n            } else {\n                end = mid;\n            }\n        }\n        return arr[end] == c ? end : start;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = { 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 };\n        Practice d = new Practice();\n        Map<Integer, Integer> res = d.getCount(arr);\n        for (Entry<Integer, Integer> entry : res.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n}\n",
        "tags": "0, 6",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 417,
        "number": 10007,
        "title": "Replace With Space",
        "difficulty": "Easy",
        "description": "<p>In-place replace all \"%20\" in a string to a space, ex: </p>\n\n<p>\n\tabc%20def -> abc def\n</p>\n<p>\n    abc%20%20%2 -> abc  %2\n</p>\n",
        "solution": "public class Solution {\n    public String replaceWithSpace(char[] originStr) {\n        int readPosition = 0;\n        int writePosition = 0;\n\n        while(readPosition < originStr.length){\n            // If find %20\n            if(originStr[readPosition] == '%' &&\n                    readPosition + 2 < originStr.length &&\n                    originStr[readPosition + 1] == '2' &&\n                    originStr[readPosition + 2] == '0'){\n                readPosition += 3; // Update read position\n                // Don't write multiple spaces\n                if(writePosition - 1 >= 0 && originStr[writePosition - 1] != ' ')\n                    originStr[writePosition++] = ' ';\n            } else {\n                originStr[writePosition++] = originStr[readPosition++];\n            }\n        }\n\n        return String.valueOf(originStr).substring(0, writePosition);\n    }\n}",
        "tags": "4",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 418,
        "number": 10008,
        "title": "BST LCA with Deepest Leaf",
        "difficulty": "Medium",
        "description": "<p>BST LCA with deepest leaf</p>\n<pre>\n     1\n    / \\\n   2   3\n      / \\\n     5   6 return 3.\n</pre>\n\n<pre>\n    1\n   / \\\n  2   3\n /   / \\\n4   5   6 retrun 1.\n</pre>\n",
        "solution": "public class Solution {\n    //Recursive way\n    // 'Time complexity: O(n),\n    // Space complexity: O(h), height of the tree'\n    public TreeNode findLCARucrsive(TreeNode root) {\n        Pair result = findLCA(root);\n        return result.node;\n    }\n\n    private Pair findLCA(TreeNode root) {\n        if (root == null) {\n            return new Pair(null, 0);\n        }\n        int depth = 0;\n        Pair left = findLCA(root.left);\n        Pair right = findLCA(root.right);\n        depth = Math.max(left.depth, right.depth) + 1;\n        if (left.depth == right.depth) {\n            return new Pair(root, depth);\n        } else if (left.depth > right.depth) {\n            return new Pair(left.node, depth);\n        } else {\n            return new Pair(right.node, depth);\n        }\n    }\n\n    class Pair {\n        public TreeNode node;\n        public int depth;\n\n        public Pair(TreeNode node, int depth) {\n            this.node = node;\n            this.depth = depth;\n        }\n    }\n\n    // Iterative Solution\n    public TreeNode findLCAIterative(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        HashMap<TreeNode, TreeNode> childToParent = new HashMap<>();\n        Queue<TreeNode> level = new LinkedList<>();\n        TreeNode left = null;\n        TreeNode right = null;\n        level.offer(root);\n        while (!level.isEmpty()) {\n            int size = level.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = level.poll();\n                if (i == 0) {\n                    left = node;\n                }\n                if (i == size - 1) {\n                    right = node;\n                }\n                if (node.left != null) {\n                    level.offer(node.left);\n                    childToParent.put(node.left, node);\n                }\n                if (node.right != null) {\n                    level.offer(node.right);\n                    childToParent.put(node.right, node);\n                }\n            }\n        }\n        while (left != right) {\n            left = childToParent.get(left);\n            right = childToParent.get(right);\n        }\n        return left;\n    }\n}",
        "tags": "12",
        "companies": "0",
        "specialtags": "0"
    },
    {
        "id": 419,
        "number": 10009,
        "title": "Multiple Leaf Tree LCA with Deepest Leaf",
        "difficulty": "Medium",
        "description": "<p>Multiple leaft Tree LCA with deepest leaf</p>\n\n<pre>\n     1\n   / | \\\n  2  3  4\n /     / \\\n4     5   6 retrun 1.\n</pre>",
        "solution": "public class MultipleChildrenSolution {\n    public TreeNodeMulti findLca(TreeNodeMulti root) {\n        return helper(root).node;\n    }\n\n    private Result helper(TreeNodeMulti root) {\n        if (root == null) {\n            return new Result(null, 0);\n        }\n        int depth = 0;\n        List<Result> next = new ArrayList<>();\n        for (TreeNodeMulti child : root.children) {\n            next.add(helper(child));\n        }\n        Result deepest = new Result(null, 0);\n        Result deepest2 = new Result(null, 0);\n        for (Result result : next) {\n            if (result.depth >= deepest.depth) {\n                deepest2.node = deepest.node;\n                deepest2.depth = deepest.depth;\n                deepest.node = result.node;\n                deepest.depth = result.depth;\n            }\n        }\n        depth = 1 + deepest.depth;\n        if (deepest.depth == deepest2.depth) {\n            return new Result(root, depth);\n        }\n        return new Result(deepest.node, depth);\n    }\n\n    class Result {\n        TreeNodeMulti node;\n        int depth;\n\n        public Result(TreeNodeMulti node, int depth) {\n            this.node = node;\n            this.depth = depth;\n        }\n    }\n\n    class TreeNodeMulti {\n        public int val;\n        public List<TreeNodeMulti> children;\n\n        public TreeNodeMulti(int val) {\n            this.val = val;\n            this.children = new ArrayList<>();\n        }\n    }\n}",
        "tags": "12",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 420,
        "number": 10010,
        "title": "Valley or Peak Element",
        "difficulty": "Easy",
        "description": "<p>Given an array will have either a valley or a mountain, only one, not one of each,\n    find out the index of the valley or peak element</p>\n<p>And with one more assumption: array[i - 1] = array[i] + 1 or array[i - 1] = array[i] - 1.</p>\n<p>\nExample 1: [1,2,3,4,3,2,1] --> return 3\n</p>\n<p>\nExample 2: [6,5,4,3,2,3,4] --> return 4\n</p>",
        "solution": "public class Solution {\n    /***\n     * 1. Use first two elements to judge is up or down\n     * 2. if it is up:\n     * \t\tAssume A[x] is peak, we have\n     * \t\tA[x] - A[i] = x - i and A[x] - A[j] = j - x\n     * \t\tso x = (A[j] - A[i] + i + j)/2\n     * 2. if it is down\n     * \t\tAssume A[x] is vally, we have\n     * \t\tA[x] - A[i] = i - x and A[x] - A[j] = x - j\n     * \t\tx = (A[i] - A[j] + i + j)/2\n     */\n    public int findPeak(int[] A) {\n        boolean isUp = (A[1] > A[0]) ? true : false;\n        if (isUp) {\n            return (A[A.length - 1] - A[0] + A.length - 1) / 2;\n        } else {\n            return (A[0] - A[A.length - 1] + A.length - 1) / 2;\n        }\n    }\n}",
        "tags": "0, 3",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 421,
        "number": 10011,
        "title": "Row With Most Ones",
        "difficulty": "Medium",
        "description": "<p>Given a boolean 2D array, where each row is sorted. Find the row with the maximum number of 1s.</p>\n\n<p>Example</p>\n<p>Input matrix</p>\n<pre>\n    0 1 1 1\n    0 0 1 1\n    1 1 1 1  // this row has maximum 1s\n    0 0 0 0\n</pre>\n\n<p>Output: 2</p>\n",
        "solution": "public class Solution {\n    public int rowWithMax1s(int[][] mat){\n        // Initialize first row as row with max 1s\n        int max_row_index = 0;\n\n        // The function first() returns index of first 1 in row 0.\n        // Use this index to initialize the index of leftmost 1 seen so far\n        int j = 0;\n        while(j < mat[0].length && mat[0][j] == 0){\n            j++;\n        }\n\n        j = j == mat[0].length ? j - 1 : j;\n        for (int i = 1; i < mat.length; i++){\n            // Move left until a 0 is found\n            while (j >= 0 && mat[i][j] == 1){\n                j--;  // Update the index of leftmost 1 seen so far\n                max_row_index = i;  // Update max_row_index\n            }\n        }\n        return max_row_index;\n    }\n}",
        "tags": "21",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 422,
        "number": 10012,
        "title": "Find the Point Where Maximum Intervals Overlap",
        "difficulty": "Medium",
        "description": "<p>Consider a big party where a log register for guest’s entry and exit times is maintained. Find the time at which there are maximum guests in the party. Note that entries in register are not in any order.<span id=\"more-135087\"></span></p>\n\n<p>Example:\n</p>\n\n<pre>Input: arrl[] = {1, 2, 9, 5, 5}\n       exit[] = {4, 5, 12, 9, 12}\nFirst guest in array arrives at 1 and leaves at 4,\nsecond guest arrives at 2 and leaves at 5, and so on.\n\nOutput: 5\nThere are maximum 3 guests at time 5.  </pre>",
        "solution": "public class Solution {\n    public int findMaxGuests(int[] arrivals, int[] exits) {\n        // Sort arrival and exit arrays\n        Arrays.sort(arrivals);\n        Arrays.sort(exits);\n\n        // guests_in indicates number of guests at a time\n        int guests_in = 1, max_guests = 1, time = arrivals[0];\n        int i = 1, j = 0, n = arrivals.length;\n\n        // Similar to merge in merge sort to process\n        // all events in sorted order\n        while (i < n && j < n) {\n            // If next event in sorted order is arrival,\n            // increment count of guests\n            if (arrivals[i] <= exits[j]) {\n                guests_in++;\n                // Update max_guests if needed\n                if (guests_in > max_guests) {\n                    max_guests = guests_in;\n                    time = arrivals[i];\n                }\n                i++;  //increment index of arrival array\n            } else {// If event is exit, decrement count\n                // of guests.\n                guests_in--;\n                j++;\n            }\n        }\n        return max_guests;\n    }\n}",
        "tags": "0, 13",
        "companies": "0",
        "specialtags": ""
    },
    {
        "id": 423,
        "number": 10013,
        "title": "Convert a Binary Tree to a Circular Doubly Link List",
        "difficulty": "Hard",
        "description": "<p>Given a Binary Tree, convert it to a Circular Doubly Linked List (In-Place).</p>\n\n<ul>\n    <li>The left and right pointers in nodes are to be used as previous and next pointers respectively in converted Circular Linked List.</li>\n    <li>The order of nodes in List must be same as Inorder of the given Binary Tree.</li>\n    <li>The first node of Inorder traversal must be head node of the Circular List.</li>\n</ul>\n\n<p><strong>Example:</strong><br>\n    <a href=\"http://www.geeksforgeeks.org/wp-content/uploads/tree-to-list.png\"><img class=\"aligncenter size-full wp-image-139076\" src=\"http://www.geeksforgeeks.org/wp-content/uploads/tree-to-list.png\" alt=\"tree to list\" width=\"873\" height=\"534\" srcset=\"http://www.geeksforgeeks.org/wp-content/uploads/tree-to-list.png 873w, http://www.geeksforgeeks.org/wp-content/uploads/tree-to-list-300x184.png 300w, http://www.geeksforgeeks.org/wp-content/uploads/tree-to-list-660x404.png 660w\" sizes=\"(max-width: 873px) 100vw, 873px\"></a></p>\n",
        "solution": "public class Solution {\n    // Method converts a tree to a circular\n    // Link List and then returns the head of the Link List\n    public TreeNode bTreeToCList(TreeNode root) {\n        if (root == null)\n            return null;\n\n        // Recursively convert left and right subtrees\n        TreeNode left = bTreeToCList(root.left);\n        TreeNode right = bTreeToCList(root.right);\n\n        // Make a circular linked list of single node (or root).\n        // To do so, make the right and left pointers of this node point to itself\n        root.left = root.right = root;\n\n        // Step 1 Concatenate the left list with the list with current node\n        // Step 2 Concatenate the returned list with the right List\n        return concatenate(concatenate(left, root), right);\n    }\n\n    // concatenate both the lists and returns the head of the List\n    private TreeNode concatenate(TreeNode leftList, TreeNode rightList) {\n        // If either of the list is empty, then return the other list\n        if (leftList == null) return rightList;\n        if (rightList == null) return leftList;\n\n        // Store the last Node of left List\n        TreeNode leftLast = leftList.left;\n        // Store the last Node of right List\n        TreeNode rightLast = rightList.left;\n\n        // Connect the last node of Left List\n        // with the first Node of the right List\n        leftLast.right = rightList;\n        rightList.left = leftLast;\n\n        // left of first node refers to the last node in the list\n        leftList.left = rightLast;\n        // Right of last node refers to the first node of the List\n        rightLast.right = leftList;\n\n        // Return the Head of the List\n        return leftList;\n    }\n}",
        "tags": "2",
        "companies": "0",
        "specialtags": "0"
    },
    {
        "id": 424,
        "number": 10014,
        "title": "Largest subarray with equal number of 0s and 1s",
        "difficulty": "Medium",
        "description": "<p>Given an array containing only 0s and 1s, find the largest subarray which contain equal no of 0s and 1s.\n    Expected time complexity is O(n). <span id=\"more-20586\"></span></p>\n\n<p>Examples:</p>\n<pre>Input: arr[] = {1, 0, 1, 1, 1, 0, 0}\nOutput: 1 to 6 (Starting and Ending indexes of output subarray)\n\nInput: arr[] = {1, 1, 1, 1}\nOutput: No such subarray\n\nInput: arr[] = {0, 0, 1, 1, 0}\nOutput: 0 to 3 Or 1 to 4\n</pre>",
        "solution": "class Solution {\n    // Returns largest subarray with equal number of 0s and 1s\n    int maxLen(int arr[], int n) {\n        // Creates an empty hashMap hM\n        Map<Integer, Integer> hM = new HashMap<>();\n\n        int sum = 0;     // Initialize sum of elements\n        int max_len = 0; // Initialize result\n        int ending_index = -1;\n        int start_index = 0;\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = (arr[i] == 0) ? -1 : 1;\n        }\n\n        // Traverse through the given array\n        for (int i = 0; i < n; i++) {\n            // Add current element to sum\n            sum += arr[i];\n\n            // To handle sum=0 at last index\n            if (sum == 0) {\n                max_len = i + 1;\n                ending_index = i;\n            }\n\n            // If this sum is seen before, then update max_len\n            // if required\n            if (hM.containsKey(sum)) {\n                if (max_len < i - hM.get(sum + n)) {\n                    max_len = i - hM.get(sum + n);\n                    ending_index = i;\n                }\n            } else // Else put this sum in hash table\n                hM.put(sum + n, i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            arr[i] = (arr[i] == -1) ? 0 : 1;\n        }\n        int end = ending_index - max_len + 1;\n\n        return max_len;\n    }\n}",
        "tags": "1",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 425,
        "number": 10015,
        "title": "Knight Path",
        "difficulty": "Hard",
        "description": "⼀一骑⼠士在⼀一个⽆无限⼤大的国际象棋棋盘，有障碍",
        "solution": "public class Point2 {\n    public int x;\n    public int y;\n    public Point2(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int hashCode() {\n        return Arrays.hashCode(new int[]{x, y});\n    }\n    @Override\n    public boolean equals(Object other) {\n        if (other == null) {\n            return false;\n        }\n        if (other == this) {\n            return true;\n        }\n        if (!(other instanceof Point2)) {\n            return false;\n        }\n        Point2 point = (Point2) other;\n        return point.x == x && point.y == y;\n    }\n}\n\npublic class Solution {\n    public int knightPath(Point2 start, Point2 end, Set<Point2> blocks) {\n        int[][] nextStep = { { 1, -2 }, { 1, 2 }, { -1, 2 }, { 1, -2 },\n                { 2, -1 }, { 2, 1 }, { -2, -1 }, { -2, 1 } };\n        Queue<Point2> explore = new LinkedList<>();\n        Set<Point2> visited = new HashSet<>();\n        int step = 0;\n        explore.offer(start);\n        visited.add(start);\n        while (!explore.isEmpty()) {\n            step++;\n            int size = explore.size();\n            for (int i = 0; i < size; i++) {\n                Point2 point = explore.poll();\n                for (int k = 0; k < 8; k++) {\n                    int x = nextStep[k][0];\n                    int y = nextStep[k][1];\n                    int nextX = point.x + x;\n                    int nextY = point.y + y;\n                    Point2 next = new Point2(nextX, nextY);\n                    boolean canReach1 = true;\n                    boolean canReach2 = true;\n                    if (Math.abs(y) > Math.abs(x)) {\n                        int tempY = y;\n                        while (Math.abs(tempY) > 0) {\n                            Point2 check = new Point2(point.x, point.y + tempY);\n                            Point2 check2 = new Point2(nextX, point.y + tempY - 1);\n                            canReach1 = blocks.contains(check) ? false : canReach1;\n                            canReach2 = blocks.contains(check2) ? false : canReach2;\n                            tempY = tempY > 0 ? tempY - 1 : tempY + 1;\n                        }\n                    } else {\n                        int tempX = x;\n                        while (Math.abs(tempX) > 0) {\n                            Point2 check = new Point2(point.x + tempX, point.y);\n                            Point2 check2 = new Point2(point.x + tempX - 1, nextY);\n                            canReach1 = blocks.contains(check) ? false : canReach1;\n                            canReach2 = blocks.contains(check2) ? false : canReach2;\n                            tempX = tempX > 0 ? tempX - 1 : tempX + 1;\n                        }\n                    }\n                    if ((!canReach1 && !canReach2) || blocks.contains(next)) {\n                        continue;\n                    }\n                    if (next.equals(end)) {\n                        return step;\n                    }\n                    if (!visited.contains(next)) {\n                        explore.add(next);\n                        visited.add(next);\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "tags": "19",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 426,
        "number": 10016,
        "title": "Task Schedule I",
        "difficulty": "Easy",
        "description": "<pre>\n    # Tasks: 1, 1, 2, 1\n    # Recovery interva (cooldown): 2\n    # Output: 7  (order is 1 _ _ 1 2 _ 1)\n\n    # Example 2\n\n    # Tasks: 1, 2, 3, 1, 2, 3\n    # Recovery interval (cooldown): 3\n    # Output: 7  (order is 1 2 3 _ 1 2 3)\n\n    # Example 3.\n\n    # Tasks: 1, 2, 3 ,4, 5, 6, 2, 4, 6, 1, 2, 4\n    # Recovery interval (cooldown): 6\n    # Output: 18  (1 2 3 4 5 6 _ _ 2 _ 4 _ 6 1 _ 2 _ 4)\n</pre>",
        "solution": "public class Solution {\n    // Output the string\n    String getStr(String s, int k) {\n        Map<Character, Integer> map = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            int idx = map.getOrDefault(c, -k);\n            while (sb.length() - k < idx) {\n                sb.append(\"_\");\n            }\n            sb.append(c);\n            map.put(c, sb.length());\n        }\n        return sb.toString();\n    }\n\n    // Output the total time spent\n    public static int missionOrder(int[] mission, int N) {\n        if (mission.length == 0) {\n            return 0;\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        int time = 0;\n        for (int i = 0; i < mission.length; i++) {\n            time++;\n            if (!map.containsKey(mission[i])) {\n                map.put(mission[i], time);\n            } else {\n                if (time - map.get(mission[i]) > N) {\n                    map.put(mission[i], time);\n                } else {\n                    time = N + map.get(mission[i]) + 1;\n                    map.put(mission[i], time);\n                }\n            }\n        }\n        return time;\n    }\n}",
        "tags": "1",
        "companies": "0",
        "specialtags": "2"
    },
    {
        "id": 427,
        "number": 11001,
        "title": "Binary Search",
        "difficulty": "Easy",
        "description": "<h1 class=\"entry-title\">Binary Search</h1>\n<p>Given a sorted array arr[] of n elements, write a function to search a given element x in arr[].<span id=\"more-142311\"></span></p>\n\n<p>We basically ignore half of the elements just after one comparison.</p>\n\n<ol>\n    <li>Compare x with the middle element. </li>\n    <li>If x matches with middle element, we return the mid index.  </li>\n    <li> Else If x is greater than the mid element, then x can only lie in right half subarray after the mid element.  So we recur for right half. </li>\n    <li> Else (x is smaller) recur for the left half.</li>\n</ol>\n",
        "solution": "// Returns index of x if it is present in arr[l..r], else\n// return -1\nclass BinarySearch {\n    // Recursive Solution\n    int binarySearch(int arr[], int l, int r, int x) {\n        // We reach here when element is not present in array\n        if(r < l) return -1;\n\n        int mid = l + (r - l) / 2;\n        // If the element is present at the middle itself\n        if (arr[mid] == x)\n            return mid;\n        // If element is smaller than mid, then it can only\n        // be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        // Else the element can only be present in right\n        // subarray\n        return binarySearch(arr, mid + 1, r, x);\n    }\n\n    // Iterative Solution\n    int binarySearch(int arr[], int x) {\n        int l = 0, r = arr.length - 1;\n        while (l <= r) {\n            int m = l + (r - l) / 2;\n            // Check if x is present at mid\n            if (arr[m] == x)\n                return m;\n            // If x greater, ignore left half\n            if (arr[m] < x)\n                l = m + 1;\n                // If x is smaller, ignore right half\n            else\n                r = m - 1;\n        }\n        // if we reach here, then element was not present\n        return -1;\n    }\n\n}",
        "tags": "1",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 428,
        "number": 11002,
        "title": "Quick Select",
        "difficulty": "Medium",
        "description": "<p>Quickselect uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from <span class=\"texhtml\">O(<i>n</i> log <i>n</i>)</span> to <span class=\"texhtml\">O(<i>n</i>)</span>, with a worst case of O(<i>n</i><sup>2</sup>).</p>",
        "solution": "public class QuickSelect {\n    // Recursive Solution\n    // Time complexity = O(n)\n    // Discard half each time: n+(n/2)+(n/4)..1 = n + (n-1) = O(2n-1) = O(n),\n    // because n/2+n/4+n/8+..1=n-1.\n    public int findKthLargest(int[] nums, int k) {\n        if (nums == null || nums.length == 0)\n            return Integer.MAX_VALUE;\n        return findKthLargest(nums, 0, nums.length - 1, nums.length - k);\n    }\n\n    // quick select: kth smallest\n    private int findKthLargest(int[] nums, int start, int end, int k) {\n        if (start > end)\n            return Integer.MAX_VALUE;\n\n        int pivot = nums[end];// Take A[end] as the pivot,\n        int left = start;\n        for (int i = start; i < end; i++) {\n            if (nums[i] <= pivot) // Put numbers < pivot to pivot's left\n                swap(nums, left++, i);\n        }\n        swap(nums, left, end);// Finally, swap A[end] with A[left]\n\n        if (left == k)// Found kth smallest number\n            return nums[left];\n        else if (left < k)// Check right part\n            return findKthLargest(nums, left + 1, end, k);\n        else // Check left part\n            return findKthLargest(nums, start, left - 1, k);\n    }\n\n    private void swap(int[] A, int i, int j) {\n        int tmp = A[i];\n        A[i] = A[j];\n        A[j] = tmp;\n    }\n\n    // Iterative\n    public int findKthLargest(int[] nums, int k) {\n        shuffle(nums);\n        int start = 0, end = nums.length - 1, index = nums.length - k;\n        while (start < end) {\n            int pivot = partion(nums, start, end);\n            if (pivot < index)\n                start = pivot + 1;\n            else if (pivot > index)\n                end = pivot - 1;\n            else\n                return nums[pivot];\n        }\n        return nums[start];\n    }\n    // Shuffle array to O(N) guaranteed running time + O(1) space\n    private void shuffle(int a[]) {\n        final Random random = new Random();\n        for(int ind = 1; ind < a.length; ind++) {\n            final int r = random.nextInt(ind + 1);\n            swap(a, ind, r);\n        }\n    }\n    // Partition function\n    private int partion(int[] nums, int start, int end) {\n        int pivot = start, temp;\n        while (start <= end) {\n            while (start <= end && nums[start] <= nums[pivot]) start++;\n            while (start <= end && nums[end] > nums[pivot]) end--;\n            if (start > end) break;\n            swap(nums, start, end);\n        }\n        swap(nums, end, pivot);\n        return end;\n    }\n    // excahnge function\n    private void swap(int[] a, int i, int j) {\n        final int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n}",
        "tags": "7",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 429,
        "number": 11003,
        "title": "Reverse LinkedList",
        "difficulty": "Medium",
        "description": "<p>Given the start and end of a linked list, reverse the nodes of a linked list and return its modified list.</p>",
        "solution": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Iterative Solution\n    public ListNode reverse(ListNode begin, ListNode end) {\n        ListNode curr = begin.next;\n        while (curr.next != end) {\n            ListNode temp = begin.next;\n            begin.next = curr.next;\n            curr.next = curr.next.next;\n            begin.next.next = temp;\n        }\n        return curr;\n    }\n\n    // Recursive Solution\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode p = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return p;\n    }\n}",
        "tags": "2",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 430,
        "number": 11004,
        "title": "KMP",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Implement strStr().\n</p>\n    <p>\n        Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle == null || haystack == null || needle.length() > haystack.length())\n            return -1;\n        if (needle.length() == 0){\n            return 0;\n        }\n\n        int[] overlay = getOverlay(needle);\n        int i = 0;\n        while (i <= haystack.length() - needle.length()){\n            int j = 0;\n            while(j < needle.length()){\n                if (haystack.charAt(i+j) != needle.charAt(j)){\n                    i = j == 0 ? i+1 : i+j-overlay[j-1];\n                    break;\n                }\n                j++;\n            }\n            if(j == needle.length()){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Generate the prefix function for pattern itself\n    private int[] getOverlay(String pattern){\n        int[] res = new int[pattern.length()];\n        res[0] = 0;\n        for(int i = 1; i < pattern.length(); i++){\n            int index = res[i-1];\n            while (index > 0 && pattern.charAt(index) != pattern.charAt(i))\n                index = res[index-1];\n            res[i] = (pattern.charAt(index) == pattern.charAt(i)) ? index + 1 : 0;\n        }\n        return res;\n    }\n}",
        "tags": "5",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 431,
        "number": 11005,
        "title": "Combination Sum II",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Given a collection of candidate numbers (<b><i>C</i></b>) and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>.\n</p>\n\n    <p>Each number in <b><i>C</i></b> may only be used <b>once</b> in the combination.\n    </p>\n    <p><b>Note:</b><br>\n    </p><ul>\n    <li>All numbers (including target) will be positive integers.</li>\n    <li>The solution set must not contain duplicate combinations.</li>\n</ul>\n    <p></p>\n\n    <p>\n        For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>, <br>\n        A solution set is: <br>\n    </p><pre>[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n</pre>\n\n</div>",
        "solution": "public class Solution {\n    /**\n     * Time Complexity: C(n,1) + C(n,2) + ..C(n, n) = O(2^n)\n     * where n is the size of candidates,\n     * and k is the max repeated times for each candidates.\n     * Space complexity: O(m) where m is the size of array for the solution\n     *\n     * @param candidates\n     * @param target\n     * @return\n     */\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> re = new ArrayList<List<Integer>>();\n        getList(candidates, target, new ArrayList<Integer>(), re, 0);\n        return re;\n    }\n\n    private void getList(int[] candidates, int target, List<Integer> li, List<List<Integer>> re, int start) {\n        if (target <= 0) {\n            if (target == 0) {\n                List<Integer> templi = new ArrayList<Integer>(li);\n                re.add(templi);\n            }\n            return;\n        }\n\n        for (int i = start; i < candidates.length; i++) {\n            if(i > start && candidates[i] == candidates[i-1]){\n                continue; // skip duplicates\n            }\n            li.add(candidates[i]);\n            getList(candidates, target - candidates[i], li, re, i+1);\n            li.remove(li.size() - 1);\n        }\n    }\n}",
        "tags": "0, 8",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 432,
        "number": 11006,
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "description": "<div class=\"question-description\">\n    <p></p><p>\n    Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n</p>\n\n    <p>\n        For example,<br>\n        <b>S</b> = <code>\"ADOBECODEBANC\"</code><br>\n        <b>T</b> = <code>\"ABC\"</code><br>\n    </p>\n    <p>\n        Minimum window is <code>\"BANC\"</code>.\n    </p>\n\n    <p>\n        <b>Note:</b><br>\n        If there is no such window in S that covers all characters in T, return the empty string <code>\"\"</code>.\n    </p>\n    <p>\n        If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\n    </p><p></p>\n</div>",
        "solution": "public class Solution {\n    public String minWindow(String s, String t) {\n        String result = \"\";\n        if (s.length() == 0 || t.length() == 0) {\n            return result;\n        }\n\n        int[] map = new int[256];\n        int[] window = new int[256];\n        for (int i = 0; i < t.length(); i++) {\n            map[t.charAt(i)]++;\n        }\n\n        int minLength = Integer.MAX_VALUE;\n        int letterCounter = 0;\n        for (int slow = 0, fast = 0; fast < s.length(); fast++) {\n            if (map[s.charAt(fast)] > 0) {\n                window[s.charAt(fast)]++;\n                if (window[s.charAt(fast)] <= map[s.charAt(fast)]) {\n                    letterCounter++;\n                }\n            }\n\n            if (letterCounter >= t.length()) {\n                while (map[s.charAt(slow)] == 0 || window[s.charAt(slow)] > map[s.charAt(slow)]) {\n                    window[s.charAt(slow)]--;\n                    slow++;\n                }\n                if (fast - slow + 1 < minLength) {\n                    minLength = fast - slow + 1;\n                    result = s.substring(slow, slow + minLength);\n                }\n            }\n        }\n        return result;\n    }\n}",
        "tags": "1, 4, 5",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 433,
        "number": 11007,
        "title": "Tree Inorder Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a binary tree, return the <i>inorder</i> traversal of its nodes' values.</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>[1,null,2,3]</code>,<br>\n    </p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n    <p></p>\n    <p>\n        return <code>[1,3,2]</code>.\n    </p>\n\n    <p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Recursive Solution\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> re = new ArrayList<>();\n        if(root == null) return re;\n        re.addAll(inorderTraversal(root.left));\n        re.add(root.val);\n        re.addAll(inorderTraversal(root.right));\n        return re;\n    }\n\n    // Iterative Solution\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> re = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        if (root == null) return re;\n        while (!stack.empty() || root != null) {\n            if (root != null) {\n                stack.push(root);\n                root = root.left;\n            } else {\n                root = stack.pop();\n                re.add(root.val);\n                root = root.right;\n            }\n        }\n        return re;\n    }\n\n    // Morris Traversal method\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<Integer>();\n        TreeNode temp = null;\n        while(root!=null){\n            if(root.left!=null){\n                // connect threading for root\n                temp = root.left;\n                while(temp.right!=null && temp.right != root)\n                    temp = temp.right;\n                // the threading already exists\n                if(temp.right!=null){\n                    temp.right = null;\n                    res.add(root.val);\n                    root = root.right;\n                }else{\n                    // construct the threading\n                    temp.right = root;\n                    root = root.left;\n                }\n            }else{\n                res.add(root.val);\n                root = root.right;\n            }\n        }\n        return res;\n    }\n}",
        "tags": "1, 12, 15",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 434,
        "number": 11008,
        "title": "Tree Preorder Traversal",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a binary tree, return the <i>preorder</i> traversal of its nodes' values.</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>{1,#,2,3}</code>,<br>\n    </p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n    <p></p>\n    <p>\n        return <code>[1,2,3]</code>.\n    </p>\n\n    <p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p></p>\n\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution\n\n        // Recursive Solution\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> re = new ArrayList<Integer>();\n            if (root == null) return re;\n            re.add(root.val);\n            re.addAll(preorderTraversal(root.left));\n            re.addAll(preorderTraversal(root.right));\n            return re;\n        }\n\n        // Iterative Solution\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> res = new ArrayList<>();\n            if (root == null) return res;\n            Stack<TreeNode> stack = new Stack<>();\n            stack.push(root);\n            while (!stack.isEmpty()) {\n                root = stack.pop();\n                res.add(root.val);\n                if (root.right != null)\n                    stack.push(root.right);\n                if (root.left != null)\n                    stack.push(root.left);\n            }\n            return res;\n        }\n\n        // Morris Travasal\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> res = new ArrayList<Integer>();\n            TreeNode cur = root, prev;\n            while (cur != null) {\n                if (cur.left == null) {\n                    res.add(cur.val);\n                    cur = cur.right;\n                } else {\n                    prev = cur.left;\n                    while (prev.right != null && prev.right != cur)\n                        prev = prev.right;\n\n                    if (prev.right == null) {\n                        // the only difference with inorder-traversal\n                        res.add(cur.val);\n                        prev.right = cur;\n                        cur = cur.left;\n                    } else {\n                        prev.right = null;\n                        cur = cur.right;\n                    }\n                }\n            }\n            return res;\n        }\n}",
        "tags": "1, 12, 15",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 435,
        "number": 11009,
        "title": "Tree Postorder Traversal",
        "difficulty": "Hard",
        "description": "<div class=\"question-content\">\n    <p></p><p>Given a binary tree, return the <i>postorder</i> traversal of its nodes' values.</p>\n\n    <p>\n        For example:<br>\n        Given binary tree <code>{1,#,2,3}</code>,<br>\n    </p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n    <p></p>\n    <p>\n        return <code>[3,2,1]</code>.\n    </p>\n\n    <p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p></p>\n</div>",
        "solution": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    // Recursive Solution\n    public ArrayList<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> re = new ArrayList<Integer>();\n        if (root == null) return re;\n        re.addAll(postorderTraversal(root.left));\n        re.addAll(postorderTraversal(root.right));\n        re.add(root.val);\n        return re;\n    }\n\n    // Iterative Solution\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        if (root == null) return res;\n        Stack<TreeNode> parentStack = new Stack<>();\n        TreeNode lastnodevisited = root, peekNode;\n        while (!parentStack.isEmpty() || root != null) {\n            if (root!= null) {\n                parentStack.push(root);\n                root = root.left;\n            } else {\n                peekNode = parentStack.peek();\n                // If right child exists AND traversing node from left child, move right\n                if (peekNode.right != null && lastnodevisited != peekNode.right) {\n                    root = peekNode.right;\n                } else {\n                    parentStack.pop();\n                    res.add(peekNode.val);\n                    lastnodevisited = peekNode;\n                }\n            }\n        }\n        return res;\n    }\n}",
        "tags": "1, 12, 15",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 436,
        "number": 11010,
        "title": "Bit Manipulation",
        "difficulty": "Medium",
        "description": "Common bit manipulation operations and masks.",
        "solution": "操作原理\n        符号\t规则\n        &\t两个位都为1时, 结果才为1\n        |\t两个位都为0时, 结果才为0\n        ~\t取反\n        ^\t两个位相同为0, 相异为1\n        位操作只能用于整形数据,\n        对float和double类型进行位操作会被编译器报错.\n\n        常见位操作\n        1. 获取(第i位)\n        boolean getBit(int i, int num){\n            return ( (num & (1 << i)) != 0 );\n        }\n\n        2. 置位(第i位)\n        int setBit(int i, int num){\n            return num | (1 << i);\n        }\n\n        3. 清零\n        3.1    清零i位\n        int clearBit(int num, int i) {\n            int mask = ~(1 << i);\n            return num & mask;\n        }\n        3.2    清零num最高位至i位\n        int clearBitMSBthroughI(int num, int i){\n            int mask = (1<< i) -1;\n            return num & mask;\n        }\n        3.3    清零i位到0位\n        int clearBitsIThrough0(int i, int num) {\n            int mask = ~( (1 << (i+1) )  -1 );\n            return num & mask;\n        }\n\n        4. 去掉数字n中最右一位1\n        int clearOne(int num) {\n            num = (num & (num - 1));\n            return num;\n        }\n",
        "tags": "22",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 437,
        "number": 11011,
        "title": "Implement Trie",
        "difficulty": "Medium",
        "description": "<div class=\"question-content\">\n    <p></p><p>\n    Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.\n</p>\n\n    <p>\n        <b>Note:</b><br>\n        You may assume that all inputs are consist of lowercase letters <code>a-z</code>.\n    </p><p></p>\n\n</div>",
        "solution": "public class Trie {\n\n    class TrieNode {\n        String word = \"\";\n        Map<Character, TrieNode> children = null;\n        public TrieNode(){\n            this.children = new HashMap<>();\n        }\n    }\n\n    TrieNode root;\n\n    /** Initialize your data structure here. */\n    public Trie() {\n        this.root = new TrieNode();\n    }\n\n    /** Inserts a word into the trie. */\n    public void insert(String word) {\n        TrieNode cur = root;\n        for(int i = 0; i < word.length(); i++){\n            char c = word.charAt(i);\n            if(!cur.children.containsKey(c)){\n                cur.children.put(c, new TrieNode());\n            }\n            cur = cur.children.get(c);\n        }\n        cur.word = word;\n    }\n\n    /** Returns if the word is in the trie. */\n    public boolean search(String word) {\n        TrieNode cur = root;\n        for(int i = 0; i < word.length(); i++){\n            char c = word.charAt(i);\n            if(cur.children.containsKey(c)){\n                cur = cur.children.get(c);\n            } else {\n                return false;\n            }\n        }\n        return cur.word.equals(word);\n    }\n\n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    public boolean startsWith(String prefix) {\n        TrieNode cur = root;\n        for(int i = 0; i < prefix.length(); i++){\n            char c = prefix.charAt(i);\n            if(cur.children.containsKey(c)){\n                cur = cur.children.get(c);\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */",
        "tags": "10, 11",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 438,
        "number": 11012,
        "title": "Shortest Path",
        "difficulty": "Medium",
        "description": "Find the shortest path between two nodes in a graph.",
        "solution": "public class Point2 {\n    public int x;\n    public int y;\n    public Point2(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    @Override\n    public int hashCode() {\n        return Arrays.hashCode(new int[]{x, y});\n    }\n    @Override\n    public boolean equals(Object other) {\n        if (other == null) {\n            return false;\n        }\n        if (other == this) {\n            return true;\n        }\n        if (!(other instanceof Point2)) {\n            return false;\n        }\n        Point2 point = (Point2) other;\n        return point.x == x && point.y == y;\n    }\n}\n\nclass Solution {\n    private final static int[] X = { 0, 0, 1, -1 };\n    private final static int[] Y = { 1, -1, 0, 0 };\n\n    public int minStep(Point2 start, Point2 end, Set<Point2> blocks) {\n        Set<Point2> visited = new HashSet<>();\n        Queue<Point2> explore = new LinkedList<>();\n        int step = 0;\n        explore.offer(start);\n        visited.add(start);\n        while (!explore.isEmpty()) {\n            step++;\n            int size = explore.size();\n            for (int i = 0; i < size; i++) {\n                Point2 point = explore.poll();\n                for (int k = 0; k < 4; k++) {\n                    int nextX = point.x + X[k];\n                    int nextY = point.y + Y[k];\n                    Point2 next = new Point2(nextX, nextY);\n                    if (next.equals(end)) {\n                        return step;\n                    }\n                    if (!visited.contains(next) && !blocks.contains(next)) {\n                        explore.offer(next);\n                        visited.contains(next);\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    public List<Point2> minPath(Point2 start, Point2 end, Set<Point2> blocks) {\n        HashMap<Point2, Point2> visitedToLast = new HashMap<>();\n        Queue<Point2> explore = new LinkedList<>();\n        List<Point2> path = new ArrayList<>();\n        boolean isFound = false;\n        explore.offer(start);\n        visitedToLast.put(start, null);\n        while (!explore.isEmpty() && !isFound) {\n            Point2 point = explore.poll();\n            for (int k = 0; k < 4; k++) {\n                int nextX = point.x + X[k];\n                int nextY = point.y + Y[k];\n                Point2 next = new Point2(nextX, nextY);\n                if (!visitedToLast.containsKey(next) && !blocks.contains(next)) {\n                    visitedToLast.put(next, point);\n                }\n                if (next.equals(end)) {\n                    isFound = true;\n                    // visitedToLast.put(end, next);\n                }\n            }\n        }\n        Point2 mover = end;\n        while (mover != null) {\n            path.add(0, mover);\n            mover = visitedToLast.get(mover);\n        }\n        return path;\n    }\n}",
        "tags": "19",
        "companies": "",
        "specialtags": "1"
    },
    {
        "id": 439,
        "number": 11013,
        "title": "Bidirectional Search",
        "difficulty": "Medium",
        "description": "<p>Bidirectional search is a graph search algorithm which find smallest path form source to goal vertex.\n    It runs two simultaneous search – </p>\n\n<ol>\n    <li>Forward search form source/initial vertex toward goal vertex</li>\n    <li>Backward search form goal/target vertex toward source vertex</li>\n</ol>\n\n<p>Bidirectional search replaces single search graph(which is likely to grow exponentially)\n    with two smaller sub graphs – one starting from initial vertex and other starting from goal vertex.\n    <strong>The search terminates when two graphs intersect.</strong></p>\n\n<p align=\"center\"><strong>Why bidirectional approach?</strong></p>\n\n<p>\"In traditional breadth-first search, we would search up to k nodes in the first \"level\" of the search.\n    In the second level, we would search up to k nodes for each of those first k nodes,\n    so k^2 nodes total (thus far). We would do this d times, so that's O(k^d) nodes.</p>\n\n<p>\"In bidirectional search, we have two searches that collide after approximately d/2 levels\n    ( the midpoint of the path). The search from s visits approximately k^(d/2), as does the search from t.\n    That's approximately 2k^(d/2), or O(k^(d/2)), nodes total.\"</p>",
        "solution": "public static class Node {\n    private final T data;\n    private final Set<Node> adjacent = new HashSet<Node>();\n\n    public Set<Node> getAdjacent() {\n        return adjacent;\n    }\n\n    public Node(T data) {\n        this.data = data;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    // returns if the node was added, false if already there\n    public boolean addAdjacent(Node node) {\n        return adjacent.add(node);\n    }\n\n    // returns true if any were added\n    public boolean addAdjacents(Set<Node> nodes) {\n        return adjacent.addAll(nodes);\n    }\n}\n\nclass Solution {\n    public static boolean pathExistsBidirectional(Node a, Node b) {\n        // BFS on both nodes at the same time\n        Queue<Node> queueA = new Queue<Node>();\n        Queue<Node> queueB = new Queue<Node>();\n        Set<Node> visitedA = new HashSet<Node>();\n        Set<Node> visitedB = new HashSet<Node>();\n\n        visitedA.add(a);\n        visitedB.add(b);\n        queueA.add(a);\n        queueB.add(b);\n\n        while (!queueA.isEmpty() && !queueB.isEmpty()) {\n            if (pathExistsBidirectionalHelper(queueA, visitedA, visitedB)) {\n                return true;\n            }\n            if (pathExistsBidirectionalHelper(queueB, visitedB, visitedA)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean pathExistsBidirectionalHelper(Queue<Node> queue, Set<Node> visitedFromThisSide, Set<Node> visitedFromThatSide) {\n        if (!queue.isEmpty()) {\n            Node next = queue.remove();\n            for (Node adjacent : next.getAdjacent()) {\n                if (visitedFromThatSide.contains(adjacent)) {\n                    return true;\n                } else if (visitedFromThisSide.add(adjacent)) {\n                    queue.add(adjacent);\n                }\n            }\n        }\n        return false;\n    }\n}",
        "tags": "19",
        "companies": "",
        "specialtags": "1"
    }
]